<!doctype html><html lang=zh class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.83.1"><link rel=canonical type=text/html href=/web/zh/docs/user-guide/platform-console/addon-mgmt/><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel="shortcut icon" href=/web/favicons/favicon.ico><link rel=apple-touch-icon href=/web/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/web/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/web/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/web/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/web/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/web/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/web/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/web/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/web/favicons/android-192x192.png sizes=192x192><title>扩展组件 | Tkestack</title><meta name=description content="生产级别多集群管理系统"><meta property="og:title" content="扩展组件"><meta property="og:description" content="扩展组件
"><meta property="og:type" content="website"><meta property="og:url" content="/web/zh/docs/user-guide/platform-console/addon-mgmt/"><meta property="og:site_name" content="Tkestack"><meta itemprop=name content="扩展组件"><meta itemprop=description content="扩展组件
"><meta name=twitter:card content="summary"><meta name=twitter:title content="扩展组件"><meta name=twitter:description content="扩展组件
"><link rel=preload href=/web/scss/main.min.f3f5e11928ea652eef8f11ab959efa477bbd1a85923ff5e0245c83fe74bd312a.css as=style><link href=/web/scss/main.min.f3f5e11928ea652eef8f11ab959efa477bbd1a85923ff5e0245c83fe74bd312a.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar"><a class=navbar-brand href=/web/zh/><span class=navbar-logo></span><span class="text-uppercase font-weight-bold">Tkestack</span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/web/zh/docs/><span>Docs</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/web/zh/blog/><span>Blog</span></a></li><li class="nav-item dropdown d-none d-lg-block"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>中文 Chinese</a><div class=dropdown-menu aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/web/>English</a></div></li></ul></div><div class="navbar-nav d-none d-lg-block"></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"></div><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"></div><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.</p><p><a href=/web/zh/docs/user-guide/platform-console/addon-mgmt/>返回本页常规视图</a>.</p></div><h1 class=title>扩展组件</h1><div class=lead>扩展组件</div><ul><li>1: <a href=#pg-f8882211bf86e03e9ad6a7593f6389f4>TApp 介绍</a></li><li>2: <a href=#pg-36486ddbc5cae072d21407bccf243040>CronHPA 介绍</a></li><li>3: <a href=#pg-10c69052f011daaf2098d301331d233d>监控组件</a></li><li>4: <a href=#pg-6dcd138c670444e4d6bd8c3e521b6e9d>LogAgent 介绍</a></li><li>5: <a href=#pg-901ced327a8b1d8464a48213006e87cc>GPUManager 介绍</a></li><li>6: <a href=#pg-1908a7f2ad115ef0bc6b1cde68a4cc21>CSIOperator 介绍</a></li></ul><div class=content><h1 id=扩展组件>扩展组件</h1><h2 id=概念>概念</h2><p><strong>这里用户可以管理集群扩展组件。</strong></p><h2 id=操作步骤>操作步骤</h2><h3 id=创建组件>创建组件</h3><ul><li>登录 TKEStack。</li><li>切换至 【平台管理】控制台，选择【扩展组件】页面。</li><li>选择需要安装组件的集群，点击【新建】按钮。如下图所示：</li></ul><p><img src=../../../../../images/%E6%96%B0%E5%BB%BA%E6%89%A9%E5%B1%95%E7%BB%84%E4%BB%B6.png alt=&#x65B0;&#x5EFA;&#x7EC4;&#x4EF6;></p><blockquote><p>注意：此页面右边的【删除】按钮可以删除安装了的组件</p></blockquote><ul><li>在弹出的扩展组件列表里，选择要安装的组件。如下图所示：</li></ul><p><img src=../../../../../images/%E9%80%89%E6%8B%A9%E6%89%A9%E5%B1%95%E7%BB%84%E4%BB%B6.png alt=&#x9009;&#x62E9;&#x6269;&#x5C55;&#x7EC4;&#x4EF6;></p><blockquote><p>注意：如果选择的是PersistentEvent，需要在下方输入地址和索引。</p></blockquote><ul><li>单击【完成】。</li></ul></div></div><div class=td-content style=page-break-before:always><h1 id=pg-f8882211bf86e03e9ad6a7593f6389f4>1 - TApp 介绍</h1><div class=lead>TApp 介绍</div><h2 id=tapp-介绍>TApp 介绍</h2><p>Kubernetes 现有应用类型（如：Deployment、StatefulSet等）无法满足很多非微服务应用的需求。比如：操作（升级、停止等）应用中的指定 Pod；应用支持多版本的 Pod。如果要将这些应用改造为适合于这些 Workload 的应用，需要花费很大精力，这将使大多数用户望而却步。</p><p>为解决上述复杂应用管理场景，TKEStack 基于 Kubernetes <a href=https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/>CRD</a> 开发了一种新的应用类型 <a href=https://github.com/tkestack/tapp><strong>TApp</strong></a>，它是一种通用类型的 Workload，同时支持 service 和 batch 类型作业，满足绝大部分应用场景，它能让用户更好的将应用迁移到 Kubernetes 集群。</p><h2 id=tapp-架构>TApp 架构</h2><p>TAPP 其结构定义见 <a href=https://github.com/tkestack/tapp/blob/master/pkg/apis/tappcontroller/v1/types.go#L41>TAPP struct</a>。TApp Controller 是 TApp 对应的Controller/<a href=https://coreos.com/operators/>operator</a>，它通过 kube-apiserver 监听 TApp、Pod 相关的事件，根据 TApp 的 spec 和 status 进行相应的操作：创建、删除pod等。</p><p><img src=../../../../../images/image%20%28105%29.png alt></p><h3 id=tapp-使用场景>TApp 使用场景</h3><p>Kubernetes 凭借其强大的声明式 API、丰富的特性和可扩展性，逐渐成为容器编排领域的霸主。越来越多的用户希望使用 Kubernetes，将现有的应用迁移到 Kubernetes 集群，但 Kubernetes 现有 Workload（如：<code>Deployment</code>、<code>StatefulSet</code>等）无法满足很多非微服务应用的需求，比如：操作（升级、停止等）应用中的指定 Pod、应用支持多版本的 Pod。如果要将这些应用改造为适合于这些 Workload的应用，需要花费很大精力，这将使大多数用户望而却步。</p><p>腾讯有着多年的容器编排经验，基于 Kuberentes CRD（Custom Resource Definition，使用声明式API方式，无侵入性，使用简单）开发了一种新的 Workload 类型 TApp，它是一种通用类型的 Workload，同时支持 service 和 batch 类型作业，满足绝大部分应用场景，它能让用户更好的将应用迁移到 Kubernetes 集群。如果用 Kubernetes 的 Workload 类比，TAPP ≈ Deployment + StatefulSet + Job ，它包含了 Deployment、StatefulSet、Job 的绝大部分功能，同时也有自己的特性，并且和原生 Kubernetes 相同的使用方式完全一致。经过这几年用户反馈， TApp 也得到了逐渐的完善。</p><h3 id=tapp-特点>TApp 特点</h3><ol><li><strong>同时支持 service 和 batch 类型作业</strong>。通过 RestartPolicy 来对这两种作业进行区分。RestartPolicy值有三种：RestartAlways、Never、OnFailure<ol><li><strong>RestartAlways</strong>：表示 Pod 会一直运行，如果结束了也会被重新拉起（适合 service 类型作业）</li><li><strong>Never</strong>：表示 Pod 结束后就不会被拉起了（适合 batch 类型作业）</li><li><strong>OnFailure</strong>：表示 Pod 结束后，如果 exit code 非0，将会被拉起，否则不会（适合 batch 类型作业）</li></ol></li><li><strong>固定ID</strong>：每个实例（Pod）都有固定的 ID(0, 1, 2 … N-1，其中N为实例个数)，它们的名字由 <strong>TApp 名字+ID</strong> 组成，因此名字也是唯一的。 有了固定的ID和名字后，我们便可以实现如下能力：<ol><li>将实例用到的各种资源（将实例用到的存储资源(如：云硬盘)，或者是IP）和实例一一对应起来，这样即使实例发生迁移，实例对应的各种资源也不会变</li><li>通过固定 ID，我们可以为实例分配固定的 IP（float ip）。</li><li>唯一的实例名字还可用来跟踪实例完整的生命周期，对于同一个实例，可以由于机器故障发生了迁移、重启等操作，虽然不是一个 Pod 了，但是我们用实例 ID 串联起来，就获得了实例真正的生命周期的跟踪，对于判断业务和系统是否正常服务具有特别重要的意义</li></ol></li><li><strong>操作指定实例</strong>：有了固定的 ID，我们就能操作指定实例。我们遵循了 Kubernetes 声明式的 API，在 spec 中 statuses 记录实例的目标状态， instances 记录实例要使用的 template，用于停止、启动、升级指定实例。</li><li><strong>支持多版本实例</strong>：在 TApp spec 中，不同的实例可以指定不同的配置（image、resource 等）、不同的启动命令等，这样一个应用可以存在多个版本实例。</li><li><strong>原地更新(in place update)</strong>：Kubernetes 的更新策略是删除旧 Pod，新建一个 Pod，然后调度等一系列流程，才能运行起来，而且 Pod原先的绑定的资源（本地磁盘、IP 等）都会变化。TApp 对此进行了优化：如果只修改了 container 的 image，TApp 将会对该 Pod 进行本地更新，原地重启受影响的容器，本地磁盘不变，IP 不变，最大限度地降低更新带来的影响，这能极大地减少更新带来的性能损失以及服务不可用。</li><li><strong>云硬盘</strong>：云硬盘的底层由分布式存储 Ceph 支持，能很好地支持有状态的作业。在实例发生跨机迁移时，云硬盘能跟随实例一起迁移。TApp 提供了多种云硬盘类型供选择。</li><li><strong>多种升级发布方式</strong>：TApp除了支持常规的蓝绿布署、滚动发布、金丝雀部署等升级发布方式，还有其特有的升级发布方式：用户可以指定升级任意的实例。</li><li><strong>自动扩缩容</strong>：根据 CPU/MEM/用户自定义指标对 TAPP 进行自动扩缩容。 除了自动扩缩容，我们还开发了周期性扩缩容 <a href=https://github.com/tkestack/tke/blob/master/hack/addon/readme/CronHPA.md>CronHPA</a> 支持对 TApp 等(包括 Kubernetes 原生的 Deployment 和 StatefulSet)进行周期性扩缩容，支持 CronTab 语法格式，满足对资源使用有周期性需求的业务。</li><li><strong>Gang scheduling</strong>：有些应用必须要等到获取到资源能运行的实例达到一定数量后才开始运行，TApp 提供的 <a href=https://en.wikipedia.org/wiki/Gang_scheduling>Gang scheduling</a> 正是处理这种情况的。</li></ol><p><img src=../../../../../images/image%20%2871%29.png alt></p><h3 id=部署在集群内-kubernetes-对象>部署在集群内 kubernetes 对象</h3><p>在集群内部署 TApp Add-on , 将在集群内部署以下 kubernetes 对象</p><table><thead><tr><th style=text-align:left>kubernetes 对象名称</th><th style=text-align:left>类型</th><th style=text-align:left>默认占用资源</th><th style=text-align:left>所属Namespaces</th></tr></thead><tbody><tr><td style=text-align:left>tapp-controller</td><td style=text-align:left>Deployment</td><td style=text-align:left>每节点1核CPU, 512MB内存</td><td style=text-align:left>kube-system</td></tr><tr><td style=text-align:left>tapps.apps.tkestack.io</td><td style=text-align:left>CustomResourceDefinition</td><td style=text-align:left>/</td><td style=text-align:left>/</td></tr><tr><td style=text-align:left>tapp-controller</td><td style=text-align:left>ServiceAccount</td><td style=text-align:left>/</td><td style=text-align:left>kube-system</td></tr><tr><td style=text-align:left>tapp-controller</td><td style=text-align:left>Service</td><td style=text-align:left>/</td><td style=text-align:left>kube-system</td></tr><tr><td style=text-align:left>tapp-controller</td><td style=text-align:left>ClusterRoleBinding（ClusterRole/cluster-admin）</td><td style=text-align:left>/</td><td style=text-align:left>/</td></tr></tbody></table><h2 id=tapp-使用方法>TApp 使用方法</h2><h3 id=安装-tapp-组件>安装 TApp 组件</h3><ul><li>登录 TKEStack</li><li>切换至 平台管理 控制台，选择扩展组件页面</li><li>选择需要安装组件的集群，点击【新建】按钮。如下图所示：</li></ul><p><img src=../../../../../images/image%20%2849%29.png alt></p><ul><li>在弹出的扩展组件列表里，滑动列表窗口找到tapp组件。如下图所示：</li></ul><p><img src=../../../../../images/image%20%2820%29.png alt></p><ul><li><p>单击【完成】</p><p>安装完成后会在刚刚安装了 TApp 扩展组件的集群里 【工作负载】下面出现【TApp】，如下图所示：</p></li></ul><p><img src=../../../../../images/image%20%2890%29.png alt></p><h3 id=使用-tapp-组件>使用 TApp 组件</h3><p>在 TKEStack 控制台上使用 TApp 使用请参考：<a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/products/business-control-pannel/application/workload/tapp.md>TApp Workload</a></p><p>对 TApp 架构和命令行使用请参考：<a href=https://github.com/tkestack/tapp/blob/master/doc/tutorial.md>TApp Repository</a></p><h2 id=参考>参考</h2><h3 id=手动部署-tapp>手动部署 TApp</h3><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>git clone https://github.com/tkestack/tapp.git
cd tapp
make build
bin/tapp-controller --kubeconfig=$HOME/.kube/config
</code></pre></div><h3 id=原地升级>原地升级</h3><p>修改 <code>spec.templatePool.{templateName}.spec.containers.image</code> 的值实现原地升级。</p><p>挂在存储卷后的 Pod 依旧在 image 升级的时候没有任何影响，同时 PVC 也没有改变，唯一改变的只有镜像本身。</p><h3 id=部分关键字解释>部分关键字解释</h3><table><thead><tr><th style=text-align:left>关键字</th><th style=text-align:left>作用</th></tr></thead><tbody><tr><td style=text-align:left>spec.templatePool</td><td style=text-align:left>模版池</td></tr><tr><td style=text-align:left>spec.templates</td><td style=text-align:left>以键值对（Pod 序号：模板池中的模板名）的形式具体声明每一个 Pod 的状态</td></tr><tr><td style=text-align:left>spec.template 等价于 spec.DefaultTemplateName</td><td style=text-align:left>默认模板（在spec.templates中没有定义的 Pod 序号将使用该模板）</td></tr><tr><td style=text-align:left>updateStrategy.inPlaceUpdateStrategy</td><td style=text-align:left>原地升级策略</td></tr><tr><td style=text-align:left>spec.updateStrategy</td><td style=text-align:left>保留旧版本 Pod 的数量，默认为 0，类似于灰度发布</td></tr><tr><td style=text-align:left>spec.updateStrategy.template</td><td style=text-align:left>要设置 maxUnavailable 值的 template 名</td></tr><tr><td style=text-align:left>spec.updateStrategy.maxUnavailable</td><td style=text-align:left>最大的不可用 Pod 数量（默认为1，可设置成一个自然数，或者一个百分比，例如 50%）</td></tr><tr><td style=text-align:left>spec.statuses</td><td style=text-align:left>明确 Pod 的状态，TApp 会实现该状态</td></tr></tbody></table><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>apiVersion: apps.tkestack.io/v1
kind: TApp
metadata:
  name: example-tapp
spec:
  replicas: 3
  # 默认模板
  template:
    metadata:
      labels:
        app: example-tapp
    spec:
      containers:
      - name: nginx
        image: nginx:latest
  # 模板池
  templatePool:
  	# 模板池中的模板
    &#34;test2&#34;:
      metadata:
        labels:
          app: example-tapp
      spec:
        containers:
        - name: nginx
          image: nginx:1.7.9
  # 要使用模板池中模板的 Pod
  templates:
    # Pod 序号：模板池中的模板
    &#34;1&#34;: &#34;test2&#34;
    &#34;2&#34;: &#34;test2&#34;
  # 更新策略
  updateStrategy:
    # 更新指定模板。test2该模板有过修改，或者是在模板池里新增的，都可以通过 updateStrategy 设置模板来进行滚动更新
    template: test2
    # 使用该模板的 Pod 在更新时最大不可用的数量
    maxUnavailable: 1
  # 明确 Pod 的状态，TApp 会实现该状态
  statuses:
    # 编号为1的 Pod 将被 Kill
    &#34;1&#34;: &#34;Killed&#34;
</code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-36486ddbc5cae072d21407bccf243040>2 - CronHPA 介绍</h1><div class=lead>CronHPA 介绍</div><h2 id=cronhpa-介绍>CronHPA 介绍</h2><p>Cron Horizontal Pod Autoscaler(<a href=https://github.com/tkestack/cron-hpa>CronHPA</a>) 可让用户利用 <a href=https://en.wikipedia.org/wiki/Cron>CronTab</a> 实现对负载（Deployment、StatefulSet、<a href=https://github.com/tkestack/tke/blob/master/hack/addon/readme/TappController.md>TApp</a> 这些支持扩缩容的资源对象）<strong>定期自动扩缩容</strong>。</p><p><a href=https://en.wikipedia.org/wiki/Cron>CronTab</a> 格式说明如下：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text># 文件格式说明
#  ——分钟（0 - 59）
# |  ——小时（0 - 23）
# | |  ——日（1 - 31）
# | | |  ——月（1 - 12）
# | | | |  ——星期（0 - 6）
# | | | | |
# * * * * *
</code></pre></div><p>CronHPA 定义了一个新的 CRD，cron-hpa-controller 是该 CRD 对应的 Controller/operator，它解析 CRD 中的配置，根据系统时间信息对相应的工作负载进行扩缩容操作。</p><h3 id=cronhpa-使用场景>CronHPA 使用场景</h3><p>以游戏服务为例，从星期五晚上到星期日晚上，游戏玩家数量暴增。如果可以将游戏服务器在星期五晚上扩大规模，并在星期日晚上缩放为原始规模，则可以为玩家提供更好的体验。这就是游戏服务器管理员每周要做的事情。</p><p>其他一些服务也会存在类似的情况，这些产品使用情况会定期出现高峰和低谷。CronHPA 可以自动化实现提前扩缩 Pod，为用户提供更好的体验。</p><h3 id=部署在集群内-kubernetes-对象>部署在集群内 kubernetes 对象</h3><p>在集群内部署 CronHPA Add-on , 将在集群内部署以下 kubernetes 对象：</p><table><thead><tr><th style=text-align:left>kubernetes 对象名称</th><th style=text-align:left>类型</th><th style=text-align:left>默认占用资源</th><th style=text-align:left>所属 Namespaces</th></tr></thead><tbody><tr><td style=text-align:left>cron-hpa-controller</td><td style=text-align:left>Deployment</td><td style=text-align:left>每节点1核 CPU, 512MB内存</td><td style=text-align:left>kube-system</td></tr><tr><td style=text-align:left>cronhpas.extensions.tkestack.io</td><td style=text-align:left>CustomResourceDefinition</td><td style=text-align:left>/</td><td style=text-align:left>/</td></tr><tr><td style=text-align:left>cron-hpa-controller</td><td style=text-align:left>ClusterRoleBinding（ClusterRole/cluster-admin）</td><td style=text-align:left>/</td><td style=text-align:left>/</td></tr><tr><td style=text-align:left>cron-hpa-controller</td><td style=text-align:left>ServiceAccount</td><td style=text-align:left>/</td><td style=text-align:left>kube-system</td></tr></tbody></table><h2 id=cronhpa-使用方法>CronHPA 使用方法</h2><h3 id=安装-cronhpa>安装 CronHPA</h3><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【扩展组件】页面</li><li>选择需要安装组件的集群，点击【新建】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%28128%29.png alt></p><ul><li>在弹出的扩展组件列表里，滑动列表窗口找到 CronHPA 组件</li><li>单击【完成】</li></ul><h3 id=在控制台上使用-cronhpa>在控制台上使用 CronHPA</h3><p>TKEStack 已经支持在页面多处位置为负载配置 CronHPA</p><ul><li>新建负载页（负载包括Deployment、StatefulSet、TApp）这里新建负载时将会同时新建与负载同名的 CronHPA 对象：</li></ul><p><img src=../../../../../images/image%20%2897%29.png alt></p><p>每条触发策略由两条字段组成</p><ol><li><strong>Crontab</strong> ：例如 &ldquo;0 23 * * 5"表示每周五23:00，详见<a href=https://en.wikipedia.org/wiki/Cron>crontab</a></li><li><strong>目标实例数</strong> ：设置实例数量</li></ol><ul><li>自动伸缩的 CronHPA 列表页。此处可以查看/修改/新建 CronHPA：</li></ul><p><img src=../../../../../images/image%20%2815%29.png alt></p><h3 id=通过-yaml-使用-cronhpa>通过 YAML 使用 CronHPA</h3><h4 id=创建-cronhpa-对象>创建 CronHPA 对象</h4><p>示例1：指定 Deployment 每周五20点扩容到60个实例，周日23点缩容到30个实例</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>apiVersion: extensions.tkestack.io/v1
kind: CronHPA
metadata:
  name: example-cron-hpa	# CronHPA 名
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment	# CronHPA 操作的负载类型
    name: demo-deployment	# CronHPA 操作的负载类型名
  crons:
    - schedule: &#34;0 20 * * 5&#34;	# Crontab 语法格式
      targetReplicas: 60			# 负载副本（Pod）的目标数量
    - schedule: &#34;0 23 * * 7&#34;
      targetReplicas: 30
</code></pre></div><p>示例2：指定 Deployment 每天8点到9点，19点到21点扩容到60，其他时间点恢复到10</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>apiVersion: extensions.tkestack.io/v1
kind: CronHPA
metadata:
  name: web-servers-cronhpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: web-servers
  crons:
    - schedule: &#34;0 8 * * *&#34;
      targetReplicas: 60
    - schedule: &#34;0 9 * * *&#34;
      targetReplicas: 10
    - schedule: &#34;0 19 * * *&#34;
      targetReplicas: 60
    - schedule: &#34;0 21 * * *&#34;
      targetReplicas: 10
</code></pre></div><h4 id=查看已有-cronhpa>查看已有 CronHPA</h4><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text># kubectl get cronhpa
NAME               AGE
example-cron-hpa   104s

# kubectl get cronhpa example-cron-hpa -o yaml
apiVersion: extensions.tkestack.io/v1
kind: CronHPA
...
spec:
  crons:
  - schedule: 0 20 * * 5
    targetReplicas: 60
  - schedule: 0 23 * * 7
    targetReplicas: 30
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: demo-deployment
</code></pre></div><h4 id=删除已有-cronhpa>删除已有 CronHPA</h4><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl delete cronhpa example-cron-hpa
</code></pre></div><p>CronHPA 项目请参考 <a href=https://github.com/tkestack/cron-hpa>CronHPA Repository</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-10c69052f011daaf2098d301331d233d>3 - 监控组件</h1><div class=lead>监控组件</div><h2 id=prometheus>Prometheus</h2><p>良好的监控环境为 TKEStack 高可靠性、高可用性和高性能提供重要保证。您可以方便为不同资源收集不同维度的监控数据，能方便掌握资源的使用状况，轻松定位故障。</p><p>TKEStack 使用开源的 Prometheus 作为监控组件，免去您部署和配置 Prometheus 的复杂操作，TKEStack 提供高可用性和可扩展性的细粒度监控系统，实时监控 CPU，GPU，内存，显存，网络带宽，磁盘 IO 等多种指标并自动绘制趋势曲线，帮助运维人员全维度的掌握平台运行状态。</p><p>TKEStack 使用 Prometheus 的架构和原理可以参考 <a href=https://github.com/tkestack/tke/blob/master/hack/addon/readme/Prometheus.md>Prometheus 组件</a></p><blockquote><p>指标具体含义可参考：<a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/FAQ/Platform/alert&monitor-metrics.md>监控 & 告警指标列表</a></p></blockquote><p><img src=../../../../../images/image%20%2873%29.png alt></p><p>TKEStack 通过 Prometheus 组件监控集群状态，Prometheus 组件通过 addon 扩展组件自动完成安装和配置，使用 InfluxDB，ElasticSearch 等存储监控数据。监控数据和指标融入到平台界面中以风格统一图表的风格展示，支持以不同时间，粒度等条件，查询集群，节点，业务，Workload 以及容器等多个层级的监控数据，全维度的掌握平台运行状态。</p><p>同时针对在可用性和可扩展性方面，支持使用 Thanos 架构提供可靠的细粒度监控和警报服务，构建具有高可用性和可扩展性的细粒度监控能力。</p><h3 id=安装-prometheus>安装 Prometheus</h3><p>Prometheus 为 TKEStack 扩展组件，需要在集群的 <a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/products/platform/cluster.md#%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF>【基本信息】</a> 页下面开启 “监控告警”。</p><p><img src=../../../../../images/image%20%2836%29.png alt></p><h3 id=集群监控>集群监控</h3><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【集群管理】</li><li>点击【监控】图标，如下图所示：</li></ul><p><img src=../../../../../images/image%20%28141%29.png alt></p><ul><li>监控数据展示</li><li>通过下图中的1可以选择监控数据时间段</li><li>通过下图中的2可以选择统计粒度，以下图中“APIServer时延”为例，下图中的每个数据表示前1分钟“APIServer时延”平均数</li></ul><p><img src=../../../../../images/image%20%2824%29.png alt></p><ul><li>上下滑动曲线图可以获得更多监控指标</li><li>点击曲线图，会弹出具体时间点的具体监控数据</li></ul><p><img src=../../../../../images/image%20%2863%29.png alt></p><blockquote><p>指标具体含义可参考：<a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/FAQ/Platform/alert&monitor-metrics.md>监控 & 告警指标列表</a></p></blockquote><h3 id=节点监控>节点监控</h3><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【集群管理】</li><li>点击【集群 ID】 -> 【节点管理】->【节点】->【监控】图标，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2839%29.png alt></p><ul><li><p>具体查看方式和<a href>集群监控</a>完全一致</p><blockquote><p>指标具体含义可参考：<a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/FAQ/Platform/alert&monitor-metrics.md>监控 & 告警指标列表</a></p></blockquote></li><li><p>此处还可以查看节点下的 Pod 监控</p><ol><li>如下图所示，对比维度可选择 节点 或 Pod</li><li>选择 Pod ，需要在其右侧选择 Pod 所属节点</li></ol></li></ul><p><img src=../../../../../images/image%20%28139%29.png alt></p><h4 id=节点下的-pod--container-监控>节点下的 Pod & Container 监控</h4><p>有两种方式</p><ul><li><a href>节点监控</a> 下选择 Pod 进行监控</li><li>在节点列表里，点击节点名，进入节点的 Pod 管理页，如下图所示，点击上方的【监控】按钮，实现对节点下的 Pod 监控</li></ul><p><img src=../../../../../images/image%20%286%29.png alt></p><blockquote><p>注意：此处还可以查看节点下的 Container 监控</p><ol><li>如下图所示，对比维度可选择 Pod 或 Container</li><li>选择 Container ，需要在其右侧选择 Container 所属 Pod</li></ol></blockquote><p><img src=../../../../../images/image%20%2850%29.png alt></p><p>指标具体含义可参考：<a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/FAQ/Platform/alert&monitor-metrics.md>监控 & 告警指标列表</a></p><h3 id=负载监控>负载监控</h3><ul><li><p>登录 TKEStack</p></li><li><p>切换至【平台管理】控制台，选择【集群管理】</p></li><li><p>点击【集群 ID】 -> 【工作负载】->【选择一种负载，例如 Deployment】->【监控】图标，如下图所示：</p></li><li><p>具体查看方式和<a href>集群监控</a>完全一致</p><blockquote><p>指标具体含义可参考：<a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/FAQ/Platform/alert&monitor-metrics.md>监控 & 告警指标列表</a></p></blockquote></li></ul><h4 id=负载下-pod--container-监控>负载下 Pod & Container 监控</h4><ol><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【集群管理】</li><li>点击【集群 ID】 -> 【工作负载】->【选择一种负载】，例如 Deployment】->【点击一个负载名】->【监控】图标，如下图所示：</li></ol><p><img src=../../../../../images/image%20%2872%29.png alt></p><blockquote><p>注意：此处还可以查看负载下的 Container 监控</p><ol><li>如下图所示，对比维度可选择 Pod 或 Container</li><li>选择 Container ，需要在其右侧选择 Container 所属 Pod 指标具体含义可参考：<a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/FAQ/Platform/alert&monitor-metrics.md>监控 & 告警指标列表</a></li></ol></blockquote><p><img src=../../../../../images/image%20%28132%29.png alt></p><p>TKEStack 使用 Prometheus 的架构和原理可以参考 <a href=https://github.com/tkestack/tke/blob/master/hack/addon/readme/Prometheus.md>Prometheus 组件</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-6dcd138c670444e4d6bd8c3e521b6e9d>4 - LogAgent 介绍</h1><div class=lead>LogAgent 介绍</div><h2 id=日志采集>日志采集</h2><h3 id=logagent-介绍>LogAgent 介绍</h3><p>TKESTack 通过 logagent 提供的集群内日志采集功能，支持将集群内服务或集群节点特定路径文件的日志发送至 Kafka、Elasticsearch 等消费端，支持采集容器标准输出日志，容器内文件日志以及主机内文件日志。更提供事件持久化、审计等功能，实时记录集群事件及操作日志记录，帮助运维人员存储和分析集群内部资源生命周期、资源调度、异常告警等情况。</p><p><img src=../../../../../images/image%20%2823%29.png alt></p><blockquote><p>TKEStack 老版本日志使用 LogCollector 扩展组件。LogAgent 用于替换 LogCollector，新版本统一用 LogAgent 完成日志采集功能。</p></blockquote><p>日志收集功能需要为每个集群手动开启。日志收集功能开启后，日志收集组件 logagent 会在集群内以 Daemonset 的形式运行。用户可以通过日志收集规则配置日志的采集源和消费端，日志收集 Agent 会从用户配置的采集源进行日志收集，并将日志内容发送至用户指定的消费端。需要注意的是，<strong>使用日志收集功能需要您确认 Kubernetes 集群内节点能够访问日志消费端。</strong></p><ul><li><strong>采集容器标准输出日志</strong> ：采集集群内指定<strong>容器的 Stderr 和 Stdout 日志。</strong>，采集到的日志信息将会以 JSON 格式输出到用户指定的消费端，并会自动附加相关的 Kubernetes metadata， 包括容器所属 Pod 的 label 和 annotation 等信息。</li><li><strong>采集容器内文件日志</strong> ：采集集群内指定<strong>容器内文件路径的日志</strong>，用户可以根据自己的需求，灵活的配置所需的容器和路径，采集到的日志信息将会以 JSON 格式输出到用户指定的消费端， 并会附加相关的 Kubernetes metadata，包括容器所属 Pod 的 label 和 annotation 等信息。</li><li><strong>采集主机内文件日志</strong> ：采集集群内所有节点的指定<strong>主机文件路径的日志</strong>，logagent 会采集集群内所有节点上满足指定路径规则的文件日志，以 JSON 格式输出到用户指定的输出端， 并会附加用户指定的 metadata，包括日志来源文件的路径和用户自定义的 metadata。</li></ul><h4 id=部署在集群内-kubernetes-对象>部署在集群内 kubernetes 对象</h4><p>在集群内部署 logagent Add-on , 将在集群内部署以下 kubernetes 对象</p><table><thead><tr><th style=text-align:left>kubernetes 对象名称</th><th style=text-align:left>类型</th><th style=text-align:left>默认占用资源</th><th style=text-align:left>所属Namespaces</th></tr></thead><tbody><tr><td style=text-align:left>logagent</td><td style=text-align:left>DaemonSet</td><td style=text-align:left>每节点0.3核 CPU, 250MB 内存</td><td style=text-align:left>kube-system</td></tr><tr><td style=text-align:left>logagent</td><td style=text-align:left>ServiceAccount</td><td style=text-align:left></td><td style=text-align:left>kube-system</td></tr></tbody></table><h3 id=使用日志采集服务>使用日志采集服务</h3><blockquote><p>注意：日志采集对接外部 Kafka 或 Elasticsearch，该功能需要额外开启，位置在集群 <a href=https://github.com/tkestack/tke/blob/master/hack/platform/cluster.md#%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF>基本信息</a> 下面，点击开启“日志采集”服务。</p></blockquote><p><img src=../../../../../images/image%20%2828%29.png alt></p><h4 id=业务管理侧>业务管理侧</h4><ul><li>登录 TKEStack</li><li>切换至【业务管理】控制台，选择 【运维中心】->【日志采集】</li><li>选择相应【业务】和【命名空间】，单击【新建】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%287%29.png alt></p><ul><li>在“新建日志采集”页面填写日志采集信息，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2847%29.png alt></p><ul><li><strong>收集规则名称：</strong> 输入规则名，1～63字符，只能包含小写字母、数字及分隔符("-")，且必须以小写字母开头，数字或小写字母结尾</li><li><strong>业务：</strong> 选择所属业务（业务管理侧才会出现）</li><li><strong>集群：</strong> 选择所属集群（平台管理侧才会出现）</li><li><strong>类型：</strong> 选择采集类型<ul><li><strong>容器标准输出：</strong> 容器 Stderr 和 Stdout 日志信息采集<ul><li><strong>日志源：</strong> 可以选择所有容器或者某个 Namespace 下的所有容器/工作负载<ul><li><strong>所有容器：</strong> 所有容器</li><li><strong>指定容器：</strong> 某个 Namespace 下的所有容器或者工作负载</li></ul></li></ul></li><li><strong>容器文件路径：</strong> 容器内文件内容采集<ul><li><p><strong>日志源：</strong> 可以采集具体容器内的某个文件路径下的文件内容</p><ul><li><strong>工作负载选项：</strong> 选择某个 Namespace 下的某种工作负载类型下的某个工作负载</li><li><strong>配置采集路径：</strong> 选择某个容器下的某个文件路径</li></ul><blockquote><ul><li>文件路径若输入<code>stdout</code>，则转为容器标准输出模式</li><li>可配置多个路径。路径必须以<code>/</code>开头和结尾，文件名支持通配符（*）。文件路径和文件名最长支持63个字符</li><li>请保证容器的日志文件保存在数据卷，否则收集规则无法生效，详见<a href>指定容器运行后的日志目录</a></li></ul></blockquote></li></ul></li><li><strong>节点文件路径：</strong> 收集节点上某个路径下的文件内容，不会重复采集，因为采集器会记住之前采集过的日志文件的位点，只采集增量部分<ul><li><strong>日志源：</strong> 可以采集具体节点内的某个文件路径下的文件内容<ul><li><strong>收集路径：</strong> 节点上日志收集路径。路径必须以<code>/</code>开头和结尾，文件名支持通配符（*）。文件路径和文件名最长支持63个字符</li><li><strong>metadata：</strong> key：value 格式，收集的日志会带上 metadata 信息上报给消费端</li></ul></li></ul></li></ul></li><li><strong>消费端：</strong> 选择日志消费端<ul><li><strong>Kafka：</strong><ul><li><strong>访问地址：</strong> Kafka IP 和端口</li><li><strong>主题（Topic）：</strong> Kafka Topic 名</li></ul></li><li><strong>Elasticsearch：</strong><ul><li><p><strong>Elasticsearch 地址：</strong> ES 地址，如：<a href=http://190.0.0.1:200/>http://190.0.0.1:200</a></p><blockquote><p>注意：当前只支持未开启用户登录认证的 ES 集群</p></blockquote></li><li><p><strong>索引：</strong> ES索引，最长60个字符，只能包含小写字母、数字及分隔符("-"、"_"、"+")，且必须以小写字母开头</p></li></ul></li></ul></li><li>单击【完成】按钮</li></ul><h4 id=平台管理侧>平台管理侧</h4><p>在平台管理侧也支持日志采集规则的创建，创建方式和业务管理处相同。详情可点击平台侧的<a href=https://github.com/tkestack/tke/blob/master/hack/platform/operation/log.md>日志采集</a>。</p><h4 id=指定容器运行后的日志目录>指定容器运行后的日志目录</h4><p>LogAgent 除了支持日志规则的创建，也支持指定容器运行后的日志目录，可实现日志文件展示和下载。</p><blockquote><p>前提：需要在创建负载时挂载数据卷，并指定日志目录</p></blockquote><p><img src=../../../../../images/image%20%28134%29.png alt></p><p>创建负载以后，在容器内的<code>/data/logdir</code>目录下的所有文件可以展示并下载，例如我们在容器的<code>/data/logdir</code>下新建一个名为<code>a.log</code>的文件，如果有内容的话，也可以在这里展示与下载：</p><p><img src=../../../../../images/image%20%2832%29.png alt></p></div><div class=td-content style=page-break-before:always><h1 id=pg-901ced327a8b1d8464a48213006e87cc>5 - GPUManager 介绍</h1><div class=lead>GPUManager 介绍</div><h2 id=gpumanager-介绍>GPUManager 介绍</h2><p><a href=https://github.com/tkestack/gpu-manager>GPUManager</a> 提供一个 All-in-One 的 GPU 管理器, 基于 Kubernets Device Plugin 插件系统实现，该管理器提供了分配并共享 GPU，GPU 指标查询，容器运行前的 GPU 相关设备准备等功能，支持用户在 Kubernetes 集群中使用 GPU 设备。</p><p>GPU-Manager 包含如下功能:</p><ul><li><strong>拓扑分配</strong>：提供基于 GPU 拓扑分配功能，当用户分配超过1张 GPU 卡的应用，可以选择拓扑连接最快的方式分配GPU设备</li><li><strong>GPU 共享</strong>：允许用户提交小于1张卡资源的的任务，并提供 QoS 保证</li><li><a href><strong>应用 GPU 指标的查询</strong></a>：用户可以访问主机的端口(默认为5678)的<code>/metrics</code> 路径，可以为 Prometheus 提供 GPU 指标的收集功能，<code>/usage</code> 路径可以提供可读性的容器状况查询</li></ul><h3 id=gpu-manager-使用场景>GPU-Manager 使用场景</h3><p>在 Kubernetes 集群中运行 GPU 应用时，可以解决 AI 训练等场景中申请独立卡造成资源浪费的情况，让计算资源得到充分利用。</p><h3 id=gpu-manager-限制条件>GPU-Manager 限制条件</h3><ol><li><p>该组件基于 Kubernetes DevicePlugin 实现，只能运行在支持 DevicePlugin 的 kubernetes版本（Kubernetes 1.10 之上的版本）</p></li><li><p>使用 GPU-Manager 要求集群内包含 GPU 机型节点</p></li><li><p>TKEStack 的 GPU-Manager 将每张 GPU 卡视为一个有100个单位的资源</p><blockquote><p>特别注意：</p><ol><li>当前仅支持 0-1 的小数张卡，如 20、35、50；以及正整数张卡，如200、500等；不支持类似150、250的资源请求</li><li>显存资源是以 256MiB 为最小的一个单位的分配显存</li></ol></blockquote></li></ol><h3 id=部署在集群内-kubernetes-对象>部署在集群内 kubernetes 对象</h3><p>在集群内部署 GPU-Manager，将在集群内部署以下 kubernetes 对象：</p><table><thead><tr><th style=text-align:left>kubernetes 对象名称</th><th style=text-align:left>类型</th><th style=text-align:left>建议预留资源</th><th style=text-align:left>所属 Namespaces</th></tr></thead><tbody><tr><td style=text-align:left>gpu-manager-daemonset</td><td style=text-align:left>DaemonSet</td><td style=text-align:left>每节点1核 CPU, 1Gi内存</td><td style=text-align:left>kube-system</td></tr><tr><td style=text-align:left>gpu-quota-admission</td><td style=text-align:left>Deployment</td><td style=text-align:left>1核 CPU, 1Gi内存</td><td style=text-align:left>kube-system</td></tr></tbody></table><h2 id=gpu-manager-使用方法>GPU-Manager 使用方法</h2><h3 id=安装-gpu-manager>安装 GPU-Manager</h3><p>集群部署阶段选择 vGPU，平台会为集群部署 GPU-Manager ，如下图新建独立集群所示，Global 集群的也是如此安装。</p><p><img src=../../../../../images/image%20%28117%29.png alt></p><h3 id=在节点安装-gpu-驱动>在节点安装 GPU 驱动</h3><p>集群部署阶段添加 GPU 节点时有勾选 GPU 选项，平台会自动为节点安装 GPU 驱动，如下图所示：</p><blockquote><p>注意：如果集群部署阶段节点没有勾选 GPU，需要自行在有 GPU 的节点上安装 GPU 驱动</p></blockquote><p><img src=../../../../../images/image%20%2877%29.png alt></p><h3 id=工作负载使用-gpu>工作负载使用 GPU</h3><h4 id=通过控制台使用>通过控制台使用</h4><p>在安装了 GPU-Manager 的集群中，创建工作负载时可以设置 GPU 限制，如下图所示：</p><blockquote><p>注意：</p><ol><li>卡数只能填写 0.1 到 1 之间的两位小数或者是所有自然数，例如：0、0.3、0.56、0.7、0.9、1、6、34，不支持 1.5、2.7、3.54</li><li>显存只能填写自然数 n，负载使用的显存为 n*256MiB</li></ol></blockquote><p><img src=../../../../../images/image%20%28109%29.png alt></p><h4 id=通过-yaml-使用>通过 YAML 使用</h4><p>如果使用 YAML 创建使用 GPU 的工作负载，提交的时候需要在 YAML 为容器设置 GPU 的使用资源。</p><ul><li>CPU 资源需要在 resource 上填写<code>tencent.com/vcuda-core</code></li><li>显存资源需要在 resource 上填写<code>tencent.com/vcuda-memory</code></li></ul><p>例1：使用1张卡的 Pod</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>apiVersion: v1

kind: Pod

...

spec:

  containers:

    - name: gpu

      resources:
        limits: 
          tencent.com/vcuda-core: 100
        requests:
          tencent.com/vcuda-core: 100
</code></pre></div><p>例2，使用 0.3 张卡、5GiB 显存的应用（5GiB = 20*256MB）</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>apiVersion: v1

kind: Pod

...

spec:

  containers:

  - name: gpu

    resources:
      limits:
        tencent.com/vcuda-core: 30
        tencent.com/vcuda-memory: 20
      requests:
        tencent.com/vcuda-core: 30
        tencent.com/vcuda-memory: 20
</code></pre></div><h2 id=gpu-监控数据查询>GPU 监控数据查询</h2><h3 id=通过控制台查询>通过控制台查询</h3><blockquote><p>前提：在集群的<a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/products/platform/cluster.md#%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF>【基本信息】</a>页里打开“监控告警”</p></blockquote><p>可以通过集群多个页面的监控按钮里查看到 GPU 的相关监控数据，下图以 集群管理 页对集群的监控为例：</p><p><img src=../../../../../images/image%20%2884%29.png alt></p><h3 id=通过后台手动查询>通过后台手动查询</h3><p>手动获取 GPU 监控数据方式（需要先安装 <a href=http://www.dest-unreach.org/socat/>socat</a>）：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl port-forward svc/gpu-manager-metric -n kube-system 5678:5678 &amp;
curl http://127.0.0.1:5678/metric
</code></pre></div><p>结果示例：</p><p><img src=../../../../../images/image%20%2848%29.png alt></p><p>GPUManager 项目请参考：<a href=https://github.com/tkestack/gpu-manager>GPUManager Repository</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-1908a7f2ad115ef0bc6b1cde68a4cc21>6 - CSIOperator 介绍</h1><div class=lead>CSIOperator 介绍</div><h2 id=csioperator>CSIOperator</h2><h3 id=csioperator-介绍>CSIOperator 介绍</h3><p>Container Storage Interface Operator(CSIOperator)用于部署和更新 Kubernetes 集群中的 CSI 驱动和外部存储组件。</p><h4 id=csioperator-使用场景>CSIOperator 使用场景</h4><p>CSIOperator 用于支持集群方便的使用存储资源，当前支持的存储插件包括 RBD、CephFS、TencentCBS 和 TencentCFS（TencentCFS 正在测试中）</p><ul><li>其中 RBD 和 CephFS 主要用于部署在 IDC 环境的集群</li><li>TencentCBS 和 TencentCFS 用于部署在腾讯云环境的集群</li></ul><h4 id=部署在集群内-kubernetes-对象>部署在集群内 kubernetes 对象</h4><p>在集群内部署 CSIOperator，将在集群内部署以下 kubernetes 对象</p><table><thead><tr><th style=text-align:left>kubernetes 对象名称</th><th style=text-align:left>类型</th><th style=text-align:left>默认占用资源</th><th style=text-align:left>所属 Namespaces</th></tr></thead><tbody><tr><td style=text-align:left>csi-operator</td><td style=text-align:left>Deployment</td><td style=text-align:left>每节点0.2核 CPU, 256MB内存</td><td style=text-align:left>kube-system</td></tr></tbody></table><h3 id=csioperator-使用方法>CSIOperator 使用方法</h3><h4 id=安装-csioperator>安装 CSIOperator</h4><ul><li>登录 TKEStack</li><li>切换至 【平台管理】控制台，选择 【扩展组件】 页面</li><li>选择需要安装组件的集群，点击【新建】按钮。如下图所示：</li></ul><p><img src=../../../../../images/image%20%2860%29.png alt></p><ul><li>在弹出的扩展组件列表里，滑动列表窗口找到 CSIOperator</li><li>单击【完成】进行安装</li></ul><h4 id=通过-csioperator-使用腾讯云存储资源>通过 CSIOperator 使用腾讯云存储资源</h4><ul><li>登录 TKEStack</li><li>切换至 【平台管理】控制台，选择 【集群管理】 页面，如下图1所示：</li><li>点击安装了 CSIOperator 组件的【集群ID】，进入要管理的集群，如下图2所示：</li><li>点击【YAML创建资源】，如下图3所示：</li></ul><p><img src=../../../../../images/image%20%28127%29.png alt></p><ul><li><p>文件中指定各自存储插件镜像的名称，这里以<code>tencentcbs</code>的 YAML 为例：（前提：需要拥有腾讯云账号）</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>apiVersion: storage.tkestack.io/v1
kind: CSI
metadata:
  name: tencentcbsv1
  namespace: kube-system
spec:
  driverName: com.tencent.cloud.csi.cbs
  version: &#34;v1&#34;
  parameters:
    secretID: &#34;xxxxxx&#34;
    secretKey: &#34;xxxxxx&#34;
</code></pre></div><ul><li>secretID、secretKey 来源于 腾讯云控制台 -> 账号中心 -> 访问管理 -> 访问秘钥 -> API密钥管理</li></ul></li><li><p>创建完 CSIOperator 的 CRD 对象，同时会为每个存储插件创建默认的 StorageClass 对象（tencentcbs 的 StorageClass 对象名为 cbs-basic-prepaid），如下图：</p></li></ul><p><img src=../../../../../images/image%20%28140%29.png alt></p><p>其 YAML 如下：</p><p><img src=../../../../../images/image%20%28123%29.png alt></p><ul><li><p>tencentcbs 的 provisioner 名称指定为：<code>com.tencent.cloud.csi.cbs</code></p></li><li><p>tencentcfs 的 provisioner 名称指定为：<code>com.tencent.cloud.csi.cfs</code>，tencentcfs 仍在测试中，目前仅支持 tencentcbs</p></li><li><p>对于磁盘类型（在 StorageClass 的 <code>diskType</code> 中指定）和大小的限制：</p><ul><li>普通云硬（ <code>CLOUD_BASIC</code> ）盘提供最小 100 GB 到最大 16000 GB 的规格选择，支持 40-100MB/s 的 IO 吞吐性能和 数百-1000 的随机 IOPS 性能</li><li>高性能云硬盘（<code>CLOUD_PREMIUM</code>）提供最小 50 GB 到最大 16000 GB 的规格选择</li><li>SSD 云硬盘（<code>CLOUD_SSD</code>）提供最小 100 GB 到最大 16000 GB 的规格选择，单块 SSD 云硬盘最高可提供 24000 随机读写IOPS、260MB/s吞吐量的存储性能</li></ul></li><li><p>默认创建的磁盘类型为普通云硬盘，如果用户希望使用该 StorageClass，可以直接创建使用了该 StorageClass 的 PVC 对象：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: test-tencentcbs
  namespace: kube-system
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: cbs-basic-prepaid
  resources:
    requests:
      storage: 10Gi
</code></pre></div></li></ul><p>详情请见 <a href=https://github.com/tkestack/csi-operator/blob/master/examples>CSIOperator Example</a></p></div></main></div></div><footer class="bg-dark py-5 row d-print-none"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank rel=noopener href=https://github.com/tkestack/tke aria-label=GitHub><i class="fab fa-github"></i></a></li></ul></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2022 The TKEStack Authors All Rights Reserved</small></div></div></div></footer></div><script src=https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js integrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js integrity=sha384-+YQ4JLhjyBLPDQt//I+STsc9iw4uQqACwlvpslubQzn4u2UU2UFM80nGisd026JF crossorigin=anonymous></script><script src=/web/js/main.min.1911ee3ae98d7d6df3807cd00d8e31ae7d1c08ee0f0bb587529b0483da4e5464.js integrity="sha256-GRHuOumNfW3zgHzQDY4xrn0cCO4PC7WHUpsEg9pOVGQ=" crossorigin=anonymous></script></body></html>