<!doctype html><html lang=zh class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.83.1"><link rel=canonical type=text/html href=/web/zh/docs/><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel="shortcut icon" href=/web/favicons/favicon.ico><link rel=apple-touch-icon href=/web/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/web/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/web/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/web/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/web/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/web/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/web/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/web/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/web/favicons/android-192x192.png sizes=192x192><title>TKEStack 文档 | Tkestack</title><meta name=description content="生产级别多集群管理系统"><meta property="og:title" content="TKEStack 文档"><meta property="og:description" content="生产级别多集群管理系统"><meta property="og:type" content="website"><meta property="og:url" content="/web/zh/docs/"><meta property="og:site_name" content="Tkestack"><meta itemprop=name content="TKEStack 文档"><meta itemprop=description content="生产级别多集群管理系统"><meta name=twitter:card content="summary"><meta name=twitter:title content="TKEStack 文档"><meta name=twitter:description content="生产级别多集群管理系统"><link rel=preload href=/web/scss/main.min.f3f5e11928ea652eef8f11ab959efa477bbd1a85923ff5e0245c83fe74bd312a.css as=style><link href=/web/scss/main.min.f3f5e11928ea652eef8f11ab959efa477bbd1a85923ff5e0245c83fe74bd312a.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar"><a class=navbar-brand href=/web/zh/><span class=navbar-logo></span><span class="text-uppercase font-weight-bold">Tkestack</span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/web/zh/docs/><span>Docs</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/web/zh/blog/><span>Blog</span></a></li><li class="nav-item dropdown d-none d-lg-block"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>中文 Chinese</a><div class=dropdown-menu aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/web/docs/>English</a></div></li></ul></div><div class="navbar-nav d-none d-lg-block"></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"></div><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"></div><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.</p><p><a href=/web/zh/docs/>返回本页常规视图</a>.</p></div><h1 class=title>TKEStack 文档</h1><ul><li>1: <a href=#pg-6e17e09fffc1050f46600282def85180>简介</a></li><ul></ul><li>2: <a href=#pg-273a1d3f87830cbffaaf95a64d1ab7e6>部署</a></li><ul><li>2.1: <a href=#pg-f6d1bc768009a5736551eb833bad5d9e>产品部署架构</a></li><li>2.2: <a href=#pg-772f3961b57805af450afc37610035eb>部署环境要求</a></li><li>2.3: <a href=#pg-783c8ecc2ba7ee0bcac796c85b13d77a>安装使用 GPU</a></li><li>2.4: <a href=#pg-51fdfea303f27cb5db555430fe8fe2d5>迁移步骤</a></li><li>2.5: <a href=#pg-bc59bbbdb54b32c83e332a5bb22589a2>安装步骤</a></li><li>2.6: <a href=#pg-675ad318dc95d5a2edd69400c4712727></a></li></ul><li>3: <a href=#pg-6546478d87b4368b79e83eb0e32c466c>快速入门</a></li><ul><li>3.1: <a href=#pg-268b773d92ea9b8a5d1139d9967931cb>快速入门</a></li><li>3.2: <a href=#pg-5e4d3b51a81e2f2500a2db566d211b8f>入门示例</a></li><ul><li>3.2.1: <a href=#pg-fab69c9d83a9da61b39c006b88f3929a>创建nginx服务</a></li><li>3.2.2: <a href=#pg-9a2a5aa9bc2d08d259f1ad9a976eb560>编写HelloWorld程序</a></li><li>3.2.3: <a href=#pg-d2fc2e9c475dda096ccff56f6718d569>如何构建Docker镜像</a></li></ul></ul><li>4: <a href=#pg-ecf7e357d2a131135219db95eddda49c>产品使用指南</a></li><ul><li>4.1: <a href=#pg-61777f7ebad3712dd7b6ca6604171a31>切换控制台</a></li><li>4.2: <a href=#pg-3261558bde8adcdba76287116c6556b4>平台管理控制台</a></li><ul><li>4.2.1: <a href=#pg-244fe30a59f1efe2a63093adc1d95f1d>概览</a></li><li>4.2.2: <a href=#pg-8a8e3c823159d27959aba112514409fb>集群管理</a></li><li>4.2.3: <a href=#pg-4084130a4de3422093300679bfcd6e9d>业务管理</a></li><li>4.2.4: <a href=#pg-2eac969bd1933c41613cedbe9af4c914>扩展组件</a></li><ul><li>4.2.4.1: <a href=#pg-f8882211bf86e03e9ad6a7593f6389f4>TApp 介绍</a></li><li>4.2.4.2: <a href=#pg-36486ddbc5cae072d21407bccf243040>CronHPA 介绍</a></li><li>4.2.4.3: <a href=#pg-10c69052f011daaf2098d301331d233d>监控组件</a></li><li>4.2.4.4: <a href=#pg-6dcd138c670444e4d6bd8c3e521b6e9d>LogAgent 介绍</a></li><li>4.2.4.5: <a href=#pg-901ced327a8b1d8464a48213006e87cc>GPUManager 介绍</a></li><li>4.2.4.6: <a href=#pg-1908a7f2ad115ef0bc6b1cde68a4cc21>CSIOperator 介绍</a></li></ul><li>4.2.5: <a href=#pg-d5c510eb12ae466242386f0cebdb156b>组织资源</a></li><ul><li>4.2.5.1: <a href=#pg-64d4646ef1291f0db93a3686d23ec15f>镜像仓库管理</a></li><li>4.2.5.2: <a href=#pg-26f3f5de560aa7df709ac0f6721cad7a>Helm模板</a></li><li>4.2.5.3: <a href=#pg-e90c4b8de7956382e8cb823e234fcfdc>访问凭证</a></li></ul><li>4.2.6: <a href=#pg-1e2e6f8e38db1566b319ae4dcf54e5bd>访问管理</a></li><ul><li>4.2.6.1: <a href=#pg-2afb350b927ffbe1b6aefc8291b4faba>策略管理</a></li><li>4.2.6.2: <a href=#pg-b8df25d88d18c9314eee7073f7e19ed4>用户管理</a></li></ul><li>4.2.7: <a href=#pg-b22c0bde169ab6bdc225b49782930706>监控&告警</a></li><ul><li>4.2.7.1: <a href=#pg-23a8b7f582c270bcb790b3707905d346>告警记录</a></li><li>4.2.7.2: <a href=#pg-c677185f730a103f7429f6161d3c5546>通知设置</a></li><li>4.2.7.3: <a href=#pg-0a1a33c9e3221ae15fbb22a45f0ce01a>告警设置</a></li></ul><li>4.2.8: <a href=#pg-09ccc45f60cc4e226d68fd40cba886e8>运维中心</a></li><ul><li>4.2.8.1: <a href=#pg-c33fc9e02cdad664bbb84e3fffcf6b82>Helm应用</a></li><li>4.2.8.2: <a href=#pg-26d04226b313f47a8e04a3e9fee4bd6e>日志采集</a></li><li>4.2.8.3: <a href=#pg-771091872cb56b9e533c1ead93c239a3>审计记录</a></li><li>4.2.8.4: <a href=#pg-4fbbc556a6db65b71e6c43d79c98e91f>事件持久化</a></li></ul></ul><li>4.3: <a href=#pg-dd936ac0eac7e736303553035fa56805>业务管理控制台</a></li><ul><li>4.3.1: <a href=#pg-402ac28c5481bba81202ae278bdded53>应用管理</a></li><ul><li>4.3.1.1: <a href=#pg-4e15f7e3621280c263719d94afc30139>命名空间</a></li><li>4.3.1.2: <a href=#pg-581be5ed4a9d7b276c4f2421596a48bb>工作负载</a></li><ul><li>4.3.1.2.1: <a href=#pg-283c1811e1a2396cc1491fc9f195b181>Deployment</a></li><li>4.3.1.2.2: <a href=#pg-66e0e51b3c40c38b649dd3f8274df967>StatefulSet</a></li><li>4.3.1.2.3: <a href=#pg-1b3dcfb569c1dd11bfb7abfcf169910a>DaomonSet</a></li><li>4.3.1.2.4: <a href=#pg-ca95b6ae5265a54d37b41c7ecda011ff>Job</a></li><li>4.3.1.2.5: <a href=#pg-1a3700b417d983d15f664242eb43d9d2>CronJob</a></li><li>4.3.1.2.6: <a href=#pg-942ebebfffb5f5766dfc29a3ff54c3d9>TApp</a></li><li>4.3.1.2.7: <a href=#pg-8f31787affb2101a550d608ac7166151>工作负载的请求与限制</a></li></ul><li>4.3.1.3: <a href=#pg-728de0d6037af6e8c4dd3d3cd18a58aa>服务</a></li><ul><li>4.3.1.3.1: <a href=#pg-c01661de03c27cf20d354588e9284d09>Service</a></li><li>4.3.1.3.2: <a href=#pg-633c3237aaeb2d075e5d341846481ed4>Ingress</a></li></ul><li>4.3.1.4: <a href=#pg-789101fc549a9485b823279e9954eed5>配置管理</a></li><ul><li>4.3.1.4.1: <a href=#pg-0c72d80fcd8fcfd427fcdb7f64153f05>ConfigMap</a></li><li>4.3.1.4.2: <a href=#pg-5a27b72a9f3556b1c20ff0496d3c3d0e>Sercet</a></li></ul><li>4.3.1.5: <a href=#pg-5133b2fd66402e8287da92f8bc3afb8a>存储</a></li><ul><li>4.3.1.5.1: <a href=#pg-29f3e5641963f81595c61e48c46454d2>PV和PVC</a></li><li>4.3.1.5.2: <a href=#pg-1ac5657bc83221fe31967a09022efbb7>StorageClass</a></li></ul><li>4.3.1.6: <a href=#pg-8c2e6b2266588f17239be429af65c27b>事件</a></li><li>4.3.1.7: <a href=#pg-14f8919cb8baa3bde4981e98721ae227>日志</a></li></ul><li>4.3.2: <a href=#pg-3057610a99f7aa499109de1965002074>业务管理</a></li><li>4.3.3: <a href=#pg-0833d65e8a0923cb315f467023b013b7>组织资源</a></li><ul><li>4.3.3.1: <a href=#pg-f5322afb855665547246929ce62f630e>镜像仓库管理</a></li><li>4.3.3.2: <a href=#pg-f0a95e137c43ada900e73e5db88f8ac3>Helm模板</a></li><li>4.3.3.3: <a href=#pg-c94ea67b479a34ed1633b3f44f2a27d9>访问凭证</a></li></ul><li>4.3.4: <a href=#pg-546cb0ff5126c40169ac9e848ea02681>监控与告警</a></li><ul><li>4.3.4.1: <a href=#pg-79be2d16b5d7949b81dad31c17ccfb47>设置告警</a></li><li>4.3.4.2: <a href=#pg-845ad2011e5c3014b6adbbdc05f6c385>通知设置</a></li></ul><li>4.3.5: <a href=#pg-22fc8e15cadbee096a9ba8d919957ba0>运维中心</a></li><ul><li>4.3.5.1: <a href=#pg-55a60e4dfe4f04261ba0510de35132f8>Helm应用</a></li><li>4.3.5.2: <a href=#pg-aecfc90660f6fc8ff8c08c88ca759f90>日志采集</a></li></ul><li>4.3.6: <a href=#pg-08c4350de537017097f922dfdd8dceaf></a></li></ul></ul><li>5: <a href=#pg-664c42187cbd9876a7d5ae8a17ec02ce>开发指引</a></li><ul><li>5.1: <a href=#pg-b5d18f6a5a5de4c1a4b8632ce9d76df1>API 使用指引</a></li></ul></ul><div class=content></div></div><div class=td-content><h1 id=pg-6e17e09fffc1050f46600282def85180>1 - 简介</h1><div class=lead>Tke stack 简介.</div><p><img src="https://avatars0.githubusercontent.com/u/57258287?s=200&v=4" alt></p><p><img src="https://github.com/tkestack/tke/workflows/build/badge.svg?branch=master" alt="TKEStack Logo"> <img src=https://github.com/tkestack/tke/workflows/build-web/badge.svg alt=build-web> <a href=https://goreportcard.com/report/tkestack.io/tke><img src=https://goreportcard.com/badge/tkestack.io/tke alt="Go Report Card"></a> <a href=https://github.com/tkestack/tke/releases><img src="https://img.shields.io/github/release/tkestack/tke.svg?style=flat-square" alt=Release></a></p><blockquote><p>在线文档地址：<a href=https://tkestack.github.io/web/zh/docs/>https://tkestack.github.io/web/zh/docs/</a></p></blockquote><p><em><strong>TKEStack</strong></em> 是一个开源项目，为在生产环境中部署容器的组织提供一个<strong>统一的容器管理平台</strong>。 <em><strong>TKEStack</strong></em> 可以简化部署和使用 Kubernetes，满足 IT 要求，并增强 DevOps 团队的能力。</p><h2 id=特点>特点</h2><ul><li><strong>统一集群管理</strong><ul><li>提供 Web 控制台和命令行客户端，用于集中管理多个 Kubernetes 集群</li><li>可与现有的身份验证机制集成，包括 LDAP，Active Directory，front proxy 和 public OAuth providers（例如GitHub）</li><li>统一授权管理，不仅在集群管理级别，甚至在Kubernetes资源级别</li><li>多租户支持，包括团队和用户对容器、构建和网络通信的隔离</li></ul></li><li><strong>应用程序工作负载管理</strong><ul><li>提供直观的UI界面，以支持可视化、YAML导入、其他资源创建和编辑方法，使用户无需预先学习所有Kubernetes概念即可运行容器</li><li>抽象的项目级资源容器，以支持跨多个集群的多个名称空间管理和部署应用程序</li></ul></li><li><strong>运维管理</strong><ul><li>集成的系统监控和应用程序监控</li><li>支持对接外部存储，以实现持久化Kubernetes事件和审计日志</li><li>限制，跟踪和管理平台上的开发人员和团队</li></ul></li><li><strong>插件支持和管理</strong><ul><li>Authentication identity provider 插件</li><li>Authorization provider 插件</li><li>事件持久化存储插件</li><li>系统和应用程序日志持久化存储插件</li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-273a1d3f87830cbffaaf95a64d1ab7e6>2 - 部署</h1><div class=lead>部署架构， 环境要求， 部署步骤</div></div><div class=td-content><h1 id=pg-f6d1bc768009a5736551eb833bad5d9e>2.1 - 产品部署架构</h1><div class=lead>产品部署架构描述</div><h2 id=总体架构>总体架构</h2><p>TKEStack 产品架构如下图所示：</p><p><img src=../images/tkestackhighlevelarchitecture-2x.png alt></p><h2 id=架构说明>架构说明</h2><p>TKEStack 采用了 Kubernetes on Kubernetes 的设计理念。即节点仅运行 Kubelet 进程，其他组件均采用容器化部署，由 Kubernetes 进行管理。</p><p>架构上分为 Global 集群和业务集群。Global 集群运行整个容器服务开源版平台自身所需要的组件，业务集群运行用户业务。在实际的部署过程中，可根据实际情况进行调整。</p><h2 id=模块说明>模块说明</h2><ul><li>Installer: 运行 tke-installer 安装器的节点，用于提供 Web UI 指导用户在 Global 集群部署TKEStacl控制台；</li><li>Global Cluster: 运行的 TKEStack 控制台的 Kubernetes 集群；</li><li>Cluster: 运行业务的 Kubernetes 集群，可以通过 TKEStack 控制台创建或导入；</li><li>Auth: 权限认证组件，提供用户鉴权、权限对接相关功能；</li><li>Gateway: 网关组件，实现集群后台统一入口、统一鉴权相关的功能，并运行控制台的 Web 界面服务；</li><li>Platform: 集群管理组件，提供 Global 集群管理多个业务集群相关功能；</li><li>Business: 业务管理组件，提供平台业务管理相关功能的后台服务；</li><li>Network Controller：网络服务组件，支撑 Galaxy 网络功能；</li><li>Monitor: 监控服务组件，提供监控采集、上报、告警相关服务；</li><li>Notify: 通知功能组件，提供消息通知相关的功能；</li><li>Registry: 镜像服务组件，提供平台镜像仓库服务；</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-772f3961b57805af450afc37610035eb>2.2 - 部署环境要求</h1><div class=lead>部署环境要求</div><h2 id=硬件要求>硬件要求</h2><blockquote><p><strong>特别注意</strong>：</p><ol><li><p>安装的时候，至少需要<strong>一个 Installer 节点</strong>和<strong>一个作为 Global 集群的 master 节点</strong>共<strong>两个节点</strong>。
>
> v1.3.0 之后的版本可直接使用 All-In-One 的安装模式，此时 Installer 节点也可以作为 Global 集群的节点。但注意：此时 Installer 的节点配置要以 Global 集群的节点配置为准，否则 Installer 节点配置太低很容易安装失败。另外该功能还不是很成熟，为避免安装失败，尽量<strong>将 Installer 节点和 Global 节点分开始用</strong></p></li><li><p><strong>Installer 节点</strong>：是单独的用作安装的节点，不能作为 Global 集群的节点使用。因为在安装 Global 集群时，需要多次重启 docker，此时如果 Global 集群里面有 Installer 节点，重启 docker 会中断 Global 集群的安装。该节点需要一台<strong>系统盘 100G</strong> 的机器，系统盘要保证剩余 <strong>50GB 可用的空间</strong>。
>
> <strong>v1.3.0 之后 Installer 节点支持作为 Global 集群的节点使用，但注意此时 Installer 节点配置以 Global 集群的节点为准</strong></p></li><li><p><strong>Global 集群</strong>：至少需要一台 <strong>8核16G内存，100G系统盘</strong>的机器。</p></li><li><p><strong>业务集群</strong>：业务集群是在部署完 Global 集群之后再添加的。</p></li></ol></blockquote><ul><li><strong>最小化部署硬件配置：</strong></li></ul><table><thead><tr><th style=text-align:left><strong>安装/业务集群</strong></th><th style=text-align:left><strong>节点/集群</strong></th><th style=text-align:left><strong>CPU 核数</strong></th><th style=text-align:left><strong>内存</strong></th><th style=text-align:left><strong>系统盘</strong></th><th style=text-align:left><strong>数量</strong></th></tr></thead><tbody><tr><td style=text-align:left>安装</td><td style=text-align:left>Installer 节点</td><td style=text-align:left>1</td><td style=text-align:left>2G</td><td style=text-align:left>100G</td><td style=text-align:left>1</td></tr><tr><td style=text-align:left>TKEStack 控制台</td><td style=text-align:left>Global 集群</td><td style=text-align:left>8</td><td style=text-align:left>16G</td><td style=text-align:left>100G</td><td style=text-align:left>1</td></tr><tr><td style=text-align:left>业务集群</td><td style=text-align:left>Master & ETCD</td><td style=text-align:left>4</td><td style=text-align:left>8G</td><td style=text-align:left>100G</td><td style=text-align:left>1</td></tr><tr><td style=text-align:left>业务集群</td><td style=text-align:left>Node</td><td style=text-align:left>8</td><td style=text-align:left>16G</td><td style=text-align:left>100G</td><td style=text-align:left>3</td></tr></tbody></table><ul><li><strong>推荐硬件配置：</strong></li></ul><table><thead><tr><th style=text-align:left><strong>安装/业务集群</strong></th><th style=text-align:left><strong>节点/集群</strong></th><th style=text-align:left><strong>CPU 核数</strong></th><th style=text-align:left><strong>内存</strong></th><th style=text-align:left><strong>系统盘</strong></th><th style=text-align:left><strong>数量</strong></th></tr></thead><tbody><tr><td style=text-align:left>安装</td><td style=text-align:left>Installer 节点</td><td style=text-align:left>1</td><td style=text-align:left>2G</td><td style=text-align:left>100G</td><td style=text-align:left>1</td></tr><tr><td style=text-align:left>TKEStack 控制台</td><td style=text-align:left>Global 节点</td><td style=text-align:left>8</td><td style=text-align:left>16G</td><td style=text-align:left>100G SSD</td><td style=text-align:left>3</td></tr><tr><td style=text-align:left>业务集群</td><td style=text-align:left>Master & ETCD</td><td style=text-align:left>16</td><td style=text-align:left>32G</td><td style=text-align:left>300G SSD</td><td style=text-align:left>3</td></tr><tr><td style=text-align:left>业务集群</td><td style=text-align:left>Node</td><td style=text-align:left>16</td><td style=text-align:left>32G</td><td style=text-align:left>系统盘：100G 数据盘：300G （/var/lib/docker）</td><td style=text-align:left>>3</td></tr></tbody></table><blockquote><p>注意：上表中的<strong>数据盘</strong>（/var/lib/docker）表示的是 docker 相关信息在主机中存储的位置，即<strong>容器数据盘</strong>，包括 docker 的镜像、容器、日志（如果容器的日志文件所在路径没有挂载 volume，日志文件会被写入容器可写层，落盘到容器数据盘里）等文件。建议给此路径挂盘，避免与系统盘混用，避免因容器、镜像、日志等 docker 相关信息导致磁盘压力过大。</p></blockquote><h2 id=软件要求>软件要求</h2><blockquote><p><strong>注意，以下要求针对集群中的所有节点</strong></p></blockquote><table><thead><tr><th style=text-align:left>需求项</th><th style=text-align:left>具体要求</th><th style=text-align:left>命令参考 （以 CentOS 7.6为例）</th></tr></thead><tbody><tr><td style=text-align:left>操作系统</td><td style=text-align:left>Ubuntu 16.04/18.04 LTS (64-bit)<br>CentOS Linux 7.6 (64-bit) Tencent Linux 2.2</td><td style=text-align:left><code>cat /etc/redhat-release</code></td></tr><tr><td style=text-align:left>kernel 版本</td><td style=text-align:left>>= Kernel 3.10.0-957.10.1.el7.x86_64</td><td style=text-align:left><code>uname -sr</code></td></tr><tr><td style=text-align:left>ssh sudo yum CLI</td><td style=text-align:left>确保 Installer 节点及其容器、<br>Global 集群节点及其容器、<br>业务集群节点及其容器&mldr;之间能够 ssh 互联；<br>确保每个节点都有基础工具</td><td style=text-align:left>1. 确保在添加所有节点时，IP 和密码输入正确。<br>2. 确保每个节点都有 sudo 或 root 权限<br>3. 如果是 CentOS，确保拥有 yum；其他操作系统类似，确保拥有包管理器<br>4. 确保拥有命令行工具</td></tr><tr><td style=text-align:left>Swap</td><td style=text-align:left>关闭。 如果不满足，系统会有一定几率出现 io 飙升，造成 docker 卡死。kubelet 会启动失败<br>(可以设置 kubelet 启动参数 &ndash;fail-swap-on 为 false 关闭 swap 检查)</td><td style=text-align:left><code>sudo swapoff -a</code><br><code>sudo sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab</code><br><code># 注意：如果 /etc/fstab有挂载 swap，必须要注释掉，不然重新开机时又会重新挂载 swap</code></td></tr><tr><td style=text-align:left>防火墙</td><td style=text-align:left>关闭。 或者至少要放通22、80、8080、443、6443、2379、2380、10250-10255、31138 端口</td><td style=text-align:left><code>可通过以下关闭防火墙</code><br><code>systemctl stop firewalld && systemctl disable firewalld</code><br><code>或者通过以下命令放通指定端口，例如只放通80端口</code> <code>firewall-cmd --zone=public --add-port=80/tcp --permanent</code></td></tr><tr><td style=text-align:left>SELinux</td><td style=text-align:left>关闭。 Kubernetes 官方要求，否则 kubelet 挂载目录时可能报错 <code>Permission denied</code></td><td style=text-align:left><code>setenforce 0</code><br><code>sed -i "s/SELINUX=enforcing/SELINUX=disabled/g" /etc/selinux/config</code></td></tr><tr><td style=text-align:left>时区</td><td style=text-align:left>所有服务器时区必须统一，建议设置为 <code>Asia/Shanghai</code></td><td style=text-align:left><code>timedatectl set-timezone Asia/Shanghai</code></td></tr><tr><td style=text-align:left>时间同步</td><td style=text-align:left>ETCD 集群各机器需要时间同步，可以利用 chrony 用于系统时间同步；<br>所有服务器要求时间必须同步，误差不得超过 2 秒</td><td style=text-align:left><code>yum install -y chronyd</code><br><code>systemctl enable chronyd && systemctl start chronyd</code></td></tr><tr><td style=text-align:left>路由检查</td><td style=text-align:left>有些设备可能会默认配置一些路由，这些路由可能与 TKEStack 冲突，建议删除这些路由并做相关配置</td><td style=text-align:left><code>ip link delete docker0</code><br><code>ip link add name docker0 type bridge</code><br><code>ip addr add dev docker0 172.17.0.1/16</code></td></tr><tr><td style=text-align:left>docker 检查</td><td style=text-align:left>有些设备可能会默认安装 docker，该 docker 版本可能与 TKEStack 不一致，<br>建议在安装 TKEStack 之前删除docker</td><td style=text-align:left><code>yum remove docker-ce containerd docker-ce-cli -y</code></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-783c8ecc2ba7ee0bcac796c85b13d77a>2.3 - 安装使用 GPU</h1><div class=lead>安装使用 GPU 具体步骤，注意事项</div><h1 id=安装使用步骤>安装使用步骤</h1><h2 id=安装使用步骤-1>安装使用步骤</h2><h3 id=限制条件>限制条件</h3><ul><li>用户在安装使用GPU时，要求集群内必须包含GPU机型节点</li><li>该组件基于 Kubernetes DevicePlugin 实现，只能运行在支持 DevicePlugin 的 kubernetes版本（Kubernetes 1.10 之上的版本）</li><li>GPU-Manager 将每张 GPU 卡视为一个有100个单位的资源：当前仅支持 0-1 的小数张卡，如 20、35、50；以及正整数张卡，如200、500等；不支持类似150、250的资源请求；显存资源是以 256MiB 为最小的一个单位的分配显存</li></ul><h3 id=tkestack-支持的-gpu-类型>TKEStack 支持的 GPU 类型</h3><p>TKEStack目前支持两种GPU类型：</p><ul><li>vGPU：虚拟GPU类型(Virtual GPU)，当选择安装此类型的GPU时，平台会自动安装组件<a href=https://github.com/tkestack/gpu-manager>GPUManager</a>，对应在集群中部署的kubernetes资源对象如下：</li></ul><table><thead><tr><th>kubernetes 对象名称</th><th>类型</th><th>建议预留资源</th><th>所属 Namespaces</th></tr></thead><tbody><tr><td>gpu-manager-daemonset</td><td>DaemonSet</td><td>每节点1核 CPU, 1Gi内存</td><td>kube-system</td></tr><tr><td>gpu-quota-admission</td><td>Deployment</td><td>1核 CPU, 1Gi内存</td><td>kube-system</td></tr></tbody></table><ul><li>pGPU: 物理GPU类型(Physical GPU)，当选择安装此类型的GPU时，平台会自动安装组件<a href=https://github.com/NVIDIA/k8s-device-plugin>Nvidia-k8s-device-plugin</a>，对应的在集群中部署的kubernetes资源对象如下：</li></ul><table><thead><tr><th>kubernetes 对象名称</th><th>类型</th><th>建议预留资源</th><th>所属 Namespaces</th></tr></thead><tbody><tr><td>nvidia-device-plugin-daemonset</td><td>DaemonSet</td><td>每节点1核 CPU, 1Gi内存</td><td>kube-system</td></tr></tbody></table><h3 id=安装步骤>安装步骤</h3><h4 id=安装使用-vgpu>安装使用 vGPU</h4><p>用户在新建独立集群时，勾选GPU选项，在下拉选项中选择 vGPU，如下图所示：</p><p><img src=../images/gpu-1.png alt></p><p>目标机器部分，勾选GPU选项，平台会自动为节点安装GPU驱动，如下图所示：</p><p><img src=../images/gpu-2.png alt></p><p>等待新建独立集群处于running状态后，可以通过登陆到集群节点通过<code>kubectl</code>查看在集群<code>kube-system</code>命名空间中部署了<code>gpu-manager</code>和<code>gpu-quota-admission</code>两个pod：</p><pre><code># kubectl get pods -n kube-system | grep gpu
gpu-manager-daemonset-2vvbm              1/1     Running   0          2m13s
gpu-quota-admission-76cfff49b6-vdh42     1/1     Running   0          3m2s
</code></pre><h4 id=创建使用-vgpu-的工作负载>创建使用 vGPU 的工作负载</h4><p>TKEStack创建使用GPU的工作负载支持两种方式：第一种是通过TKEStack前端页面创建，第二种是通过后台命令行的方式创建。</p><p>1、 通过前端控制台创建</p><p>在安装了 GPU-Manager 的集群中，创建工作负载时可以设置GPU限制，如下图所示：</p><blockquote><p>注意：</p><ol><li>卡数只能填写 0.1 到 1 之间的两位小数或者是所有自然数，例如：0、0.3、0.56、0.7、0.9、1、6、34，不支持 1.5、2.7、3.54</li><li>显存只能填写自然数 n，负载使用的显存为 n*256MiB</li></ol></blockquote><p><img src=../images/gpu-3.png alt></p><p>2、 通过后台命令行创建</p><p>使用 YAML 创建使用 GPU 的工作负载，需要在 YAML 文件中为容器设置 GPU 的使用资源。</p><ul><li>CPU 资源需要在 resource 上填写<code>tencent.com/vcuda-core</code></li><li>显存资源需要在 resource 上填写<code>tencent.com/vcuda-memory</code></li></ul><p>如下所示：创建一个使用 0.3 张卡、5GiB 显存的nginx应用（5GiB = 20*256MB）</p><pre><code>apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - name: nginx
    image: nginx
    imagePullPolicy: IfNotPresent
    resources:
      limits:
        tencent.com/vcuda-core: 30
        tencent.com/vcuda-memory: 20
      requests:
        tencent.com/vcuda-core: 30
        tencent.com/vcuda-memory: 20
</code></pre><pre><code># kubectl create -f nginx.yaml
pod/nginx created
</code></pre><blockquote><p>注意：</p><ul><li>如果pod在创建过程中出现CrashLoopBackOff 的状态，且error log如下所示：</li></ul><pre><code>failed to create containerd task: OCI runtime create failed: container_linux.go:380: starting container process caused: process_linux.go:545: container init caused: Running hook #0:: error running hook: exit status 1, stdout: , stderr: nvidia-container-cli: mount error: open failed: /sys/fs/cgroup/devices/system.slice/containerd.service/kubepods-besteffort-podfd3b355a_665c_4c95_8e7f_61fd2111689f.slice/devices.allow: no such file or directory: unknown
</code></pre><p>需要在GPU主机上手动安装libnvidia-container-tools这个组件，首先需要添加repo源：添加repo源， 添加repo源后执行如下命令：</p><pre><code># yum install libnvidia-container-tools
</code></pre><ul><li>如果pod在创建过程中出现如下error log：</li></ul><pre><code>failed to generate spec: lstat /dev/nvidia-uvm: no such file or directory
</code></pre><p>需要在pod所在的主机上手动mount这个设备文件：</p><pre><code># nvidia-modprobe -u -c=0
</code></pre></blockquote><p>查看创建的应用状态：</p><pre><code># kubectl get pods
NAME    READY   STATUS    RESTARTS   AGE
nginx   1/1     Running   0          3s
</code></pre><p>查看GPU监控数据（需要提前安装socat）：</p><pre><code># yum install socat
</code></pre><pre><code># kubectl port-forward svc/gpu-manager-metric -n kube-system 5678:5678
</code></pre><pre><code># curl http://127.0.0.1:5678/metric
</code></pre><p>结果如下</p><pre><code>Handling connection for 5678
# HELP container_gpu_memory_total gpu memory usage in MiB
# TYPE container_gpu_memory_total gauge
container_gpu_memory_total{container_name=&quot;nginx&quot;,gpu_memory=&quot;gpu0&quot;,namespace=&quot;default&quot;,node=&quot;10.0.0.127&quot;,pod_name=&quot;nginx&quot;} 0
container_gpu_memory_total{container_name=&quot;nginx&quot;,gpu_memory=&quot;total&quot;,namespace=&quot;default&quot;,node=&quot;10.0.0.127&quot;,pod_name=&quot;nginx&quot;} 0
# HELP container_gpu_utilization gpu utilization
# TYPE container_gpu_utilization gauge
container_gpu_utilization{container_name=&quot;nginx&quot;,gpu=&quot;gpu0&quot;,namespace=&quot;default&quot;,node=&quot;10.0.0.127&quot;,pod_name=&quot;nginx&quot;} 0
container_gpu_utilization{container_name=&quot;nginx&quot;,gpu=&quot;total&quot;,namespace=&quot;default&quot;,node=&quot;10.0.0.127&quot;,pod_name=&quot;nginx&quot;} 0
# HELP container_request_gpu_memory request of gpu memory in MiB
# TYPE container_request_gpu_memory gauge
container_request_gpu_memory{container_name=&quot;nginx&quot;,namespace=&quot;default&quot;,node=&quot;10.0.0.127&quot;,pod_name=&quot;nginx&quot;,req_of_gpu_memory=&quot;total&quot;} 5120
# HELP container_request_gpu_utilization request of gpu utilization
# TYPE container_request_gpu_utilization gauge
container_request_gpu_utilization{container_name=&quot;nginx&quot;,namespace=&quot;default&quot;,node=&quot;10.0.0.127&quot;,pod_name=&quot;nginx&quot;,req_of_gpu=&quot;total&quot;} 0.30000001192092896
</code></pre><h4 id=安装使用-pgpu>安装使用 pGPU</h4><p>用户在新建独立集群时，勾选GPU选项，在下拉选项中选择pGPU，如下图所示：</p><p><img src=../images/gpu-4.png alt></p><p>目标机器部分，勾选GPU选项，平台会自动为节点安装GPU驱动，如下图所示：</p><p><img src=../images/gpu-2.png alt></p><p>等待新建独立集群处于running状态后，可以通过登陆到集群节点通过<code>kubectl</code>查看到，在集群<code>kube-system</code>命名空间中部署了<code>nvidia-device-plugin</code>pod：</p><pre><code># kubectl get pods -n kube-system | grep nvidia
nvidia-device-plugin-daemonset-frdh2     1/1     Running   0          64s
</code></pre><p>通过查看节点信息可以看到GPU资源和使用情况：</p><pre><code># kubectl describe nodes &lt;nodeIP&gt;
</code></pre><p>显示信息如下：</p><pre><code>Capacity:
  cpu:                8
  ephemeral-storage:  154685884Ki
  hugepages-1Gi:      0
  hugepages-2Mi:      0
  memory:             32779608Ki
  nvidia.com/gpu:     1
  pods:               256
Allocatable:
  cpu:                7800m
  ephemeral-storage:  142558510459
  hugepages-1Gi:      0
  hugepages-2Mi:      0
  memory:             31653208Ki
  nvidia.com/gpu:     1
  pods:               256
</code></pre><h4 id=创建使用vgpu的工作负载>创建使用vGPU的工作负载</h4><ul><li><p>通过控制台创建方式参考vGPU的创建步骤</p></li><li><p>通过命令行创建</p></li></ul><p>通过如下YAML创建使用1个GPU的工作负载：</p><pre><code>apiVersion: v1
kind: Pod
metadata:
  name: gpu-operator-test
spec:
  restartPolicy: OnFailure
  containers:
    - name: cuda-vector-add
      image: &quot;tkestack/cuda-vector-add:v0.1&quot;
      resources:
        limits:
          nvidia.com/gpu: 1
</code></pre><pre><code># kubectl create -f pod.yaml
pod/gpu-operator-test created
</code></pre><p>查看pod的状态和log：</p><pre><code># kubectl get pods
NAME                READY   STATUS      RESTARTS   AGE
gpu-operator-test   0/1     Completed   0          4m51s
</code></pre><pre><code># kubectl logs gpu-operator-test
[Vector addition of 50000 elements]
Copy input data from the host memory to the CUDA device
CUDA kernel launch with 196 blocks of 256 threads
Copy output data from the CUDA device to the host memory
Test PASSED
Done
</code></pre><p>通过再次查看节点信息可以看到GPU已经被分配使用：</p><pre><code>kubectl describe nodes &lt;nodeIP&gt;
</code></pre><pre><code>Allocated resources:
  (Total limits may be over 100 percent, i.e., overcommitted.)
  Resource           Requests     Limits
  --------           --------     ------
  cpu                1137m (14%)  282m (3%)
  memory             644Mi (2%)   1000Mi (3%)
  ephemeral-storage  0 (0%)       0 (0%)
  hugepages-1Gi      0 (0%)       0 (0%)
  hugepages-2Mi      0 (0%)       0 (0%)
  nvidia.com/gpu     1            1
</code></pre><h4 id=添加节点使用gpu>添加节点使用GPU</h4><p>在添加节点上使用GPU资源，需要在创建添加节点时勾选GPU选项，如下图所示：</p><p><img src=../images/gpu-5.png alt></p></div><div class=td-content style=page-break-before:always><h1 id=pg-51fdfea303f27cb5db555430fe8fe2d5>2.4 - 迁移步骤</h1><div class=lead>TKEStack 具体迁移步骤，注意事项</div><h2 id=容器运行时迁移>容器运行时迁移</h2><p><a href=https://tkestack.github.io/web/zh/blog/2021/09/01/container-runtime-migraion/>TKEStack 集群容器运行时迁移</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-bc59bbbdb54b32c83e332a5bb22589a2>2.5 - 安装步骤</h1><div class=lead>tke stack 具体安装步骤，注意事项</div><h1 id=安装步骤>安装步骤</h1><h2 id=安装步骤-1>安装步骤</h2><h3 id=1-需求检查>1. 需求检查</h3><p>仔细检查每个节点的硬件和软件需求：<a href=environment-requirement.md>installation requirements</a></p><h3 id=2-installer安装>2. Installer安装</h3><p>为了简化平台安装过程，容器服务开源版基于 tke-installer 安装器提供了一个向导式的图形化安装指引界面。</p><p>在您 Installer 节点的终端，执行如下脚本：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text># amd64
arch=amd64 version=v1.3.1 &amp;&amp; wget https://tke-release-1251707795.cos.ap-guangzhou.myqcloud.com/tke-installer-linux-$arch-$version.run{,.sha256} &amp;&amp; sha256sum --check --status tke-installer-linux-$arch-$version.run.sha256 &amp;&amp; chmod +x tke-installer-linux-$arch-$version.run &amp;&amp; ./tke-installer-linux-$arch-$version.run

# arm64
arch=arm64 version=v1.3.1 &amp;&amp; wget https://tke-release-1251707795.cos.ap-guangzhou.myqcloud.com/tke-installer-linux-$arch-$version.run{,.sha256} &amp;&amp; sha256sum --check --status tke-installer-linux-$arch-$version.run.sha256 &amp;&amp; chmod +x tke-installer-linux-$arch-$version.run &amp;&amp; ./tke-installer-linux-$arch-$version.run
</code></pre></div><blockquote><p>您可以查看 TKEStack <a href=https://github.com/tkestack/tke/releases>Release</a> 按需选择版本进行安装，建议您安装最新版本。</p><p>tke-installer 约为 7GB，包含安装所需的所有资源。</p></blockquote><p>以上脚本执行完之后，终端会提示访问 <a href=http://%5Btke-installer-IP%5D:8080/index.html%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E4%B8%BB%E6%9C%BA%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AE%E8%AF%A5%E5%9C%B0%E5%9D%80%EF%BC%8C%E6%8C%89%E7%85%A7%E6%8C%87%E5%BC%95%E5%BC%80%E5%A7%8B%E5%AE%89%E8%A3%85%E6%8E%A7%E5%88%B6%E5%8F%B0%EF%BC%8C%E5%8F%AF%E5%8F%82%E8%80%83%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%AE%89%E8%A3%85%E3%80%82>http://[tke-installer-IP]:8080/index.html，使用本地主机的浏览器访问该地址，按照指引开始安装控制台，可参考下面的控制台安装。</a></p><blockquote><p>注意：这里<code>tke-installer-IP</code>地址默认为<strong>内网地址</strong>，如果本地主机不在集群内网，<code>tke-installer-IP</code>为内网地址所对应的<strong>外网地址</strong>。</p></blockquote><h3 id=3-控制台安装>3. 控制台安装</h3><blockquote><p>注意：控制台是运行在global集群之上，控制台安装就是在安装global集群。</p></blockquote><ol><li>填写 TKEStack 控制台基本配置信息</li></ol><p><img src=../images/step-1.png alt></p><ul><li><strong>用户名</strong>：TKEStack 控制台管理员名称（<strong>例如：admin</strong>）</li><li><strong>密码</strong>：TKEStack 控制台管理员密码</li><li><strong>高可用设置</strong>（按需使用，可直接选择【<strong>不设置</strong>】）<ul><li><strong>TKE提供</strong>：在所有 master 节点额外安装 Keepalived 完成 VIP 的配置与连接</li><li><strong>使用已有</strong>：对接配置好的外部 LB 实例</li><li><strong>不设置</strong>：访问第一台 master 节点 APIServer</li></ul></li><li>填写 TKEStack 控制台集群设置信息</li></ul><p><img src=../images/step-2.png alt></p><ul><li><strong>网卡名称</strong>：集群节点使用的网卡，根据实际环境填写正确的网卡名称，默认为eth0（<strong>建议使用默认值</strong>）</li><li><strong>GPU 类型</strong>：（按需使用，可直接选择【<strong>不设置</strong>】）<ul><li><strong>不使用</strong>：不安装 Nvidia GPU 相关驱动</li><li><strong>Virtual</strong>：平台会自动为集群安装 <a href=../key-features/gpumanager.md>GPUManager</a> 扩展组件</li><li><strong>Physical</strong>：平台会自动为集群安装 <a href=https://github.com/NVIDIA/k8s-device-plugin>Nvidia-k8s-device-plugin</a></li></ul></li><li><strong>容器网络：</strong> 将为集群内容器分配在容器网络地址范围内的 IP 地址，您可以自定义三大私有网段作为容器网络， 根据您选择的集群内服务数量的上限，自动分配适当大小的 CIDR 段用于 Kubernetes service；根据您选择 Pod 数量上限/节点，自动为集群内每台服务器分配一个适当大小的网段用于该主机分配 Pod 的 IP 地址（<strong>建议使用默认值</strong>）<ul><li><strong>CIDR：</strong> 集群内 Sevice、 Pod 等资源所在网段</li><li><strong>Pod数量上限/节点：</strong> 决定分配给每个 Node 的 CIDR 的大小</li><li><strong>Service数量上限/集群</strong>：决定分配给 Sevice 的 CIDR 大小</li></ul></li><li><strong>master 节点：</strong> 输入目标机器信息后单击保存，若保存按钮是灰色，单击网页空白处即可变蓝<ul><li><strong>访问地址：</strong> Master 节点<strong>内网 IP</strong>，请配置<strong>至少 8 Cores & 16G内存</strong> 及以上的机型，<strong>否则会部署失败</strong></li><li><strong>SSH 端口</strong>：请确保目标机器安全组开放 SSH 端口和 ICMP 协议，否则无法远程登录和 PING 服务器（建议使用<strong>22</strong>）</li><li><strong>用户名和密码：</strong> 均为添加的节点的用户名和密码</li><li>可以通过节点下面的【添加机器】蓝色字体增加master节点（<strong>按需添加</strong>）</li></ul></li></ul><p><img src=../images/step-3-2.png alt></p><ul><li><strong>高级设置</strong>（非必须）：可以自定义 Global 集群的 Docker、kube-apiserver、kube-controller-manager、kube-scheduler、kubelet 运行参数</li><li>填写 TKEStack 控制台认证信息。（建议使用<strong>TKE提供</strong>）</li></ul><p><img src=../images/step-3-1.png alt></p><ul><li><strong>认证方式：</strong><ul><li><strong>TKE提供</strong>：使用 TKE 自带的认证方式</li><li><strong>OIDC</strong>：使用 OIDC 认证方式，详见 <a href=https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens>OIDC</a></li></ul></li><li>填写 TKEStack 控制台镜像仓库信息。（建议使用<strong>TKE提供</strong>）</li></ul><p><img src=../images/step-4.png alt></p><ul><li><strong>镜像仓库类型：</strong><ul><li><strong>TKE提供</strong>：使用 TKE 自带的镜像仓库</li><li><strong>第三方仓库</strong>：对接配置好的外部镜像仓库，此时，TKEStack 将不会再安装镜像仓库，而是使用您提供的镜像仓库作为默认镜像仓库服务</li></ul></li><li>业务设置</li><li>确认是否开启 TKEStack 控制台业务模块。(<strong>建议开启</strong>)</li><li>确实是否开启平台审计功能，审计模块为平台提供了操作记录,用户可以在平台管理进行查询，需用用户提供ES资源。（<strong>按需使用，可不开启</strong>）</li></ul><p><img src=../images/step-5.png alt></p><ol><li>选择 TKEStack 控制台监控存储类型。（建议使用<strong>TKE提供</strong>）</li></ol><p><img src=../images/step-6.png alt></p><ul><li><strong>监控存储类型</strong>：<ul><li><strong>TKE提供</strong>：使用 TKE 自带的 Influxdb 作为存储</li><li><strong>外部 Influxdb</strong>：对接外部的 Influxdb 作为存储</li><li><strong>外部 ES</strong>：对接外部的 Elasticsearch作为存储</li><li><strong>不使用</strong>：不使用监控</li></ul></li><li>确认是否开启 TKEStack 控制台，选择开启则需要填写控制台域名及证书。（<strong>建议使用默认值</strong>）</li></ul><p><img src=../images/step-7.png alt></p><ul><li><strong>监控存储类型</strong>:<ul><li><strong>自签名证书</strong>：使用 TKE 带有的自签名证书</li><li><strong>指定服务器证书</strong>：填写已备案域名的服务器证书</li></ul></li><li>确认 TKEStack 控制台所有配置是否正确。</li></ul><p><img src=../images/step-8.png alt></p><ol><li>开始安装 TKEStack 控制台，安装成功后界面如下，最下面出现【查看指引】的按钮。</li></ol><p><img src=../images/step-9.png alt></p><ol><li>点击【查看指引】，按照指引，在本地主机上添加域名解析，以访问 TKEStack 控制台。</li></ol><p><img src=../images/step-10.png alt></p><ul><li><p><strong>以Linux/MacOS为例</strong>: 在<code>/etc/hosts</code>文件中加入以下两行域名解析</p><ul><li>【IP】 console.tke.com</li><li>【IP】 registry.tke.com</li></ul><blockquote><p>注意：这里域名的【IP】地址默认为<strong>内网地址</strong>，如果本地主机不在集群内网，域名的IP地址应该填该内网地址所对应的<strong>外网地址</strong>。</p></blockquote></li></ul><h3 id=4-访问控制台>4. 访问控制台</h3><p>在本地主机的浏览器地址输入<code>http://console.tke.com</code>,可访问Global集群的控制台界面，输入控制台安装创建的用户名和密码后即可使用TKEStack。</p><h2 id=安装常见问题>安装常见问题</h2><p>安装失败请首先检查硬件和软件需求：<a href=environment-requirement.md>installation requirements</a></p><p>可参考<a href=../faq/installation/>FAQ installation</a>获得更多帮助。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-675ad318dc95d5a2edd69400c4712727>2.6 -</h1><h1 id=readme>readme</h1><p>Because we can not find resources online with static folder,so use this folder to store image.</p><p>If we fix this issue in the future, then we use static folder rather than this folder.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-6546478d87b4368b79e83eb0e32c466c>3 - 快速入门</h1><div class=lead>快速入门</div></div><div class=td-content><h1 id=pg-268b773d92ea9b8a5d1139d9967931cb>3.1 - 快速入门</h1><div class=lead>快速入门</div><h2 id=教程介绍>教程介绍</h2><p>TKEStack 是一款面向私有化环境的开源容器编排引擎。在本教程中，您将了解如何创建 TKEStack 控制台，并使用控制台创建和管理容器集群，在集群内快速、弹性地部署您的服务。</p><h2 id=操作步骤>操作步骤</h2><h3 id=平台安装>平台安装</h3><p>参考：<a href=../../installation/installation-steps>installation-procedures</a></p><h3 id=集群>集群</h3><p>平台安装之后，可在【平台管理】控制台的【集群管理】中看到 global 集群。如下图所示：</p><p><img src=../../../images/cluster%20%282%29%20%282%29%20%289%29.png alt></p><p>TKEStack 还可以另外<strong>新建独立集群</strong>以及<strong>导入已有集群</strong>实现<strong>多集群的管理</strong>。</p><blockquote><p>注意：<strong>新建独立集群</strong>和<strong>导入已有集群</strong>都属于<a href=../../installation/installation-architecture>TKEStack 架构</a>中的<strong>业务集群</strong>。</p></blockquote><h4 id=新建独立集群>新建独立集群</h4><ol><li>登录 TKEStack，右上角会出现当前登录的用户名，示例为 admin。</li><li>切换至【平台管理】控制台。</li><li>在“集群管理”页面中，单击【新建独立集群】。如下图所示：</li></ol><p><img src=../../../images/createCluster.png alt></p><ol><li>在“新建独立集群”页面，填写集群的基本信息。新建的集群需满足<a href=../installation/environment-requirement.md>installation requirements</a>的需求，在满足需求之后，TKEStack 的集群添加非常便利。如下图所示,只需填写【集群名称】、【目标机器】、【密码】，其他保持默认即可添加新的集群。</li></ol><blockquote><p>注意：若【保存】按钮是灰色，单击附近空白处即可变蓝</p></blockquote><p><img src=../../../images/ClusterInfo.png alt></p><ol><li><p>集群名称**：** 支持**中文**，小于 60 字符即可</p></li><li><p>Kubernetes 版本**：** 选择合适的 kubernetes 版本，各版本特性对比请查看 <a href=https://kubernetes.io/docs/home/supported-doc-versions/>Supported Versions of the Kubernetes Documentation</a>。（**建议使用默认值**）</p></li><li><p>网卡名称： 最长 63 个字符，只能包含小写字母、数字及分隔符(' - &lsquo;)，且必须以小写字母开头，数字或小写字母结尾。（<strong>建议使用默认值 eth0</strong>）</p></li><li><p>VIP ：高可用 VIP 地址。（<strong>按需使用</strong>）</p></li><li><p>GPU：选择是否安装 GPU 相关依赖。（<strong>按需使用</strong>）</p></li><li><p>pGPU：平台会自动为集群安装 <a href=../../key-features/gpumanager>GPUManager</a> 扩展组件</p></li><li><p>vGPU：平台会自动为集群安装 <a href=https://github.com/NVIDIA/k8s-device-plugin>Nvidia-k8s-device-plugin</a></p></li><li><p>容器网络 ：将为集群内容器分配在容器网络地址范围内的 IP 地址，您可以自定义三大私有网段作为容器网络， 根据您选择的集群内服务数量的上限，自动分配适当大小的 CIDR 段用于 kubernetes service；根据您选择 Pod 数量上限/节点，自动为集群内每台云服务器分配一个适当大小的网段用于该主机分配 Pod 的 IP 地址。（<strong>建议使用默认值</strong>）</p></li><li><p><strong>CIDR</strong>： 集群内 Sevice、 Pod 等资源所在网段。</p></li><li><p><strong>Pod 数量上限/节点</strong>： 决定分配给每个 Node 的 CIDR 的大小。</p></li><li><p><strong>Service 数量上限/集群</strong> ：决定分配给 Sevice 的 CIDR 大小。</p></li><li><p>目标机器 ：</p></li><li><p><strong>目标机器</strong>：节点的内网地址。（建议: Master&Etcd 节点配置<strong>4 核</strong>及以上的机型）</p></li><li><p><strong>SSH 端口</strong>： 请确保目标机器安全组开放 22 端口和 ICMP 协议，否则无法远程登录和 PING 云服务器。（<strong>建议使用默认值 22</strong>）</p></li><li><p><strong>主机 label</strong>：给主机设置 Label,可用于指定容器调度。（<strong>按需使用</strong>）</p></li><li><p><strong>认证方式</strong>：连接目标机器的方式</p><ul><li><strong>密码认证</strong>：<ul><li><strong>密码</strong>：目标机器密码</li></ul></li><li><strong>密钥认证</strong>：<ul><li><strong>私钥</strong>：目标机器秘钥</li><li><strong>私钥密码</strong>：目标机器私钥密码，可选填</li></ul></li></ul></li><li><p><strong>GPU</strong>： 使用 GPU 机器需提前安装驱动和 runtime。（<strong>按需使用</strong>）</p><blockquote><p>输入以上信息后单击【保存】后还可<strong>继续添加集群的节点</strong></p></blockquote></li><li><p><strong>提交</strong>： 集群信息填写完毕后，【提交】按钮变为可提交状态，单击即可提交。</p></li></ol><h3 id=导入已有集群>导入已有集群</h3><ol><li>登录 TKEStack。</li><li>切换至【平台管理】控制台。</li><li>在“集群管理”页面，单击【导入集群】。如下图所示：</li></ol><p><img src=../../../images/importCluster-1.png alt></p><ol><li>在“导入集群”页面，填写被导入的集群信息。如下图所示：</li></ol><p><img src=../../../images/importCluster-2.png alt></p><ol><li>名称： 被导入集群的名称，最长 60 字符</li><li>API Server：</li><li>被导入集群的 API server 的域名或 IP 地址，注意域名不能加上 https://</li><li>端口，此处用的是 https 协议，端口应填 443。</li><li>CertFile： 输入被导入集群的 cert 文件内容</li><li>Token： 输入被导入集群创建时的 token 值</li><li>单击最下方 【提交】 按钮 。</li></ol><h3 id=创建业务>创建业务</h3><blockquote><p>注：业务可以实现跨集群资源的使用</p></blockquote><ol><li>登录 TKEStack。</li><li>在【平台管理】控制台的【业务管理】中，单击 【新建业务】。如下图所示：</li></ol><p><img src=../../../images/createbusiness.png alt></p><ol><li>在“新建业务”页面，填写业务信息。如下图所示：</li></ol><p><img src=../../../images/createbusiness.png alt></p><ol><li>业务名称：不能超过 63 个字符，这里以<code>my-business</code>为例</li><li>业务成员： <a href=../user-guide/platform-console/access-mgmt/>【访问管理】</a>中【用户管理】中的用户，这里以<code>admin</code>例，即这该用户可以访问这个业务。</li><li>集群：</li><li>【集群管理】中的集群，这里以<code>gobal</code>集群为例</li><li>【填写资源限制】可以设置当前业务使用该集群的资源上限（可不限制）</li><li>【新增集群】可以添加多个集群，此业务可以使用多个集群的资源（按需添加）</li><li>上级业务：支持多级业务管理，按需选择（可不选）</li></ol><p>8 .单击最下方 【完成】 按钮即可创建业务。</p><h3 id=创建业务下的命名空间>创建业务下的命名空间</h3><ol><li>登录 TKEStack。</li><li>在【平台管理】控制台的【业务管理】中，单击【业务 id】。如下图所示：</li></ol><p><img src=../../../images/businessid.png alt></p><ol><li>单击【Namespace 列表】。如下图标签 1 所示：</li></ol><blockquote><p>该页面可以更改业务名称、成员、以及业务下集群资源的限制。</p></blockquote><p><img src=../../../images/businessns%20%281%29.png alt></p><ol><li>单击【新建 Namespace】。如下图所示：</li></ol><p><img src=../../../images/newns.png alt></p><ol><li>在“新建 Namespace”页面中，填写相关信息。如下图所示：</li></ol><p><img src=../../../images/my-ns.png alt></p><ol><li>名称：不能超过 63 个字符，这里以<code>new-ns</code>为例</li><li>集群：<code>my-business</code>业务中的集群，这里以<code>global</code>集群为例</li><li>资源限制：这里可以限制当前命名空间下各种资源的使用量，可以不设置。</li></ol><h3 id=创建业务下的-deployment>创建业务下的 Deployment</h3><ol><li>登录 TKEStack，点击【平台管理】选项旁边的切换按钮，可以切换到【业务管理】控制台。</li></ol><blockquote><p>注意：因为当前登录的是 admin 用户，【业务管理】控制台只包含在<a href=quick-starts.md#%E5%88%9B%E5%BB%BA%E4%B8%9A%E5%8A%A1>创建业务</a>中成员包含 admin 的业务，如果切换到【业务管理】控制台没有看见任何业务，请确认【平台管理】中【业务管理】中的相关业务的成员有没有当前用户，如没有，请添加当前用户。</p></blockquote><ol><li>点击左侧导航栏中的【应用管理】，如果当前用户被分配了多个业务，可通过下图中标签 3 的选择框选择合适的业务。</li><li>点击【工作负载】，点击下图标签 4 的【Deployment】，此时进入“Deployment”页面，可通过下图中的标签 5 选择 Deployment 的【命名空间】：</li></ol><p><img src=../../../images/deployment.png alt></p><ol><li>单击上图标签 6【新建】，进入“新建 Workload ”页面。根据实际需求，设置 Deployment 参数。这里参数很多，其中必填信息已用红框标识：</li></ol><p><img src=../../../images/createdeployment-1.png alt></p><ol><li>工作负载名：输入自定义名称，这里以<code>my-dep</code>为例</li><li>描述：给工作负载添加描述，可不填</li><li>标签：给工作负载添加标签，通过工作负载名默认生成</li><li>命名空间：根据实际需求进行选择</li><li>类型：选择【Deployment（可扩展的部署 Pod）】</li><li><strong>数据卷（选填）</strong>：为容器提供存储，目前支持临时路径、主机路径、云硬盘数据卷、文件存储 NFS、配置文件、PVC，还需挂载到容器的指定路径中。如需指定容器挂载至指定路径时，单击【添加数据卷】<ul><li><strong>临时目录</strong>：主机上的一个临时目录，生命周期和 Pod 一致</li><li><strong>主机路径</strong>：主机上的真实路径，可以重复使用，不会随 Pod 一起销毁</li><li><strong>NFS 盘</strong>：挂载外部 NFS 到 Pod，用户需要指定相应 NFS 地址，格式：127.0.0.1:/data</li><li><strong>ConfigMap</strong>：用户选择在业务 Namespace 下的<a href=../../user-guide/business-console/workload-mgmt/pei-zhi-guan-li/configmap>ConfigMap</a></li><li><strong>Secret</strong>：用户选择在业务 namespace 下的<a href=../../user-guide/business-console/workload-mgmt/pei-zhi-guan-li/secret>Secret</a></li><li><strong>PVC</strong>：用户选择在业务 namespace 下的<a href=../../user-guide/business-console/workload-mgmt/cun-chu/pv-he-pvc>PVC</a></li></ul></li><li><strong>实例内容器</strong>：根据实际需求，为 Deployment 的一个 Pod 设置一个或多个不同的容器。如下图所示：<ul><li><strong>名称</strong>：自定义，这里以<code>my-container</code>为例</li><li><strong>镜像</strong>：根据实际需求进行选择，这里以<code>nginx</code>为例<ul><li><strong>镜像版本（Tag）</strong>：根据实际需求进行填写，不填默认为<code>latest</code></li><li><strong>CPU/内存限制</strong>：可根据 <a href=https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/>Kubernetes 资源限制</a> 进行设置 CPU 和内存的限制范围，提高业务的健壮性（<strong>建议使用默认值</strong>）</li><li><strong>GPU 限制</strong>：如容器内需要使用 GPU，此处填 GPU 需求</li><li><strong>环境变量</strong>：用于设置容器内的变量，变量名只能包含大小写字母、数字及下划线，并且不能以数字开头<ul><li><strong>新增变量</strong>：自己设定变量键值对</li><li><strong>引用 ConfigMap/Secret</strong>：引用已有键值对</li></ul></li><li><strong>高级设置</strong>：可设置 “<strong>工作目录</strong>”、“<strong>运行命令</strong>”、“<strong>运行参数</strong>”、“<strong>镜像更新策略</strong>”、“<strong>容器健康检查</strong>”和“<strong>特权级</strong>”等参数。这里介绍一下镜像更新策略。<ul><li><p><strong>镜像更新策略</strong>：提供以下 3 种策略，请按需选择</p><p>若不设置镜像拉取策略，当镜像版本为空或 <code>latest</code> 时，使用 Always 策略，否则使用 IfNotPresent 策略</p><ul><li><strong>Always</strong>：总是从远程拉取该镜像</li><li><strong>IfNotPresent</strong>：默认使用本地镜像，若本地无该镜像则远程拉取该镜像</li><li><strong>Never</strong>：只使用本地镜像，若本地没有该镜像将报异常</li></ul></li></ul></li></ul></li></ul></li></ol><p><img src=../../../images/businessns%20%281%29%20%281%29.png alt></p><p><img src=../../../images/createdeployment-4.png alt></p><ul><li><strong>实例数量</strong>：根据实际需求选择调节方式，设置实例数量。<ul><li><strong>手动调节</strong>：直接设定实例个数</li><li><strong>自动调节</strong>：根据设定的触发条件自动调节实例个数，目前支持根据 CPU、内存利用率和利用量出入带宽等调节实例个数</li></ul></li><li><strong>显示高级设置</strong></li></ul><p><img src=../../../images/createdeployment-5.png alt></p><ul><li><p><strong>imagePullSecrets</strong>：镜像拉取密钥，用于拉取用户的私有镜像，使用私有镜像首先需要新建 Secret</p></li><li><p><strong>节点调度策略</strong>：根据配置的调度规则，将 Pod 调度到预期的节点。</p><ul><li><strong>不使用调度策略</strong>：k8s 自动调度</li><li><strong>自定义调度规则</strong>：通过节点的 Label 来实现<ul><li><strong>强制满足条件</strong>：调度期间如果满足亲和性条件则调度到对应 node，如果没有节点满足条件则调度失败。</li><li><strong>尽量满足条件</strong>：调度期间如果满足亲和性条件则调度到对应 node，如果没有节点满足条件则随机调度到任意节点。</li></ul></li></ul></li><li><p><strong>注释（Annotations）</strong>：给 deployment 添加相应 Annotation，如用户信息等</p></li><li><p><strong>网络模式</strong>：选择 Pod 网络模式</p><ul><li><strong>OverLay（虚拟网络）</strong>：基于 IPIP 和 Host Gateway 的 Overlay 网络方案</li><li><strong>FloatingIP（浮动 IP）</strong>：支持容器、物理机和虚拟机在同一个扁平面中直接通过 IP 进行通信的 Underlay 网络方案。提供了 IP 漂移能力，支持 Pod 重启或迁移时 IP 不变</li><li><strong>NAT（端口映射</strong>）：Kubernetes 原生 NAT 网络方案</li><li><strong>Host（主机网络）</strong>：Kubernetes 原生 Host 网络方案</li></ul></li><li><p><strong>创建 Service（可选）</strong>：</p></li><li><p><strong>Service</strong>：勾选【启用】按钮，配置负载端口访问</p><blockquote><p>注意：如果不勾选【启用】则不会创建 Service</p></blockquote></li><li><p><strong>服务访问方式</strong>：选择是【仅在集群内部访问】该负载还是集群外部通过【主机端口访问】该负载</p><ul><li><strong>仅在集群内访问</strong>：使用 Service 的 ClusterIP 模式，自动分配 Service 网段中的 IP，用于集群内访问。数据库类等服务如 MySQL 可以选择集群内访问，以保证服务网络隔离</li><li><strong>主机端口访问</strong>：提供一个主机端口映射到容器的访问方式，支持 TCP、UDP、Ingress。可用于业务定制上层 LB 转发到 Node</li><li><strong>Headless Service</strong>：不创建用于集群内访问的 ClusterIP，访问 Service 名称时返回后端 Pods IP 地址，用于适配自有的服务发现机制。解析域名时返回相应 Pod IP 而不是 Cluster IP</li></ul></li><li><p><strong>端口映射</strong>：输入负载要暴露的端口并指定通信协议类型（<strong>容器和服务端口建议都使用 80</strong>）</p></li><li><p><strong>Session Affinity:</strong> 点击【显示高级设置】出现，会话保持，设置会话保持后，会根据请求 IP 把请求转发给这个 IP 之前访问过的 Pod。默认 None，按需使用</p></li><li><p>单击【创建 Workload】，完成创建。</p></li></ul><p>​ 当“运行/期望 Pod 数量”相等时，即表示 Deployment 下的所有 Pod 已创建完成。</p><ul><li>如果在第 5 步中有创建 Service，则可以再【服务】下的【Service】看到与刚刚创建的 Deployment 同名的 Service</li></ul><h3 id=删除资源>删除资源</h3><p>在本节中，启动了<code>my-business</code>业务下的 Deployment 和 Service 两种资源，此步骤介绍如何清除所有资源。</p><h4 id=删除-deployment>删除 Deployment</h4><ol><li>登录 TKEStack，切换到【业务管理】控制台，选择左侧导航栏中的【应用管理】。</li><li>展开【工作负载】下拉项，进入 “Deployment” 管理页面，选择需要删除【Deployment】的业务下相应的【命名空间】，点击要删除的 Deployment 最右边的【更多】，点击【删除】。如下图所示：</li><li>在弹出框中单击【确定】，即可删除 Deployment。</li></ol><h4 id=删除-service>删除 Service</h4><ol><li>登录 TKEStack，切换到【业务管理】控制台，选择左侧导航栏中的【应用管理】。</li><li>展开【服务】下拉项，进入 “Service” 管理页面，选择需要删除【Service】的业务下相应的【命名空间】，点击要删除的 Service 最右边的【删除】。如下图所示：</li><li>在弹出框中单击【确定】，即可删除 Service。</li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-5e4d3b51a81e2f2500a2db566d211b8f>3.2 - 入门示例</h1><div class=lead>入门示例</div></div><div class=td-content><h1 id=pg-fab69c9d83a9da61b39c006b88f3929a>3.2.1 - 创建nginx服务</h1><div class=lead>创建nginx服务</div><p>本文档旨在帮助大家了解如何快速创建一个容器集群内的 nginx 服务。</p><h2 id=前提条件>前提条件</h2><blockquote><ul><li>已部署 <a href=../../../installation/environment-requirement>TKEStack 控制台</a>。</li><li>已创建集群。如没有另外创建集群，可以先使用global集群。如要尝试创建新集群，请参见 <a href=../../../user-guide/platform-console/cluster-mgmt>创建集群</a>。</li></ul></blockquote><h2 id=操作步骤>操作步骤</h2><h3 id=创建-nginx-服务>创建 Nginx 服务</h3><ol><li>登录TKEStack 控制台 。</li></ol><p><img src=../../../../images/nginx-0.png alt></p><ol><li>单击左侧导航栏中【集群管理】，进入“集群管理”页面，单击需要创建服务的集群 ID。</li></ol><p><img src=../../../../images/nginx-1.png alt></p><ol><li>进入【工作负载】的【 Deployment 】中，选择【新建】。如下图所示：</li></ol><p><img src=../../../../images/nginx-2%20%281%29%20%281%29%20%282%29.png alt></p><ol><li>在“新建Workload”页面，只需输入下图中红框的参数即可。</li></ol><p><img src=../../../../images/nginx-2%20%281%29%20%281%29.png alt></p><p><img src=../../../../images/nginx-3.png alt></p><p><img src=../../../../images/nginx-4.png alt></p><blockquote><p>注意：服务所在集群的安全组需要放通节点网络及容器网络，同时需要放通30000 - 32768端口，否则可能会出现容器服务无法使用问题。</p></blockquote><ol><li>单击上图中的【创建Workload】，完成创建。如下图所示：</li></ol><blockquote><p>注意：当运行/期望Pod数量一致时，负载完成创建。</p></blockquote><p><img src=../../../../images/nginx-5.png alt></p><ol><li>如果在第5步中有创建Service，则可以在【服务】下的【Service】看到与刚刚创建的Deployment同名的Service</li></ol><p><img src=../../../../images/nginx-6.png alt></p><h3 id=访问-nginx-服务>访问 Nginx 服务</h3><p>可通过以下两种方式访问 nginx 服务。</p><h4 id=通过主机节点端口访问-nginx-服务>通过主机节点端口访问 nginx 服务</h4><p>在本地主机的浏览器地址栏输入<code>集群任意节点IP:30000 端口</code>，例如<code>10.0.0.1:30000</code>即可访问服务。如果服务创建成功，访问服务时直接进入 nginx 服务器的默认欢迎页。如下图所示：</p><blockquote><p>注意：如果本地主机在集群内网中，输入节点的内网IP地址即可；如果本地主机不在集群内网中，需要输入节点的外网IP地址</p></blockquote><p><img src=https://main.qcloudimg.com/raw/37246241fe0abd1d3796c080b1661217.png alt></p><h4 id=通过服务名称访问-nginx-服务>通过服务名称访问 nginx 服务</h4><p>集群内的其他服务或容器可以直接通过服务名称访问。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-9a2a5aa9bc2d08d259f1ad9a976eb560>3.2.2 - 编写HelloWorld程序</h1><div class=lead>编写HelloWorld程序</div><h2 id=操作场景>操作场景</h2><p>本文档旨在帮助大家了解如何快速创建一个容器集群内的 Hello World 的 Node.js 版的服务。</p><h2 id=前提条件>前提条件</h2><ul><li>已部署 <a href=../../../installation/environment-requirement>TKEStack 控制台</a>。</li><li>已创建集群。如没有另外创建集群，可以先使用global集群。如要尝试创建新集群，请参见 <a href=../../../user-guide/platform-console/cluster-mgmt>创建集群</a>。</li></ul><h2 id=操作步骤>操作步骤</h2><h3 id=编写代码制作镜像>编写代码制作镜像</h3><h4 id=编写应用程序>编写应用程序</h4><p>以CentOS 7.6为例</p><ol><li><p>安装node.js，然后依次执行以下命令，创建并进入 hellonode 的文件夹。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>yum install -y nodejs
mkdir hellonode
cd hellonode/
</code></pre></div></li><li><p>执行以下命令，新建并打开 server.js 文件。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>vim server.js
</code></pre></div></li><li><p>按 “<strong>i</strong>” 或 “<strong>insert</strong>” 切换至编辑模式，将以下内容输入 server.js。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#204a87;font-weight:700>var</span> <span style=color:#000>http</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>require</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;http&#39;</span><span style=color:#000;font-weight:700>);</span>
<span style=color:#204a87;font-weight:700>var</span> <span style=color:#000>handleRequest</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>function</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>request</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>response</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
<span style=color:#000>console</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>log</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;Received request for URL: &#39;</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>request</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>url</span><span style=color:#000;font-weight:700>);</span>
<span style=color:#000>response</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>writeHead</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>200</span><span style=color:#000;font-weight:700>);</span>
<span style=color:#000>response</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>end</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#39;Hello World!&#39;</span><span style=color:#000;font-weight:700>);</span>
<span style=color:#000;font-weight:700>};</span>
<span style=color:#204a87;font-weight:700>var</span> <span style=color:#000>www</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>http</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>createServer</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>handleRequest</span><span style=color:#000;font-weight:700>);</span>
<span style=color:#000>www</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>listen</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>80</span><span style=color:#000;font-weight:700>);</span>
</code></pre></div><p>按 “<strong>Esc</strong>”，输入 “<strong>:wq</strong>”，保存文件并返回。</p></li><li><p>执行以下命令，执行 server.js 文件。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>node server.js
</code></pre></div></li><li><p>测试 Hello World 程序，有以下两种办法。 1. 另起一个终端，再次登录节点，执行以下命令。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>   curl 127.0.0.1:80

   # 终端会输出一下信息
   Hello World!
</code></pre></div><ol><li><p>打开本地主机的浏览器，以<code>IP地址:端口</code>的形式访问，端口为80。 网页出现<code>Hello world!</code>说明 Hello World 程序运行成功。</p><blockquote><p>注意：如果本地主机不在该节点所在的内网，IP地址应该是该节点的外网地址</p></blockquote></li></ol></li></ol><h4 id=创建-docker-镜像>创建 Docker 镜像</h4><ol><li><p>在 hellonode 文件夹下，创建 Dockerfile 文件。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>[root@VM_1_98_centos hellonode]# vim Dockerfile
</code></pre></div></li><li><p>按 “<strong>i</strong>” 或 “<strong>insert</strong>” 切换至编辑模式，将以下内容输入 Dockerfile 文件。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>FROM node:4.4
EXPOSE 80
COPY server.js .
CMD node server.js
</code></pre></div><p>按 “<strong>Esc</strong>”，输入 “<strong>:wq</strong>”，保存文件并返回。</p></li><li><p>执行以下命令，构建镜像。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>docker build -t hello-node:v1 .
</code></pre></div></li><li><p>执行以下命令，查看构建好的 hello-node 镜像。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>docker images
</code></pre></div><p>显示结果如下，则说明 hello-node 镜像已成功构建，记录其 IMAGE ID。如下图所示：</p><p><img src=../../../../images/helloworld-3.png alt></p></li></ol><h4 id=上传该镜像到镜像仓库>上传该镜像到镜像仓库</h4><blockquote><ul><li>已在<a href=../../../user-guide/platform-console/registry-mgmt/>【组织资源】</a>中的【镜像仓库管理】创建命名空间。</li><li>已在<a href=../../../user-guide/platform-console/registry-mgmt/>【组织资源】</a>中的【访问凭证】创建访问凭证。</li></ul></blockquote><p>依次执行以下命令，上传镜像到 qcloud 仓库。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>sudo docker login -u tkestack -p 【访问凭证】 default.registry.tke.com
sudo docker tag 【IMAGEID】 default.registry.tke.com/【命名空间】/helloworld:v1
sudo docker push default.registry.tke.com/【命名空间】/helloworld:v1
</code></pre></div><blockquote><ul><li>请将命令中的 【访问凭证】 替换为 已创建的访问凭证。</li><li>请将命令中的 【IMAGEID】 替换为 你自己创建镜像的ID，示例中的ID如上图158204134510。</li><li>请将命令中的 【命名空间】 替换为 已创建的命名空间。</li></ul><p>显示以下结果，则说明镜像上传成功。 <img src=../../../../images/helloworld-4.png alt></p></blockquote><h4 id=在镜像仓库命名空间中进行确认>在镜像仓库命名空间中进行确认</h4><p><img src=../../../../images/helloworld-6.png alt></p><h3 id=通过该镜像创建-hello-world-服务>通过该镜像创建 Hello World 服务</h3><ol><li><p>登录 TKEStack 控制台。</p></li><li><p>单击左侧导航栏中【集群管理】，进入“集群管理”页面。</p></li><li><p>单击需要创建服务的集群 ID，进入工作负载 “Deployment” 详情页，选择【新建】。如下图所示：</p><p><img src=../../../../images/helloworld-5.png alt></p></li><li><p>在“新建Workload”页面，仅输入以下红框内容即可：</p><p><img src=../../../../images/helloworld-8.png alt></p><p><img src=../../../../images/helloworld-7.png alt><img src=../../../../images/helloworld-10.png alt></p><blockquote><p>注意：</p><ol><li>镜像，地址要填全：default.registry.tke.com/【命名空间】/【镜像名】，例如：default.registry.tke.com/test/helloworld</li><li>服务所在集群的安全组需要放通节点网络及容器网络，同时需要放通30000 - 32768端口，否则可能会出现容器服务无法使用问题。</li></ol></blockquote></li><li><p>单击【创建Workload】，完成 Hello World 服务的创建。</p></li></ol><h3 id=访问-hello-world-服务>访问 Hello World 服务</h3><p>可通过以下两种方式访问 Hello World 服务。</p><h4 id=通过主机节点端口访问-hello-world-服务>通过主机节点端口访问 Hello World 服务</h4><ol><li><p>选择【服务】>【Service】，在“Service”管理页面，看到与名为helloworld的Deployment同名的 helloworld Service已经运行，如下图所示：<img src=../../../../images/helloworld-11.png alt></p></li><li><p>在本地主机的浏览器地址栏输入<code>集群任意节点IP:30000 端口</code>，例如<code>10.0.0.1:30000</code>即可访问服务。如果服务创建成功，访问服务时页面会返回<code>Hello World！</code></p><blockquote><p>注意：如果本地主机在集群内网中，输入节点的内网IP地址即可；如果本地主机不在集群内网中，需要输入节点的外网IP地址</p></blockquote></li></ol><h4 id=通过服务名称访问-hello-world-服务>通过服务名称访问 Hello World 服务</h4><p>集群内的其他服务或容器可以直接通过服务名称访问。</p><p>更多关于Docker 镜像请参见 <a href=../docker-image-example>如何构建 Docker 镜像</a> 。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d2fc2e9c475dda096ccff56f6718d569>3.2.3 - 如何构建Docker镜像</h1><div class=lead>如何构建Docker镜像</div><h2 id=说明>说明</h2><p>DockerHub 提供了大量的镜像可用，详情可查看 <a href=https://hub.docker.com/>DockerHub 官网</a>。</p><p>Docker 容器的设计宗旨是让用户在相对独立的环境中运行独立的程序。</p><p>Docker 容器程序在镜像内程序运行结束后会自动退出。如果要令构建的镜像在服务中持续运行，需要在创建服务页面指定自身持续执行的程序，如：业务主程序，main 函数入口等。</p><p>由于企业环境的多样性，并非所有应用都能在 DockerHub 找到对应的镜像来使用。 您可以通过以下教程了解到如何将应用打包成Docker镜像。</p><p>Docker 生成镜像目前有两种方式：</p><ul><li>通过 Dockerfile 自动构建镜像；</li><li>通过容器操作，并执行 Commit 打包生成镜像。</li></ul><h2 id=dockerfile-自动编译生成推荐使用>Dockerfile 自动编译生成（推荐使用）</h2><p>以 Dockerhub 官方提供的 WordPress 为例，<a href=https://github.com/docker-library/wordpress/blob/7d40c4237f01892bb6dbc67d1a82f5b15f807ca1/php5.6/apache/Dockerfile>转到 github 查看详情 >></a></p><p>其 Dockfile 源码如下：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>FROM php:5.6-apache

# install the PHP extensions we need
RUN apt-get update &amp;&amp; apt-get install -y libpng12-dev libjpeg-dev &amp;&amp; rm -rf /var/lib/apt/lists/* \
    &amp;&amp; docker-php-ext-configure gd --with-png-dir=/usr --with-jpeg-dir=/usr \
    &amp;&amp; docker-php-ext-install gd mysqli opcache

# set recommended PHP.ini settings
# see https://secure.php.net/manual/en/opcache.installation.php
RUN { \
        echo &#39;opcache.memory_consumption=128&#39;; \
        echo &#39;opcache.interned_strings_buffer=8&#39;; \
        echo &#39;opcache.max_accelerated_files=4000&#39;; \
        echo &#39;opcache.revalidate_freq=2&#39;; \
        echo &#39;opcache.fast_shutdown=1&#39;; \
        echo &#39;opcache.enable_cli=1&#39;; \
    } &gt; /usr/local/etc/php/conf.d/opcache-recommended.ini

RUN a2enmod rewrite expires

VOLUME /var/www/html

ENV WORDPRESS_VERSION 4.6.1
ENV WORDPRESS_SHA1 027e065d30a64720624a7404a1820e6c6fff1202

RUN set -x \
    &amp;&amp; curl -o wordpress.tar.gz -fSL &#34;https://wordpress.org/wordpress-${WORDPRESS_VERSION}.tar.gz&#34; \
    &amp;&amp; echo &#34;$WORDPRESS_SHA1 *wordpress.tar.gz&#34; | sha1sum -c - \
# upstream tarballs include ./wordpress/ so this gives us /usr/src/wordpress
    &amp;&amp; tar -xzf wordpress.tar.gz -C /usr/src/ \
    &amp;&amp; rm wordpress.tar.gz \
    &amp;&amp; chown -R www-data:www-data /usr/src/wordpress

COPY docker-entrypoint.sh /usr/local/bin/
RUN ln -s usr/local/bin/docker-entrypoint.sh /entrypoint.sh # backwards compat

# ENTRYPOINT resets CMD
ENTRYPOINT [&#34;docker-entrypoint.sh&#34;]
CMD [&#34;apache2-foreground&#34;]
</code></pre></div><p>通过上述 Dockerfile 文件可以了解到，内置执行了许多的 Linux 命令来安装和部署软件。</p><h2 id=操作步骤>操作步骤</h2><p>在终端创建一个名为worldpress的文件夹，在该文件夹下创建 Dockerfile 文件，文件内容即以上代码。通过 <code>docker build ./</code>命令来构建镜像。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>[root@VM_1_98_centos ~]# mkdir worldpress
[root@VM_1_98_centos ~]# ls
worldpress
[root@VM_1_98_centos ~]# cd worldpress/
[root@VM_1_98_centos worldpress]# vi Dockerfile
[root@VM_1_98_centos worldpress]# ls
Dockerfile
[root@VM_1_98_centos worldpress]# docker build ./
Sending build context to Docker daemon  3.072kB
Step 1/12 : FROM php:5.6-apache
5.6-apache: Pulling from library/php
5e6ec7f28fb7: Pull complete
cf165947b5b7: Pull complete
7bd37682846d: Pull complete
······
</code></pre></div><p>通过 docker images 命令即可查看到构建完成的镜像。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>[root@VM_88_88_centos worldpress]# docker images
REPOSITORY                                     TAG                 IMAGE ID            CREATED             SIZE
worldpress                                     latest              9f0b470b5ddb        12 minutes ago      420 MB
docker.io/php                                  5.6-apache          eb8333e24502        5 days ago          389.7 MB
</code></pre></div><p>使用 Dockerfile 来构建镜像有以下建议： 1. 尽量精简，不安装多余的软件包。 2. 尽量选择 Docker 官方提供镜像作为基础版本，减少镜像体积。 3. Dockerfile 开头几行的指令应当固定下来，不建议频繁更改，有效利用缓存。 4. 多条 RUN 命令使用''连接，有利于理解且方便维护。 5. 通过 -t 标记构建镜像，有利于管理新创建的镜像。 6. 不在 Dockerfile 中映射公有端口。 7. Push 前先在本地运行，确保构建的镜像无误。</p><h2 id=执行-commit-实现打包生成镜像>执行 Commit 实现打包生成镜像</h2><p>通过 Dockerfile 可以快速构建镜像，而通过 commit 生成镜像可以解决应用在部署过程中有大量交互内容以及难以通过 Dockerfile 构建的问题。</p><p>通过 commit 构建镜像操作如下： 1. 运行基础镜像容器，并进入console。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>[root@VM_88_88_centos ~]# docker run -i -t centos
[root@f5f1beda4075 /]#
</code></pre></div><ol><li><p>安装需要的软件，并添加配置。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>[root@f5f1beda4075 /]# yum update &amp;&amp; yum install  openssh-server
Loaded plugins: fastestmirror, ovl
base                                                                                                                                                                    | 3.6 kB  00:00:00     
extras                                                                                                                                                                  | 3.4 kB  00:00:00     
updates                                                                                                                                                                 | 3.4 kB  00:00:00     
(1/4): base/7/x86_64/group_gz                                                                                                                                           | 155 kB  00:00:00     
(2/4): extras/7/x86_64/primary_db                                                                                                                                       | 166 kB  00:00:00     
(3/4): base/7/x86_64/primary_db                                                                                                                                         | 5.3 MB  00:00:00     
(4/4): updates/7/x86_64/primary_db 
......
......
......
Dependency Installed:
fipscheck.x86_64 0:1.4.1-5.el7              fipscheck-lib.x86_64 0:1.4.1-5.el7              openssh.x86_64 0:6.6.1p1-25.el7_2              tcp_wrappers-libs.x86_64 0:7.6-77.el7             
Complete!
</code></pre></div></li><li><p>配置完成后打开新终端保存该镜像。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>shell
[root@VM_88_88_centos ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
f5f1beda4075        centos              &#34;/bin/bash&#34;         8 minutes ago       Up 8 minutes                            hungry_kare
[root@VM_88_88_centos ~]# docker commit f5f1beda4075 test:v1.0      
sha256:65325ffd2af9d574afca917a8ce81cf8a710e6d1067ee611a87087e1aa88e4a4
[root@VM_88_88_centos ~]# 
[root@VM_88_88_centos ~]# docker images
REPOSITORY                                     TAG                 IMAGE ID            CREATED             SIZE
test                                           v1.0                65325ffd2af9        11 seconds ago      307.8 MB
</code></pre></div></li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-ecf7e357d2a131135219db95eddda49c>4 - 产品使用指南</h1><div class=lead>产品使用指南</div></div><div class=td-content><h1 id=pg-61777f7ebad3712dd7b6ca6604171a31>4.1 - 切换控制台</h1><div class=lead>切换控制台</div><h2 id=概念>概念</h2><p><strong>这里用户可以自由切换控制面和业务面。</strong></p><blockquote><p>注意：只有当【平台管理】控制台中创建的业务的成员包含当前登录的用户，当前用户才会出现并可以切换至【业务管理】控制台，如下图所示。</p></blockquote><p><img src=../../../images/qie-huan-qian-ti-.png alt></p><h2 id=操作步骤>操作步骤</h2><ol><li>登录 TKEStack，默认显示【平台管理】控制台,鼠标移动到【平台管理】旁，会出现切换提示,如下图：</li></ol><p><img src=../../../images/qie-huan-.png alt></p><ol><li>如果当前显示的是【业务管理】控制台，鼠标移动到【业务管理】旁，会出现切换提示，如下图：</li></ol><p><img src=../../../images/qie-huan-1.png alt></p><ol><li>点击【 切换图标】 即可实现【平台管理】和【业务管理】控制台切换。</li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-3261558bde8adcdba76287116c6556b4>4.2 - 平台管理控制台</h1><div class=lead>平台管理控制台</div></div><div class=td-content><h1 id=pg-244fe30a59f1efe2a63093adc1d95f1d>4.2.1 - 概览</h1><div class=lead>概览</div><p>平台概览页面，可查看TKEStack控制台管理资源的概览。</p><p>如下图所示，在【平台管理】页面点击【概览】，此处可以展现：</p><ol><li>平台的资源概览</li><li>集群的资源状态</li><li>快速入口</li><li>实用提示</li></ol><p><img src=../../../../images/overview.png alt></p></div><div class=td-content style=page-break-before:always><h1 id=pg-8a8e3c823159d27959aba112514409fb>4.2.2 - 集群管理</h1><div class=lead>集群管理</div><h2 id=概念>概念</h2><p><strong>在这里可以管理你的 Kubernetes 集群</strong></p><p><img src=../../../../images/1588923397_72_w857_h868.png alt=img></p><p>平台安装之后，可在【平台管理】控制台的【集群管理】中看到 global 集群，如下图所示： <img src=../../../../images/cluster%20%282%29%20%282%29%20%285%29.png alt=Global&#x96C6;&#x7FA4;></p><p>TKEStack还可以另外<strong>新建独立集群</strong>以及<strong>导入已有集群</strong>实现<strong>多集群的管理</strong></p><blockquote><p>注意：<strong>新建独立集群</strong>和<strong>导入已有集群</strong>都属于<a href=../../../installation/installation-architecture>TKEStack架构</a>中的<strong>业务集群</strong>。</p></blockquote><h2 id=新建独立集群>新建独立集群</h2><ol><li><p>登录 TKEStack，右上角会出现当前登录的用户名，示例为admin</p></li><li><p>切换至【平台管理】控制台</p></li><li><p>在“集群管理”页面中，单击【新建独立集群】，如下图所示：</p><p><img src=../../../../images/createCluster.png alt=&#x65B0;&#x5EFA;&#x72EC;&#x7ACB;&#x96C6;&#x7FA4;></p></li><li><p>在“新建独立集群”页面，填写集群的基本信息。新建的集群节点需满足<a href=https://github.com/ruyingzhe/docs/tree/7f24a45c0f07eac673325093def1526590391c03/docs/installation/installation-requirement.md>部署环境要求</a>，在满足需求之后，TKEStack的集群添加非常便利。如下图所示,只需填写【集群名称】、【目标机器】、【SSH端口】（默认22）、【密码】，其他保持默认即可添加新的集群。</p><blockquote><p>注意：若【保存】按钮是灰色，单击页面空白处即可变蓝</p></blockquote><p><img src=../../../../images/ClusterInfo.png alt=&#x96C6;&#x7FA4;&#x57FA;&#x672C;&#x4FE1;&#x606F;0.png></p><ul><li><p><strong>集群名称：</strong> 支持<strong>中文</strong>，小于60字符即可</p></li><li><p><strong>Kubernetes版本：</strong> 选择合适的kubernetes版本，各版本特性对比请查看 <a href=https://kubernetes.io/docs/home/supported-doc-versions/>Supported Versions of the Kubernetes Documentation</a>（<strong>建议使用默认值</strong>）</p></li><li><p><strong>网卡名称：</strong> 可以通过 ifconfig 查看设备的网卡名称，一般默认都是 eth0。但有一些特殊情况：如果非 eth0 一定要填入正确的网卡名称，否则跨设备通信容易出现问题</p></li><li><p><strong>高可用类型</strong> ：高可用 VIP 地址（<strong>按需使用</strong>）</p><blockquote><p>注意：如果使用高可用，至少需要三个 master 节点才可组成高可用集群，否则会出现 <em><strong>脑裂</strong></em> 现象。</p></blockquote><ul><li><strong>不设置</strong>：第一台 master 节点的 IP 地址作为 APIServer 地址</li></ul></li><li><p><strong>TKE 提供</strong>：用户只需提供高可用的 IP 地址。TKE 部署 Keepalive，配置该 IP 为 Global 集群所有 Master 节点的VIP，以实现 Global 集群和控制台的高可用，此时该 VIP 和所有 Master 节点 IP 地址都是 APIServer 地址</p><ul><li><strong>使用已有</strong>：对接配置好的外部 LB 实例。VIP 绑定 Global 集群所有 Master 节点的 80（TKEStack 控制台）、443（TKEStack 控制台）、6443（kube-apiserver 端口）、31138（tke-auth-api 端口）端口，同时确保该 VIP 有至少两个 LB 后端（Master 节点），以避免 LB 单后端不可用风险</li></ul></li><li><p><strong>GPU</strong>：选择是否安装 GPU 相关依赖。（<strong>按需使用</strong>）</p><blockquote><p>注意：使用 GPU 首先确保节点有物理 GPU 卡，选择 GPU 类型后，平台将自动为节点安装相应的 GPU 驱动和运行时工具</p></blockquote><ul><li><strong>pGPU</strong>：平台会自动为集群安装 <a href=https://github.com/tkestack/docs/blob/master/features/gpumanager.md>GPUManager</a> 扩展组件，此时可以给负载分配任意整数张卡</li><li><strong>vGPU</strong>：平台会自动为集群安装 <a href=https://github.com/NVIDIA/k8s-device-plugin>Nvidia-k8s-device-plugin</a>，此时GPU可以被虚拟化，可以给负载分配非整数张GPU卡，例如可以给一个负载分配0.3个GPU</li></ul></li><li><p><strong>容器网络</strong> ：将为集群内容器分配在容器网络地址范围内的 IP 地址，您可以自定义三大私有网段作为容器网络， 根据您选择的集群内服务数量的上限，自动分配适当大小的 CIDR 段用于 kubernetes service；根据您选择 Pod 数量上限/节点，自动为集群内每台云服务器分配一个适当大小的网段用于该主机分配 Pod 的 IP 地址。（<strong>建议使用默认值</strong>）</p><ul><li><strong>CIDR：</strong> 集群内 Sevice、 Pod 等资源所在网段，注意：CIDR不能与目标机器IP段重叠， 否则会造成初始化失败</li><li><strong>Pod数量上限/节点：</strong> 决定分配给每个 Node 的 CIDR 的大小</li><li><strong>Service数量上限/集群</strong>：决定分配给 Sevice 的 CIDR 大小</li></ul></li><li><p><strong>Master</strong> ：输入目标机器信息后单击保存，<strong>若保存按钮是灰色，单击网页空白处即可变蓝</strong></p><blockquote><p>注意：如果在之前选择了高可用，至少需要三个 master 节点才可组成高可用集群，否则会出现 <em><strong>脑裂</strong></em> 现象。</p></blockquote><ul><li><p><strong>目标机器</strong>：Master 节点<strong>内网 IP</strong>，请配置<strong>至少 8 Cores & 16G 内存</strong> 及以上的机型，<strong>否则会部署失败</strong>。注意：如上图所示，如果节点密码一样，这里可以通过英文的分号“;”分隔多个 IP 地址实现快速添加多个节点</p></li><li><p><strong>SSH 端口</strong>： 请确保目标机器安全组开放 22 端口和 ICMP 协议，否则无法远程登录和 ping 通云服务器。（<strong>建议使用默认值22</strong>）</p></li><li><p><strong>主机label</strong>：给主机设置 Label,可用于指定容器调度。（<strong>按需使用</strong>）</p></li><li><p><strong>认证方式</strong>：连接目标机器的方式</p><ul><li><strong>密码认证</strong>：<ul><li><strong>密码</strong>：目标机器密码</li></ul></li><li><strong>密钥认证</strong>：<ul><li><strong>密码</strong>：目标机器密码</li><li><strong>证书</strong>：目标机器登陆证书</li></ul></li></ul></li><li><p><strong>GPU</strong>： 使用 GPU 机器需提前安装驱动和 runtime。（<strong>按需使用</strong>）</p><blockquote><p><strong>添加机器</strong>：可以通过节点下面的**【添加】**蓝色字体增加不同密码的master节点（**按需添加**）</p></blockquote></li></ul></li></ul></li><li><p><strong>提交</strong>： 集群信息填写完毕后，【提交】按钮变为可提交状态，单击即可提交。</p></li></ol><h2 id=导入已有集群>导入已有集群</h2><ol><li>登录 TKEStack</li><li>切换至【平台管理】控制台</li><li>在“集群管理”页面，单击【导入集群】，如下图所示： <img src=../../../../images/importCluster-1.png alt=&#x5BFC;&#x5165;&#x96C6;&#x7FA4;></li><li>在“导入集群”页面，填写被导入的集群信息，如下图所示： <img src=../../../../images/importCluster-2.png alt=&#x5BFC;&#x5165;&#x96C6;&#x7FA4;&#x4FE1;&#x606F;><ul><li><p><strong>名称</strong>： 被导入集群的名称，最长60字符</p></li><li><p><strong>API Server</strong>： 被导入集群的 API Server 的域名或 IP 地址</p></li><li><p><strong>CertFile</strong>： 输入被导入集群的 CertFile 文件内容</p></li><li><p><strong>Token</strong>： 输入被导入集群创建时的 token 值</p><blockquote><p>注意：若不清楚集群的这些信息如何获取，可以参照下面导入 TKE/ACK/RKE 的方式导入自己的集群。</p></blockquote></li></ul></li><li>单击最下方 【提交】 按钮</li></ol><h4 id=tkestack-导入腾讯的-tke-集群>TKEStack 导入腾讯的 TKE 集群</h4><ol><li><p>首先需要在 TKE 控制台所要导入的集群“基本信息”页里开启内/外网访问</p><p><img src=https://github.com/ruyingzhe/docs/tree/7f24a45c0f07eac673325093def1526590391c03/docs/images/image-20200930154323734.png alt=image-20200930154323734></p></li><li><p><strong>APIServer 地址</strong>：即上图中的访问地址，也可以根据上图中 kubeconfig 文件里的“server”字段内容填写。</p></li><li><p><strong>CertFile</strong>：集群证书，kubeconfig 中“certificate-authority-data”字段内容。</p></li><li><p><strong>Token</strong>：由于目前 TKE 没有自动创建具有 admin 权限的 token，这里需要手动创建，具体方式如下：</p><ol><li><p>生成 kubernetes 集群最高权限 admin 用户的 token</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#000>cat &lt;&lt;EOF | kubectl apply -f -</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>kind</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ClusterRoleBinding</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>apiVersion</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>rbac.authorization.k8s.io/v1beta1</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>metadata</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>admin</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>annotations</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>rbac.authorization.kubernetes.io/autoupdate</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;true&#34;</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>roleRef</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>kind</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ClusterRole</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>cluster-admin</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>apiGroup</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>rbac.authorization.k8s.io</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>subjects</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span>- <span style=color:#204a87;font-weight:700>kind</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ServiceAccount</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>admin</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>namespace</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>kube-system</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>---</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>apiVersion</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>v1</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>kind</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ServiceAccount</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>metadata</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>admin</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>namespace</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>kube-system</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>labels</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>kubernetes.io/cluster-service</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;true&#34;</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>addonmanager.kubernetes.io/mode</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Reconcile</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>EOF</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div></li><li><p>创建完成后获取 secret 中 token 的值</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text># 获取admin-token的secret名字
$ kubectl -n kube-system get secret|grep admin-token
admin-token-nwphb                          kubernetes.io/service-account-token   3         6m
# 获取token的值
$ kubectl -n kube-system describe secret admin-token-nwphb | grep token
Name:         admin-token-w4wcd
Type:  kubernetes.io/service-account-token
token:            非常长的字符串
</code></pre></div></li></ol></li></ol><h4 id=tkestack-中导入-rancher-的-rke-集群>TKEStack 中导入 Rancher 的 RKE 集群</h4><blockquote><p>特别注意：RKE 集群的 kubeconfig 中 clusters 字段里面的第一个 cluster 一般都是 Rancher 平台，而不是 RKE 集群。输入以下信息时，要确定选择正确的集群。</p></blockquote><ol><li><p>获取 RKE 的 kubeconfig 文件</p></li><li><p><strong>APIServer 地址</strong>：获取文件里面的“cluster”字段下“server”的内容。注意是引号里的全部内容</p></li><li><p><strong>CertFile</strong>：集群证书，在上面的“server”地址的正下方，有集群证书字段“certificate-authority-data”。</p><blockquote><p>注意，Rancher 的 kubeconfig 这里的字段内容默认有“\”换行符，需要手动把内容里的换行符和空格全部去除。</p></blockquote></li><li><p><strong>Token</strong>：在“user”字段里面拥有用户的 token</p></li></ol><h4 id=tkestack-中导入阿里的-ack-集群>TKEStack 中导入阿里的 ACK 集群</h4><ol><li>和 TKE 一样，需要获取开启外网访问的 ACK 的 kubeconfig 文件</li><li><strong>APIServer 地址</strong>：获取文件里面的“cluster”字段下“server”的内容</li><li><strong>CertFile</strong>：集群证书，在上面的“server”地址正下方有集群证书字段“certificate-authority-data”</li><li><strong>Token</strong>：获取方式同 TKE，需要手动创建</li></ol><h2 id=对集群的操作><strong>对集群的操作</strong></h2><h3 id=基本信息>基本信息</h3><ol><li><p>登录 TKEStack</p></li><li><p>切换至【平台管理】控制台</p></li><li><p>在“集群管理”页面中，点击要操作的集群ID，如下图“global”所示：</p><p><img src=../../../../images/cluster%20%282%29%20%282%29%20%282%29.png alt=Global&#x96C6;&#x7FA4;></p></li><li><p>点击【基本信息】，可查看集群基础信息</p><p><img src=../../../../images/basicinformation.png alt></p><ol><li><strong>基本信息</strong><ol><li><strong>集群名称</strong>：用户自定义，可以通过第3步“集群列表页”中 “ID/名称” 下的笔型图案修改</li><li><strong>集群 ID</strong> ：TKEStack 自动给每个集群一个唯一的 ID 标识符</li><li><strong>状态</strong>：集群运行状态，Running 表示正常运行</li><li><strong>Kubernetes 版本</strong>：当前集群的 Kubernetes 版本</li><li><strong>网卡名称</strong>：当前集群的网卡名称，默认为 eth0</li><li><strong>容器网络</strong>：当前集群的容器网络</li><li><strong>集群凭证</strong>：可以在本地配置 Kubectl 连接 当前 Kubernetes 集群</li><li><strong>超售比</strong>：Kubernetes 对象在申请资源时，如果申请总额大于硬件配置，则无法申请，但是很多时候部分对象并没有占用这么多资源，因此可以设置超售比来扩大资源申请总额，以提高硬件资源利用率</li><li><strong>创建时间</strong>：当前集群的创建时间</li></ol></li><li><strong>组件信息</strong>：这里可以开启或关闭集群的 日志采集 和 监控告警 功能<ol><li><strong>监控告警</strong>：通过在集群安装 prometheus 实现，可以在【监控&告警】下的<a href=https://github.com/ruyingzhe/docs/tree/7f24a45c0f07eac673325093def1526590391c03/docs/user-guide/platform/monitor&alert/alertsetting.md>【告警设置】</a>进一步设置</li><li><strong>日志采集</strong>：通过在集群安装 logagent 实现，可以在【运维中心】下的<a href=https://github.com/ruyingzhe/docs/tree/7f24a45c0f07eac673325093def1526590391c03/docs/user-guide/platform/operation/log.md>【日志采集】</a>进一步设置</li></ol></li></ol></li></ol><h3 id=节点管理>节点管理</h3><p>节点是容器集群组成的基本元素。节点取决于业务，既可以是虚拟机，也可以是物理机。每个节点都包含运行 Pod 所需要的基本组件，包括 Kubelet、Kube-proxy 等。</p><h4 id=添加节点>添加节点</h4><ol><li><p>登录 TKEStack</p></li><li><p>切换至【平台管理】控制台</p></li><li><p>在“集群管理”页面中，点击要操作的集群ID，如下图“global”所示：</p><p><img src=../../../../images/cluster%20%282%29%20%282%29%20%286%29.png alt=Global&#x96C6;&#x7FA4;></p></li><li><p>点击【节点管理】中的【节点】，可查看当前集群的“节点列表”</p><p><img src=../../../../images/nodes.png alt></p></li><li><p>点击蓝色【添加节点】按钮可增加当前集群的 Worker 节点</p><ol><li>目标机器：建议内网地址，要求添加的节点和当前集群的其他机器在同一内网。注意：如果节点密码一样，这里可以通过英文的分号“;”分隔多个 IP 地址实现快速添加多个节点</li><li>SSH端口：默认 22</li><li>主机label：按需添加，给主机设置 Label，可用于指定容器调度</li><li>认证方式：连接目标机器的方式，根据实际情况设置</li><li>用户名：默认 root</li><li>密码：目标机器用户名为 root 的密码</li><li>GPU：按需选择，使用 GPU 机器需提前安装驱动和 runtime</li><li>添加机器：可以通过节点下面的**【添加】**蓝色字体增加不同密码的节点（按需添加）</li></ol></li></ol><h4 id=节点监控>节点监控</h4><p>点击上图中的蓝色【监控】按钮可监控节点，可以从Pod、CPU、内存、硬盘、网络等维度监控。</p><blockquote><p>前提：在集群的 <a href=cluster-mgmt.md#%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF>基本信息</a> 页里开启了 监控告警</p></blockquote><h4 id=节点操作>节点操作</h4><p>对节点的可以的操作如下图所示：</p><p><img src=../../../../images/nodecaozuo.png alt></p><ol><li><p><strong>移出</strong>：仅针对 worker 节点，将节点移出集群</p></li><li><p><strong>驱逐</strong>：节点驱逐后，将会把节点内的所有 Pod（不包含 DaemonSet 管理的 Pod）从节点中驱逐到集群内其他节点，并将节点设置为封锁状态</p><blockquote><p>注意：本地存储的 Pod 被驱逐后数据将丢失，请谨慎操作</p></blockquote></li><li><p><strong>编辑标签</strong>：编辑节点标签</p></li><li><p><strong>编辑 Taint</strong>：编辑 Taint 后，新的 pod 不能被调度到该节点，但可以通过编辑 pod 的 toleration 使其可以调度到具有匹配的 taint 节点上</p></li><li><p><strong>封锁</strong>：封锁节点后，将不接受新的Pod调度到该节点，需要手动取消封锁的节点</p></li></ol><h4 id=节点-pod-管理>节点 Pod 管理</h4><p>点击其中一个节点名，例如上图中的【172.19.0.154】，可以看到该节点更多的信息，具体包括：</p><p><img src=../../../../images/nodespod.png alt></p><ol><li><strong>Pod 管理</strong>：可查看当前节点下的 pod<ol><li>销毁重建：销毁该 pod，重新新建该 pod</li><li>远程登录：登录到该 pod 里</li></ol></li><li><strong>事件</strong>：关于该节点上资源的事件，资源事件只在 ETCD 里保存最近1小时内发生的事件，请尽快查阅</li><li><strong>详情</strong>：包括节点主机信息以及 Kubernetes 信息</li><li><strong>YAML</strong>：此处可以查看节点的 YAML 文件，点击【编辑YAML】可以手动修改节点的 YAML 文件</li></ol><h3 id=其他操作>其他操作</h3><p>注意：由于【平台管理】控制台下对集群的大多数操作与【业务管理】控制台完全一致，因此除了集群的【基本信息】和【节点管理】之外，其他栏目（包括 命名空间、负载、服务、配置、存储、日志、事件）请参考【业务管理】控制台下<a href=https://github.com/ruyingzhe/docs/tree/7f24a45c0f07eac673325093def1526590391c03/docs/user-guide/business-control-pannel/application/README.md>【应用管理】</a>的相应部分。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-4084130a4de3422093300679bfcd6e9d>4.2.3 - 业务管理</h1><div class=lead>业务管理</div><h2 id=概念>概念</h2><p><strong>在这里用户可以管理线上业务。</strong></p><h2 id=操作步骤>操作步骤</h2><h3 id=新建业务>新建业务</h3><blockquote><p>注：业务可以实现跨集群资源的使用</p></blockquote><ol><li><p>登录 TKEStack。</p></li><li><p>在【平台管理】控制台的【业务管理】中，单击 【新建业务】。如下图所示：</p><p><img src=../../../../images/createbusiness.png alt=&#x65B0;&#x5EFA;&#x4E1A;&#x52A1;></p></li><li><p>在“新建业务”页面，填写业务信息。如下图所示： <img src=../../../../images/bussinessInfo.png alt=&#x4E1A;&#x52A1;&#x4FE1;&#x606F;></p></li><li><p><strong>业务名称</strong>：不能超过63个字符，这里以<code>my-business</code>为例</p></li><li><p><strong>业务成员</strong>： <a href=access-mgmt/>【访问管理】</a>中【用户管理】中的用户，这里以<code>admin</code>例，即该用户可以访问这个业务。</p></li><li><p><strong>集群</strong>：</p><ul><li>【集群管理】中的集群，这里以<code>gobal</code>集群为例</li><li>【填写资源限制】可以设置当前业务使用该集群的资源上限（可不限制）</li><li>【新增集群】可以添加多个集群，此业务可以使用多个集群的资源（按需添加）</li></ul></li><li><p><strong>上级业务</strong>：支持多级业务管理，按需选择（可不选）</p></li><li><p>单击最下方 【完成】 按钮即可创建业务。</p></li></ol><h3 id=添加业务成员>添加业务成员</h3><ol><li><p>登录 TKEStack。</p></li><li><p>切换至 【平台管理】控制台，点击【业务管理】。</p></li><li><p>在“业务管理”页面中，可以看到已创建的业务列表。鼠标移动到要修改的业务上(无需点击)，成员列会出现修改图标按钮。如下图所示： <img src=../../../../images/%E4%BF%AE%E6%94%B9%E4%B8%9A%E5%8A%A1%E6%88%90%E5%91%98%E5%9B%BE%E6%A0%87.png alt=&#x4FEE;&#x6539;&#x56FE;&#x6807;&#x6309;&#x94AE;></p><blockquote><p>注意：修改业务成员仅限状态为Active的业务，这里可以新建和删除成员。</p></blockquote></li></ol><h3 id=查看业务监控>查看业务监控</h3><ol><li><p>登录 TKEStack。</p></li><li><p>切换至 【管理】控制台，点击【业务管理】。</p></li><li><p>在“业务管理”页面中，可以看到已创建的业务列表。点击监控按钮，如下图所示：</p><p><img src=../../../../images/%E6%9F%A5%E7%9C%8B%E4%B8%9A%E5%8A%A1%E7%9B%91%E6%8E%A7.png alt=&#x76D1;&#x63A7;&#x6309;&#x94AE;></p></li><li><p>在右侧弹出窗口里查看业务监控情况，如下图所示：</p><p><img src=../../../../images/%E4%B8%9A%E5%8A%A1%E7%9B%91%E6%8E%A7%E8%AF%A6%E6%83%85.png alt=&#x4E1A;&#x52A1;&#x76D1;&#x63A7;&#x8BE6;&#x60C5;></p></li></ol><h3 id=删除业务>删除业务</h3><ol><li><p>登录 TKEStack。</p></li><li><p>切换至 【平台管理】控制台，点击【业务管理】。</p></li><li><p>在“业务管理”页面中，可以看到已创建的业务列表。点击删除按钮，如下图所示：</p><p><img src=../../../../images/%E5%88%A0%E9%99%A4%E4%B8%9A%E5%8A%A1.png alt=&#x5220;&#x9664;&#x4E1A;&#x52A1;></p><blockquote><p>注意：删除业务成员仅限状态为Active的业务</p></blockquote></li></ol><h3 id=对业务的操作>对业务的操作</h3><ol><li><p>登录 TKEStack。</p></li><li><p>在【平台管理】控制台的【业务管理】中，单击【业务id】。如下图所示： <img src=../../../../images/businessid.png alt=&#x4E1A;&#x52A1;id></p><p>a. <strong>业务信息：</strong> 在这里可以对业务名称、关联的集群、关联集群的资源进行限制等操作。</p><p><img src=../../../../images/%E4%B8%9A%E5%8A%A1%E4%BF%A1%E6%81%AF1.png alt=&#x4E1A;&#x52A1;&#x4FE1;&#x606F;></p><p>b. <strong>成员列表：</strong> 在这里可以对业务名称、关联的集群、关联集群的资源进行限制等操作。</p><p><img src=../../../../images/%E6%88%90%E5%91%98%E5%88%97%E8%A1%A8%E8%AE%BE%E7%BD%AE.png alt=&#x4E1A;&#x52A1;&#x4FE1;&#x606F;></p><p>c. <strong>子业务：</strong> 在这里可以<strong>新建本业务的子业务</strong>或<strong>通过导入子业务将已有业务变成本业务的子业务</strong></p><p><img src=../../../../images/%E5%AD%90%E4%B8%9A%E5%8A%A1.png alt=&#x4E1A;&#x52A1;&#x4FE1;&#x606F;></p><p>d. <strong>业务下Namespace列表：</strong> 这里可以管理业务下的Namespace</p><p><img src=../../../../images/%E4%B8%9A%E5%8A%A1Namespace%E5%88%97%E8%A1%A8.png alt=&#x4E1A;&#x52A1;&#x4FE1;&#x606F;></p><p>​ 单击【新建Namespace】。在“新建Namespace”页面中，填写相关信息。如下图所示：</p><p><img src=../../../../images/my-ns.png alt=&#x65B0;&#x5EFA;&#x7A7A;&#x95F4;&#x5217;&#x8868;></p><p>​ <strong>名称</strong>：不能超过63个字符，这里以<code>new-ns</code>为例</p><p>​ <strong>集群</strong>：<code>my-business</code>业务中的集群，这里以<code>global</code>集群为例</p><p>​ <em>资源限制*</em>：这里可以限制当前命名空间下各种资源的使用量，可以不设置。</p></li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-2eac969bd1933c41613cedbe9af4c914>4.2.4 - 扩展组件</h1><div class=lead>扩展组件</div><h1 id=扩展组件>扩展组件</h1><h2 id=概念>概念</h2><p><strong>这里用户可以管理集群扩展组件。</strong></p><h2 id=操作步骤>操作步骤</h2><h3 id=创建组件>创建组件</h3><ul><li>登录 TKEStack。</li><li>切换至 【平台管理】控制台，选择【扩展组件】页面。</li><li>选择需要安装组件的集群，点击【新建】按钮。如下图所示：</li></ul><p><img src=../../../../../images/%E6%96%B0%E5%BB%BA%E6%89%A9%E5%B1%95%E7%BB%84%E4%BB%B6.png alt=&#x65B0;&#x5EFA;&#x7EC4;&#x4EF6;></p><blockquote><p>注意：此页面右边的【删除】按钮可以删除安装了的组件</p></blockquote><ul><li>在弹出的扩展组件列表里，选择要安装的组件。如下图所示：</li></ul><p><img src=../../../../../images/%E9%80%89%E6%8B%A9%E6%89%A9%E5%B1%95%E7%BB%84%E4%BB%B6.png alt=&#x9009;&#x62E9;&#x6269;&#x5C55;&#x7EC4;&#x4EF6;></p><blockquote><p>注意：如果选择的是PersistentEvent，需要在下方输入地址和索引。</p></blockquote><ul><li>单击【完成】。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f8882211bf86e03e9ad6a7593f6389f4>4.2.4.1 - TApp 介绍</h1><div class=lead>TApp 介绍</div><h2 id=tapp-介绍>TApp 介绍</h2><p>Kubernetes 现有应用类型（如：Deployment、StatefulSet等）无法满足很多非微服务应用的需求。比如：操作（升级、停止等）应用中的指定 Pod；应用支持多版本的 Pod。如果要将这些应用改造为适合于这些 Workload 的应用，需要花费很大精力，这将使大多数用户望而却步。</p><p>为解决上述复杂应用管理场景，TKEStack 基于 Kubernetes <a href=https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/>CRD</a> 开发了一种新的应用类型 <a href=https://github.com/tkestack/tapp><strong>TApp</strong></a>，它是一种通用类型的 Workload，同时支持 service 和 batch 类型作业，满足绝大部分应用场景，它能让用户更好的将应用迁移到 Kubernetes 集群。</p><h2 id=tapp-架构>TApp 架构</h2><p>TAPP 其结构定义见 <a href=https://github.com/tkestack/tapp/blob/master/pkg/apis/tappcontroller/v1/types.go#L41>TAPP struct</a>。TApp Controller 是 TApp 对应的Controller/<a href=https://coreos.com/operators/>operator</a>，它通过 kube-apiserver 监听 TApp、Pod 相关的事件，根据 TApp 的 spec 和 status 进行相应的操作：创建、删除pod等。</p><p><img src=../../../../../images/image%20%28105%29.png alt></p><h3 id=tapp-使用场景>TApp 使用场景</h3><p>Kubernetes 凭借其强大的声明式 API、丰富的特性和可扩展性，逐渐成为容器编排领域的霸主。越来越多的用户希望使用 Kubernetes，将现有的应用迁移到 Kubernetes 集群，但 Kubernetes 现有 Workload（如：<code>Deployment</code>、<code>StatefulSet</code>等）无法满足很多非微服务应用的需求，比如：操作（升级、停止等）应用中的指定 Pod、应用支持多版本的 Pod。如果要将这些应用改造为适合于这些 Workload的应用，需要花费很大精力，这将使大多数用户望而却步。</p><p>腾讯有着多年的容器编排经验，基于 Kuberentes CRD（Custom Resource Definition，使用声明式API方式，无侵入性，使用简单）开发了一种新的 Workload 类型 TApp，它是一种通用类型的 Workload，同时支持 service 和 batch 类型作业，满足绝大部分应用场景，它能让用户更好的将应用迁移到 Kubernetes 集群。如果用 Kubernetes 的 Workload 类比，TAPP ≈ Deployment + StatefulSet + Job ，它包含了 Deployment、StatefulSet、Job 的绝大部分功能，同时也有自己的特性，并且和原生 Kubernetes 相同的使用方式完全一致。经过这几年用户反馈， TApp 也得到了逐渐的完善。</p><h3 id=tapp-特点>TApp 特点</h3><ol><li><strong>同时支持 service 和 batch 类型作业</strong>。通过 RestartPolicy 来对这两种作业进行区分。RestartPolicy值有三种：RestartAlways、Never、OnFailure<ol><li><strong>RestartAlways</strong>：表示 Pod 会一直运行，如果结束了也会被重新拉起（适合 service 类型作业）</li><li><strong>Never</strong>：表示 Pod 结束后就不会被拉起了（适合 batch 类型作业）</li><li><strong>OnFailure</strong>：表示 Pod 结束后，如果 exit code 非0，将会被拉起，否则不会（适合 batch 类型作业）</li></ol></li><li><strong>固定ID</strong>：每个实例（Pod）都有固定的 ID(0, 1, 2 … N-1，其中N为实例个数)，它们的名字由 <strong>TApp 名字+ID</strong> 组成，因此名字也是唯一的。 有了固定的ID和名字后，我们便可以实现如下能力：<ol><li>将实例用到的各种资源（将实例用到的存储资源(如：云硬盘)，或者是IP）和实例一一对应起来，这样即使实例发生迁移，实例对应的各种资源也不会变</li><li>通过固定 ID，我们可以为实例分配固定的 IP（float ip）。</li><li>唯一的实例名字还可用来跟踪实例完整的生命周期，对于同一个实例，可以由于机器故障发生了迁移、重启等操作，虽然不是一个 Pod 了，但是我们用实例 ID 串联起来，就获得了实例真正的生命周期的跟踪，对于判断业务和系统是否正常服务具有特别重要的意义</li></ol></li><li><strong>操作指定实例</strong>：有了固定的 ID，我们就能操作指定实例。我们遵循了 Kubernetes 声明式的 API，在 spec 中 statuses 记录实例的目标状态， instances 记录实例要使用的 template，用于停止、启动、升级指定实例。</li><li><strong>支持多版本实例</strong>：在 TApp spec 中，不同的实例可以指定不同的配置（image、resource 等）、不同的启动命令等，这样一个应用可以存在多个版本实例。</li><li><strong>原地更新(in place update)</strong>：Kubernetes 的更新策略是删除旧 Pod，新建一个 Pod，然后调度等一系列流程，才能运行起来，而且 Pod原先的绑定的资源（本地磁盘、IP 等）都会变化。TApp 对此进行了优化：如果只修改了 container 的 image，TApp 将会对该 Pod 进行本地更新，原地重启受影响的容器，本地磁盘不变，IP 不变，最大限度地降低更新带来的影响，这能极大地减少更新带来的性能损失以及服务不可用。</li><li><strong>云硬盘</strong>：云硬盘的底层由分布式存储 Ceph 支持，能很好地支持有状态的作业。在实例发生跨机迁移时，云硬盘能跟随实例一起迁移。TApp 提供了多种云硬盘类型供选择。</li><li><strong>多种升级发布方式</strong>：TApp除了支持常规的蓝绿布署、滚动发布、金丝雀部署等升级发布方式，还有其特有的升级发布方式：用户可以指定升级任意的实例。</li><li><strong>自动扩缩容</strong>：根据 CPU/MEM/用户自定义指标对 TAPP 进行自动扩缩容。 除了自动扩缩容，我们还开发了周期性扩缩容 <a href=https://github.com/tkestack/tke/blob/master/hack/addon/readme/CronHPA.md>CronHPA</a> 支持对 TApp 等(包括 Kubernetes 原生的 Deployment 和 StatefulSet)进行周期性扩缩容，支持 CronTab 语法格式，满足对资源使用有周期性需求的业务。</li><li><strong>Gang scheduling</strong>：有些应用必须要等到获取到资源能运行的实例达到一定数量后才开始运行，TApp 提供的 <a href=https://en.wikipedia.org/wiki/Gang_scheduling>Gang scheduling</a> 正是处理这种情况的。</li></ol><p><img src=../../../../../images/image%20%2871%29.png alt></p><h3 id=部署在集群内-kubernetes-对象>部署在集群内 kubernetes 对象</h3><p>在集群内部署 TApp Add-on , 将在集群内部署以下 kubernetes 对象</p><table><thead><tr><th style=text-align:left>kubernetes 对象名称</th><th style=text-align:left>类型</th><th style=text-align:left>默认占用资源</th><th style=text-align:left>所属Namespaces</th></tr></thead><tbody><tr><td style=text-align:left>tapp-controller</td><td style=text-align:left>Deployment</td><td style=text-align:left>每节点1核CPU, 512MB内存</td><td style=text-align:left>kube-system</td></tr><tr><td style=text-align:left>tapps.apps.tkestack.io</td><td style=text-align:left>CustomResourceDefinition</td><td style=text-align:left>/</td><td style=text-align:left>/</td></tr><tr><td style=text-align:left>tapp-controller</td><td style=text-align:left>ServiceAccount</td><td style=text-align:left>/</td><td style=text-align:left>kube-system</td></tr><tr><td style=text-align:left>tapp-controller</td><td style=text-align:left>Service</td><td style=text-align:left>/</td><td style=text-align:left>kube-system</td></tr><tr><td style=text-align:left>tapp-controller</td><td style=text-align:left>ClusterRoleBinding（ClusterRole/cluster-admin）</td><td style=text-align:left>/</td><td style=text-align:left>/</td></tr></tbody></table><h2 id=tapp-使用方法>TApp 使用方法</h2><h3 id=安装-tapp-组件>安装 TApp 组件</h3><ul><li>登录 TKEStack</li><li>切换至 平台管理 控制台，选择扩展组件页面</li><li>选择需要安装组件的集群，点击【新建】按钮。如下图所示：</li></ul><p><img src=../../../../../images/image%20%2849%29.png alt></p><ul><li>在弹出的扩展组件列表里，滑动列表窗口找到tapp组件。如下图所示：</li></ul><p><img src=../../../../../images/image%20%2820%29.png alt></p><ul><li><p>单击【完成】</p><p>安装完成后会在刚刚安装了 TApp 扩展组件的集群里 【工作负载】下面出现【TApp】，如下图所示：</p></li></ul><p><img src=../../../../../images/image%20%2890%29.png alt></p><h3 id=使用-tapp-组件>使用 TApp 组件</h3><p>在 TKEStack 控制台上使用 TApp 使用请参考：<a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/products/business-control-pannel/application/workload/tapp.md>TApp Workload</a></p><p>对 TApp 架构和命令行使用请参考：<a href=https://github.com/tkestack/tapp/blob/master/doc/tutorial.md>TApp Repository</a></p><h2 id=参考>参考</h2><h3 id=手动部署-tapp>手动部署 TApp</h3><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>git clone https://github.com/tkestack/tapp.git
cd tapp
make build
bin/tapp-controller --kubeconfig=$HOME/.kube/config
</code></pre></div><h3 id=原地升级>原地升级</h3><p>修改 <code>spec.templatePool.{templateName}.spec.containers.image</code> 的值实现原地升级。</p><p>挂在存储卷后的 Pod 依旧在 image 升级的时候没有任何影响，同时 PVC 也没有改变，唯一改变的只有镜像本身。</p><h3 id=部分关键字解释>部分关键字解释</h3><table><thead><tr><th style=text-align:left>关键字</th><th style=text-align:left>作用</th></tr></thead><tbody><tr><td style=text-align:left>spec.templatePool</td><td style=text-align:left>模版池</td></tr><tr><td style=text-align:left>spec.templates</td><td style=text-align:left>以键值对（Pod 序号：模板池中的模板名）的形式具体声明每一个 Pod 的状态</td></tr><tr><td style=text-align:left>spec.template 等价于 spec.DefaultTemplateName</td><td style=text-align:left>默认模板（在spec.templates中没有定义的 Pod 序号将使用该模板）</td></tr><tr><td style=text-align:left>updateStrategy.inPlaceUpdateStrategy</td><td style=text-align:left>原地升级策略</td></tr><tr><td style=text-align:left>spec.updateStrategy</td><td style=text-align:left>保留旧版本 Pod 的数量，默认为 0，类似于灰度发布</td></tr><tr><td style=text-align:left>spec.updateStrategy.template</td><td style=text-align:left>要设置 maxUnavailable 值的 template 名</td></tr><tr><td style=text-align:left>spec.updateStrategy.maxUnavailable</td><td style=text-align:left>最大的不可用 Pod 数量（默认为1，可设置成一个自然数，或者一个百分比，例如 50%）</td></tr><tr><td style=text-align:left>spec.statuses</td><td style=text-align:left>明确 Pod 的状态，TApp 会实现该状态</td></tr></tbody></table><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>apiVersion: apps.tkestack.io/v1
kind: TApp
metadata:
  name: example-tapp
spec:
  replicas: 3
  # 默认模板
  template:
    metadata:
      labels:
        app: example-tapp
    spec:
      containers:
      - name: nginx
        image: nginx:latest
  # 模板池
  templatePool:
  	# 模板池中的模板
    &#34;test2&#34;:
      metadata:
        labels:
          app: example-tapp
      spec:
        containers:
        - name: nginx
          image: nginx:1.7.9
  # 要使用模板池中模板的 Pod
  templates:
    # Pod 序号：模板池中的模板
    &#34;1&#34;: &#34;test2&#34;
    &#34;2&#34;: &#34;test2&#34;
  # 更新策略
  updateStrategy:
    # 更新指定模板。test2该模板有过修改，或者是在模板池里新增的，都可以通过 updateStrategy 设置模板来进行滚动更新
    template: test2
    # 使用该模板的 Pod 在更新时最大不可用的数量
    maxUnavailable: 1
  # 明确 Pod 的状态，TApp 会实现该状态
  statuses:
    # 编号为1的 Pod 将被 Kill
    &#34;1&#34;: &#34;Killed&#34;
</code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-36486ddbc5cae072d21407bccf243040>4.2.4.2 - CronHPA 介绍</h1><div class=lead>CronHPA 介绍</div><h2 id=cronhpa-介绍>CronHPA 介绍</h2><p>Cron Horizontal Pod Autoscaler(<a href=https://github.com/tkestack/cron-hpa>CronHPA</a>) 可让用户利用 <a href=https://en.wikipedia.org/wiki/Cron>CronTab</a> 实现对负载（Deployment、StatefulSet、<a href=https://github.com/tkestack/tke/blob/master/hack/addon/readme/TappController.md>TApp</a> 这些支持扩缩容的资源对象）<strong>定期自动扩缩容</strong>。</p><p><a href=https://en.wikipedia.org/wiki/Cron>CronTab</a> 格式说明如下：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text># 文件格式说明
#  ——分钟（0 - 59）
# |  ——小时（0 - 23）
# | |  ——日（1 - 31）
# | | |  ——月（1 - 12）
# | | | |  ——星期（0 - 6）
# | | | | |
# * * * * *
</code></pre></div><p>CronHPA 定义了一个新的 CRD，cron-hpa-controller 是该 CRD 对应的 Controller/operator，它解析 CRD 中的配置，根据系统时间信息对相应的工作负载进行扩缩容操作。</p><h3 id=cronhpa-使用场景>CronHPA 使用场景</h3><p>以游戏服务为例，从星期五晚上到星期日晚上，游戏玩家数量暴增。如果可以将游戏服务器在星期五晚上扩大规模，并在星期日晚上缩放为原始规模，则可以为玩家提供更好的体验。这就是游戏服务器管理员每周要做的事情。</p><p>其他一些服务也会存在类似的情况，这些产品使用情况会定期出现高峰和低谷。CronHPA 可以自动化实现提前扩缩 Pod，为用户提供更好的体验。</p><h3 id=部署在集群内-kubernetes-对象>部署在集群内 kubernetes 对象</h3><p>在集群内部署 CronHPA Add-on , 将在集群内部署以下 kubernetes 对象：</p><table><thead><tr><th style=text-align:left>kubernetes 对象名称</th><th style=text-align:left>类型</th><th style=text-align:left>默认占用资源</th><th style=text-align:left>所属 Namespaces</th></tr></thead><tbody><tr><td style=text-align:left>cron-hpa-controller</td><td style=text-align:left>Deployment</td><td style=text-align:left>每节点1核 CPU, 512MB内存</td><td style=text-align:left>kube-system</td></tr><tr><td style=text-align:left>cronhpas.extensions.tkestack.io</td><td style=text-align:left>CustomResourceDefinition</td><td style=text-align:left>/</td><td style=text-align:left>/</td></tr><tr><td style=text-align:left>cron-hpa-controller</td><td style=text-align:left>ClusterRoleBinding（ClusterRole/cluster-admin）</td><td style=text-align:left>/</td><td style=text-align:left>/</td></tr><tr><td style=text-align:left>cron-hpa-controller</td><td style=text-align:left>ServiceAccount</td><td style=text-align:left>/</td><td style=text-align:left>kube-system</td></tr></tbody></table><h2 id=cronhpa-使用方法>CronHPA 使用方法</h2><h3 id=安装-cronhpa>安装 CronHPA</h3><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【扩展组件】页面</li><li>选择需要安装组件的集群，点击【新建】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%28128%29.png alt></p><ul><li>在弹出的扩展组件列表里，滑动列表窗口找到 CronHPA 组件</li><li>单击【完成】</li></ul><h3 id=在控制台上使用-cronhpa>在控制台上使用 CronHPA</h3><p>TKEStack 已经支持在页面多处位置为负载配置 CronHPA</p><ul><li>新建负载页（负载包括Deployment、StatefulSet、TApp）这里新建负载时将会同时新建与负载同名的 CronHPA 对象：</li></ul><p><img src=../../../../../images/image%20%2897%29.png alt></p><p>每条触发策略由两条字段组成</p><ol><li><strong>Crontab</strong> ：例如 &ldquo;0 23 * * 5"表示每周五23:00，详见<a href=https://en.wikipedia.org/wiki/Cron>crontab</a></li><li><strong>目标实例数</strong> ：设置实例数量</li></ol><ul><li>自动伸缩的 CronHPA 列表页。此处可以查看/修改/新建 CronHPA：</li></ul><p><img src=../../../../../images/image%20%2815%29.png alt></p><h3 id=通过-yaml-使用-cronhpa>通过 YAML 使用 CronHPA</h3><h4 id=创建-cronhpa-对象>创建 CronHPA 对象</h4><p>示例1：指定 Deployment 每周五20点扩容到60个实例，周日23点缩容到30个实例</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>apiVersion: extensions.tkestack.io/v1
kind: CronHPA
metadata:
  name: example-cron-hpa	# CronHPA 名
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment	# CronHPA 操作的负载类型
    name: demo-deployment	# CronHPA 操作的负载类型名
  crons:
    - schedule: &#34;0 20 * * 5&#34;	# Crontab 语法格式
      targetReplicas: 60			# 负载副本（Pod）的目标数量
    - schedule: &#34;0 23 * * 7&#34;
      targetReplicas: 30
</code></pre></div><p>示例2：指定 Deployment 每天8点到9点，19点到21点扩容到60，其他时间点恢复到10</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>apiVersion: extensions.tkestack.io/v1
kind: CronHPA
metadata:
  name: web-servers-cronhpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: web-servers
  crons:
    - schedule: &#34;0 8 * * *&#34;
      targetReplicas: 60
    - schedule: &#34;0 9 * * *&#34;
      targetReplicas: 10
    - schedule: &#34;0 19 * * *&#34;
      targetReplicas: 60
    - schedule: &#34;0 21 * * *&#34;
      targetReplicas: 10
</code></pre></div><h4 id=查看已有-cronhpa>查看已有 CronHPA</h4><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text># kubectl get cronhpa
NAME               AGE
example-cron-hpa   104s

# kubectl get cronhpa example-cron-hpa -o yaml
apiVersion: extensions.tkestack.io/v1
kind: CronHPA
...
spec:
  crons:
  - schedule: 0 20 * * 5
    targetReplicas: 60
  - schedule: 0 23 * * 7
    targetReplicas: 30
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: demo-deployment
</code></pre></div><h4 id=删除已有-cronhpa>删除已有 CronHPA</h4><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl delete cronhpa example-cron-hpa
</code></pre></div><p>CronHPA 项目请参考 <a href=https://github.com/tkestack/cron-hpa>CronHPA Repository</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-10c69052f011daaf2098d301331d233d>4.2.4.3 - 监控组件</h1><div class=lead>监控组件</div><h2 id=prometheus>Prometheus</h2><p>良好的监控环境为 TKEStack 高可靠性、高可用性和高性能提供重要保证。您可以方便为不同资源收集不同维度的监控数据，能方便掌握资源的使用状况，轻松定位故障。</p><p>TKEStack 使用开源的 Prometheus 作为监控组件，免去您部署和配置 Prometheus 的复杂操作，TKEStack 提供高可用性和可扩展性的细粒度监控系统，实时监控 CPU，GPU，内存，显存，网络带宽，磁盘 IO 等多种指标并自动绘制趋势曲线，帮助运维人员全维度的掌握平台运行状态。</p><p>TKEStack 使用 Prometheus 的架构和原理可以参考 <a href=https://github.com/tkestack/tke/blob/master/hack/addon/readme/Prometheus.md>Prometheus 组件</a></p><blockquote><p>指标具体含义可参考：<a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/FAQ/Platform/alert&monitor-metrics.md>监控 & 告警指标列表</a></p></blockquote><p><img src=../../../../../images/image%20%2873%29.png alt></p><p>TKEStack 通过 Prometheus 组件监控集群状态，Prometheus 组件通过 addon 扩展组件自动完成安装和配置，使用 InfluxDB，ElasticSearch 等存储监控数据。监控数据和指标融入到平台界面中以风格统一图表的风格展示，支持以不同时间，粒度等条件，查询集群，节点，业务，Workload 以及容器等多个层级的监控数据，全维度的掌握平台运行状态。</p><p>同时针对在可用性和可扩展性方面，支持使用 Thanos 架构提供可靠的细粒度监控和警报服务，构建具有高可用性和可扩展性的细粒度监控能力。</p><h3 id=安装-prometheus>安装 Prometheus</h3><p>Prometheus 为 TKEStack 扩展组件，需要在集群的 <a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/products/platform/cluster.md#%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF>【基本信息】</a> 页下面开启 “监控告警”。</p><p><img src=../../../../../images/image%20%2836%29.png alt></p><h3 id=集群监控>集群监控</h3><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【集群管理】</li><li>点击【监控】图标，如下图所示：</li></ul><p><img src=../../../../../images/image%20%28141%29.png alt></p><ul><li>监控数据展示</li><li>通过下图中的1可以选择监控数据时间段</li><li>通过下图中的2可以选择统计粒度，以下图中“APIServer时延”为例，下图中的每个数据表示前1分钟“APIServer时延”平均数</li></ul><p><img src=../../../../../images/image%20%2824%29.png alt></p><ul><li>上下滑动曲线图可以获得更多监控指标</li><li>点击曲线图，会弹出具体时间点的具体监控数据</li></ul><p><img src=../../../../../images/image%20%2863%29.png alt></p><blockquote><p>指标具体含义可参考：<a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/FAQ/Platform/alert&monitor-metrics.md>监控 & 告警指标列表</a></p></blockquote><h3 id=节点监控>节点监控</h3><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【集群管理】</li><li>点击【集群 ID】 -> 【节点管理】->【节点】->【监控】图标，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2839%29.png alt></p><ul><li><p>具体查看方式和<a href>集群监控</a>完全一致</p><blockquote><p>指标具体含义可参考：<a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/FAQ/Platform/alert&monitor-metrics.md>监控 & 告警指标列表</a></p></blockquote></li><li><p>此处还可以查看节点下的 Pod 监控</p><ol><li>如下图所示，对比维度可选择 节点 或 Pod</li><li>选择 Pod ，需要在其右侧选择 Pod 所属节点</li></ol></li></ul><p><img src=../../../../../images/image%20%28139%29.png alt></p><h4 id=节点下的-pod--container-监控>节点下的 Pod & Container 监控</h4><p>有两种方式</p><ul><li><a href>节点监控</a> 下选择 Pod 进行监控</li><li>在节点列表里，点击节点名，进入节点的 Pod 管理页，如下图所示，点击上方的【监控】按钮，实现对节点下的 Pod 监控</li></ul><p><img src=../../../../../images/image%20%286%29.png alt></p><blockquote><p>注意：此处还可以查看节点下的 Container 监控</p><ol><li>如下图所示，对比维度可选择 Pod 或 Container</li><li>选择 Container ，需要在其右侧选择 Container 所属 Pod</li></ol></blockquote><p><img src=../../../../../images/image%20%2850%29.png alt></p><p>指标具体含义可参考：<a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/FAQ/Platform/alert&monitor-metrics.md>监控 & 告警指标列表</a></p><h3 id=负载监控>负载监控</h3><ul><li><p>登录 TKEStack</p></li><li><p>切换至【平台管理】控制台，选择【集群管理】</p></li><li><p>点击【集群 ID】 -> 【工作负载】->【选择一种负载，例如 Deployment】->【监控】图标，如下图所示：</p></li><li><p>具体查看方式和<a href>集群监控</a>完全一致</p><blockquote><p>指标具体含义可参考：<a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/FAQ/Platform/alert&monitor-metrics.md>监控 & 告警指标列表</a></p></blockquote></li></ul><h4 id=负载下-pod--container-监控>负载下 Pod & Container 监控</h4><ol><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【集群管理】</li><li>点击【集群 ID】 -> 【工作负载】->【选择一种负载】，例如 Deployment】->【点击一个负载名】->【监控】图标，如下图所示：</li></ol><p><img src=../../../../../images/image%20%2872%29.png alt></p><blockquote><p>注意：此处还可以查看负载下的 Container 监控</p><ol><li>如下图所示，对比维度可选择 Pod 或 Container</li><li>选择 Container ，需要在其右侧选择 Container 所属 Pod 指标具体含义可参考：<a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/FAQ/Platform/alert&monitor-metrics.md>监控 & 告警指标列表</a></li></ol></blockquote><p><img src=../../../../../images/image%20%28132%29.png alt></p><p>TKEStack 使用 Prometheus 的架构和原理可以参考 <a href=https://github.com/tkestack/tke/blob/master/hack/addon/readme/Prometheus.md>Prometheus 组件</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-6dcd138c670444e4d6bd8c3e521b6e9d>4.2.4.4 - LogAgent 介绍</h1><div class=lead>LogAgent 介绍</div><h2 id=日志采集>日志采集</h2><h3 id=logagent-介绍>LogAgent 介绍</h3><p>TKESTack 通过 logagent 提供的集群内日志采集功能，支持将集群内服务或集群节点特定路径文件的日志发送至 Kafka、Elasticsearch 等消费端，支持采集容器标准输出日志，容器内文件日志以及主机内文件日志。更提供事件持久化、审计等功能，实时记录集群事件及操作日志记录，帮助运维人员存储和分析集群内部资源生命周期、资源调度、异常告警等情况。</p><p><img src=../../../../../images/image%20%2823%29.png alt></p><blockquote><p>TKEStack 老版本日志使用 LogCollector 扩展组件。LogAgent 用于替换 LogCollector，新版本统一用 LogAgent 完成日志采集功能。</p></blockquote><p>日志收集功能需要为每个集群手动开启。日志收集功能开启后，日志收集组件 logagent 会在集群内以 Daemonset 的形式运行。用户可以通过日志收集规则配置日志的采集源和消费端，日志收集 Agent 会从用户配置的采集源进行日志收集，并将日志内容发送至用户指定的消费端。需要注意的是，<strong>使用日志收集功能需要您确认 Kubernetes 集群内节点能够访问日志消费端。</strong></p><ul><li><strong>采集容器标准输出日志</strong> ：采集集群内指定<strong>容器的 Stderr 和 Stdout 日志。</strong>，采集到的日志信息将会以 JSON 格式输出到用户指定的消费端，并会自动附加相关的 Kubernetes metadata， 包括容器所属 Pod 的 label 和 annotation 等信息。</li><li><strong>采集容器内文件日志</strong> ：采集集群内指定<strong>容器内文件路径的日志</strong>，用户可以根据自己的需求，灵活的配置所需的容器和路径，采集到的日志信息将会以 JSON 格式输出到用户指定的消费端， 并会附加相关的 Kubernetes metadata，包括容器所属 Pod 的 label 和 annotation 等信息。</li><li><strong>采集主机内文件日志</strong> ：采集集群内所有节点的指定<strong>主机文件路径的日志</strong>，logagent 会采集集群内所有节点上满足指定路径规则的文件日志，以 JSON 格式输出到用户指定的输出端， 并会附加用户指定的 metadata，包括日志来源文件的路径和用户自定义的 metadata。</li></ul><h4 id=部署在集群内-kubernetes-对象>部署在集群内 kubernetes 对象</h4><p>在集群内部署 logagent Add-on , 将在集群内部署以下 kubernetes 对象</p><table><thead><tr><th style=text-align:left>kubernetes 对象名称</th><th style=text-align:left>类型</th><th style=text-align:left>默认占用资源</th><th style=text-align:left>所属Namespaces</th></tr></thead><tbody><tr><td style=text-align:left>logagent</td><td style=text-align:left>DaemonSet</td><td style=text-align:left>每节点0.3核 CPU, 250MB 内存</td><td style=text-align:left>kube-system</td></tr><tr><td style=text-align:left>logagent</td><td style=text-align:left>ServiceAccount</td><td style=text-align:left></td><td style=text-align:left>kube-system</td></tr></tbody></table><h3 id=使用日志采集服务>使用日志采集服务</h3><blockquote><p>注意：日志采集对接外部 Kafka 或 Elasticsearch，该功能需要额外开启，位置在集群 <a href=https://github.com/tkestack/tke/blob/master/hack/platform/cluster.md#%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF>基本信息</a> 下面，点击开启“日志采集”服务。</p></blockquote><p><img src=../../../../../images/image%20%2828%29.png alt></p><h4 id=业务管理侧>业务管理侧</h4><ul><li>登录 TKEStack</li><li>切换至【业务管理】控制台，选择 【运维中心】->【日志采集】</li><li>选择相应【业务】和【命名空间】，单击【新建】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%287%29.png alt></p><ul><li>在“新建日志采集”页面填写日志采集信息，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2847%29.png alt></p><ul><li><strong>收集规则名称：</strong> 输入规则名，1～63字符，只能包含小写字母、数字及分隔符("-")，且必须以小写字母开头，数字或小写字母结尾</li><li><strong>业务：</strong> 选择所属业务（业务管理侧才会出现）</li><li><strong>集群：</strong> 选择所属集群（平台管理侧才会出现）</li><li><strong>类型：</strong> 选择采集类型<ul><li><strong>容器标准输出：</strong> 容器 Stderr 和 Stdout 日志信息采集<ul><li><strong>日志源：</strong> 可以选择所有容器或者某个 Namespace 下的所有容器/工作负载<ul><li><strong>所有容器：</strong> 所有容器</li><li><strong>指定容器：</strong> 某个 Namespace 下的所有容器或者工作负载</li></ul></li></ul></li><li><strong>容器文件路径：</strong> 容器内文件内容采集<ul><li><p><strong>日志源：</strong> 可以采集具体容器内的某个文件路径下的文件内容</p><ul><li><strong>工作负载选项：</strong> 选择某个 Namespace 下的某种工作负载类型下的某个工作负载</li><li><strong>配置采集路径：</strong> 选择某个容器下的某个文件路径</li></ul><blockquote><ul><li>文件路径若输入<code>stdout</code>，则转为容器标准输出模式</li><li>可配置多个路径。路径必须以<code>/</code>开头和结尾，文件名支持通配符（*）。文件路径和文件名最长支持63个字符</li><li>请保证容器的日志文件保存在数据卷，否则收集规则无法生效，详见<a href>指定容器运行后的日志目录</a></li></ul></blockquote></li></ul></li><li><strong>节点文件路径：</strong> 收集节点上某个路径下的文件内容，不会重复采集，因为采集器会记住之前采集过的日志文件的位点，只采集增量部分<ul><li><strong>日志源：</strong> 可以采集具体节点内的某个文件路径下的文件内容<ul><li><strong>收集路径：</strong> 节点上日志收集路径。路径必须以<code>/</code>开头和结尾，文件名支持通配符（*）。文件路径和文件名最长支持63个字符</li><li><strong>metadata：</strong> key：value 格式，收集的日志会带上 metadata 信息上报给消费端</li></ul></li></ul></li></ul></li><li><strong>消费端：</strong> 选择日志消费端<ul><li><strong>Kafka：</strong><ul><li><strong>访问地址：</strong> Kafka IP 和端口</li><li><strong>主题（Topic）：</strong> Kafka Topic 名</li></ul></li><li><strong>Elasticsearch：</strong><ul><li><p><strong>Elasticsearch 地址：</strong> ES 地址，如：<a href=http://190.0.0.1:200/>http://190.0.0.1:200</a></p><blockquote><p>注意：当前只支持未开启用户登录认证的 ES 集群</p></blockquote></li><li><p><strong>索引：</strong> ES索引，最长60个字符，只能包含小写字母、数字及分隔符("-"、"_"、"+")，且必须以小写字母开头</p></li></ul></li></ul></li><li>单击【完成】按钮</li></ul><h4 id=平台管理侧>平台管理侧</h4><p>在平台管理侧也支持日志采集规则的创建，创建方式和业务管理处相同。详情可点击平台侧的<a href=https://github.com/tkestack/tke/blob/master/hack/platform/operation/log.md>日志采集</a>。</p><h4 id=指定容器运行后的日志目录>指定容器运行后的日志目录</h4><p>LogAgent 除了支持日志规则的创建，也支持指定容器运行后的日志目录，可实现日志文件展示和下载。</p><blockquote><p>前提：需要在创建负载时挂载数据卷，并指定日志目录</p></blockquote><p><img src=../../../../../images/image%20%28134%29.png alt></p><p>创建负载以后，在容器内的<code>/data/logdir</code>目录下的所有文件可以展示并下载，例如我们在容器的<code>/data/logdir</code>下新建一个名为<code>a.log</code>的文件，如果有内容的话，也可以在这里展示与下载：</p><p><img src=../../../../../images/image%20%2832%29.png alt></p></div><div class=td-content style=page-break-before:always><h1 id=pg-901ced327a8b1d8464a48213006e87cc>4.2.4.5 - GPUManager 介绍</h1><div class=lead>GPUManager 介绍</div><h2 id=gpumanager-介绍>GPUManager 介绍</h2><p><a href=https://github.com/tkestack/gpu-manager>GPUManager</a> 提供一个 All-in-One 的 GPU 管理器, 基于 Kubernets Device Plugin 插件系统实现，该管理器提供了分配并共享 GPU，GPU 指标查询，容器运行前的 GPU 相关设备准备等功能，支持用户在 Kubernetes 集群中使用 GPU 设备。</p><p>GPU-Manager 包含如下功能:</p><ul><li><strong>拓扑分配</strong>：提供基于 GPU 拓扑分配功能，当用户分配超过1张 GPU 卡的应用，可以选择拓扑连接最快的方式分配GPU设备</li><li><strong>GPU 共享</strong>：允许用户提交小于1张卡资源的的任务，并提供 QoS 保证</li><li><a href><strong>应用 GPU 指标的查询</strong></a>：用户可以访问主机的端口(默认为5678)的<code>/metrics</code> 路径，可以为 Prometheus 提供 GPU 指标的收集功能，<code>/usage</code> 路径可以提供可读性的容器状况查询</li></ul><h3 id=gpu-manager-使用场景>GPU-Manager 使用场景</h3><p>在 Kubernetes 集群中运行 GPU 应用时，可以解决 AI 训练等场景中申请独立卡造成资源浪费的情况，让计算资源得到充分利用。</p><h3 id=gpu-manager-限制条件>GPU-Manager 限制条件</h3><ol><li><p>该组件基于 Kubernetes DevicePlugin 实现，只能运行在支持 DevicePlugin 的 kubernetes版本（Kubernetes 1.10 之上的版本）</p></li><li><p>使用 GPU-Manager 要求集群内包含 GPU 机型节点</p></li><li><p>TKEStack 的 GPU-Manager 将每张 GPU 卡视为一个有100个单位的资源</p><blockquote><p>特别注意：</p><ol><li>当前仅支持 0-1 的小数张卡，如 20、35、50；以及正整数张卡，如200、500等；不支持类似150、250的资源请求</li><li>显存资源是以 256MiB 为最小的一个单位的分配显存</li></ol></blockquote></li></ol><h3 id=部署在集群内-kubernetes-对象>部署在集群内 kubernetes 对象</h3><p>在集群内部署 GPU-Manager，将在集群内部署以下 kubernetes 对象：</p><table><thead><tr><th style=text-align:left>kubernetes 对象名称</th><th style=text-align:left>类型</th><th style=text-align:left>建议预留资源</th><th style=text-align:left>所属 Namespaces</th></tr></thead><tbody><tr><td style=text-align:left>gpu-manager-daemonset</td><td style=text-align:left>DaemonSet</td><td style=text-align:left>每节点1核 CPU, 1Gi内存</td><td style=text-align:left>kube-system</td></tr><tr><td style=text-align:left>gpu-quota-admission</td><td style=text-align:left>Deployment</td><td style=text-align:left>1核 CPU, 1Gi内存</td><td style=text-align:left>kube-system</td></tr></tbody></table><h2 id=gpu-manager-使用方法>GPU-Manager 使用方法</h2><h3 id=安装-gpu-manager>安装 GPU-Manager</h3><p>集群部署阶段选择 vGPU，平台会为集群部署 GPU-Manager ，如下图新建独立集群所示，Global 集群的也是如此安装。</p><p><img src=../../../../../images/image%20%28117%29.png alt></p><h3 id=在节点安装-gpu-驱动>在节点安装 GPU 驱动</h3><p>集群部署阶段添加 GPU 节点时有勾选 GPU 选项，平台会自动为节点安装 GPU 驱动，如下图所示：</p><blockquote><p>注意：如果集群部署阶段节点没有勾选 GPU，需要自行在有 GPU 的节点上安装 GPU 驱动</p></blockquote><p><img src=../../../../../images/image%20%2877%29.png alt></p><h3 id=工作负载使用-gpu>工作负载使用 GPU</h3><h4 id=通过控制台使用>通过控制台使用</h4><p>在安装了 GPU-Manager 的集群中，创建工作负载时可以设置 GPU 限制，如下图所示：</p><blockquote><p>注意：</p><ol><li>卡数只能填写 0.1 到 1 之间的两位小数或者是所有自然数，例如：0、0.3、0.56、0.7、0.9、1、6、34，不支持 1.5、2.7、3.54</li><li>显存只能填写自然数 n，负载使用的显存为 n*256MiB</li></ol></blockquote><p><img src=../../../../../images/image%20%28109%29.png alt></p><h4 id=通过-yaml-使用>通过 YAML 使用</h4><p>如果使用 YAML 创建使用 GPU 的工作负载，提交的时候需要在 YAML 为容器设置 GPU 的使用资源。</p><ul><li>CPU 资源需要在 resource 上填写<code>tencent.com/vcuda-core</code></li><li>显存资源需要在 resource 上填写<code>tencent.com/vcuda-memory</code></li></ul><p>例1：使用1张卡的 Pod</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>apiVersion: v1

kind: Pod

...

spec:

  containers:

    - name: gpu

      resources:
        limits: 
          tencent.com/vcuda-core: 100
        requests:
          tencent.com/vcuda-core: 100
</code></pre></div><p>例2，使用 0.3 张卡、5GiB 显存的应用（5GiB = 20*256MB）</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>apiVersion: v1

kind: Pod

...

spec:

  containers:

  - name: gpu

    resources:
      limits:
        tencent.com/vcuda-core: 30
        tencent.com/vcuda-memory: 20
      requests:
        tencent.com/vcuda-core: 30
        tencent.com/vcuda-memory: 20
</code></pre></div><h2 id=gpu-监控数据查询>GPU 监控数据查询</h2><h3 id=通过控制台查询>通过控制台查询</h3><blockquote><p>前提：在集群的<a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/products/platform/cluster.md#%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF>【基本信息】</a>页里打开“监控告警”</p></blockquote><p>可以通过集群多个页面的监控按钮里查看到 GPU 的相关监控数据，下图以 集群管理 页对集群的监控为例：</p><p><img src=../../../../../images/image%20%2884%29.png alt></p><h3 id=通过后台手动查询>通过后台手动查询</h3><p>手动获取 GPU 监控数据方式（需要先安装 <a href=http://www.dest-unreach.org/socat/>socat</a>）：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl port-forward svc/gpu-manager-metric -n kube-system 5678:5678 &amp;
curl http://127.0.0.1:5678/metric
</code></pre></div><p>结果示例：</p><p><img src=../../../../../images/image%20%2848%29.png alt></p><p>GPUManager 项目请参考：<a href=https://github.com/tkestack/gpu-manager>GPUManager Repository</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-1908a7f2ad115ef0bc6b1cde68a4cc21>4.2.4.6 - CSIOperator 介绍</h1><div class=lead>CSIOperator 介绍</div><h2 id=csioperator>CSIOperator</h2><h3 id=csioperator-介绍>CSIOperator 介绍</h3><p>Container Storage Interface Operator(CSIOperator)用于部署和更新 Kubernetes 集群中的 CSI 驱动和外部存储组件。</p><h4 id=csioperator-使用场景>CSIOperator 使用场景</h4><p>CSIOperator 用于支持集群方便的使用存储资源，当前支持的存储插件包括 RBD、CephFS、TencentCBS 和 TencentCFS（TencentCFS 正在测试中）</p><ul><li>其中 RBD 和 CephFS 主要用于部署在 IDC 环境的集群</li><li>TencentCBS 和 TencentCFS 用于部署在腾讯云环境的集群</li></ul><h4 id=部署在集群内-kubernetes-对象>部署在集群内 kubernetes 对象</h4><p>在集群内部署 CSIOperator，将在集群内部署以下 kubernetes 对象</p><table><thead><tr><th style=text-align:left>kubernetes 对象名称</th><th style=text-align:left>类型</th><th style=text-align:left>默认占用资源</th><th style=text-align:left>所属 Namespaces</th></tr></thead><tbody><tr><td style=text-align:left>csi-operator</td><td style=text-align:left>Deployment</td><td style=text-align:left>每节点0.2核 CPU, 256MB内存</td><td style=text-align:left>kube-system</td></tr></tbody></table><h3 id=csioperator-使用方法>CSIOperator 使用方法</h3><h4 id=安装-csioperator>安装 CSIOperator</h4><ul><li>登录 TKEStack</li><li>切换至 【平台管理】控制台，选择 【扩展组件】 页面</li><li>选择需要安装组件的集群，点击【新建】按钮。如下图所示：</li></ul><p><img src=../../../../../images/image%20%2860%29.png alt></p><ul><li>在弹出的扩展组件列表里，滑动列表窗口找到 CSIOperator</li><li>单击【完成】进行安装</li></ul><h4 id=通过-csioperator-使用腾讯云存储资源>通过 CSIOperator 使用腾讯云存储资源</h4><ul><li>登录 TKEStack</li><li>切换至 【平台管理】控制台，选择 【集群管理】 页面，如下图1所示：</li><li>点击安装了 CSIOperator 组件的【集群ID】，进入要管理的集群，如下图2所示：</li><li>点击【YAML创建资源】，如下图3所示：</li></ul><p><img src=../../../../../images/image%20%28127%29.png alt></p><ul><li><p>文件中指定各自存储插件镜像的名称，这里以<code>tencentcbs</code>的 YAML 为例：（前提：需要拥有腾讯云账号）</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>apiVersion: storage.tkestack.io/v1
kind: CSI
metadata:
  name: tencentcbsv1
  namespace: kube-system
spec:
  driverName: com.tencent.cloud.csi.cbs
  version: &#34;v1&#34;
  parameters:
    secretID: &#34;xxxxxx&#34;
    secretKey: &#34;xxxxxx&#34;
</code></pre></div><ul><li>secretID、secretKey 来源于 腾讯云控制台 -> 账号中心 -> 访问管理 -> 访问秘钥 -> API密钥管理</li></ul></li><li><p>创建完 CSIOperator 的 CRD 对象，同时会为每个存储插件创建默认的 StorageClass 对象（tencentcbs 的 StorageClass 对象名为 cbs-basic-prepaid），如下图：</p></li></ul><p><img src=../../../../../images/image%20%28140%29.png alt></p><p>其 YAML 如下：</p><p><img src=../../../../../images/image%20%28123%29.png alt></p><ul><li><p>tencentcbs 的 provisioner 名称指定为：<code>com.tencent.cloud.csi.cbs</code></p></li><li><p>tencentcfs 的 provisioner 名称指定为：<code>com.tencent.cloud.csi.cfs</code>，tencentcfs 仍在测试中，目前仅支持 tencentcbs</p></li><li><p>对于磁盘类型（在 StorageClass 的 <code>diskType</code> 中指定）和大小的限制：</p><ul><li>普通云硬（ <code>CLOUD_BASIC</code> ）盘提供最小 100 GB 到最大 16000 GB 的规格选择，支持 40-100MB/s 的 IO 吞吐性能和 数百-1000 的随机 IOPS 性能</li><li>高性能云硬盘（<code>CLOUD_PREMIUM</code>）提供最小 50 GB 到最大 16000 GB 的规格选择</li><li>SSD 云硬盘（<code>CLOUD_SSD</code>）提供最小 100 GB 到最大 16000 GB 的规格选择，单块 SSD 云硬盘最高可提供 24000 随机读写IOPS、260MB/s吞吐量的存储性能</li></ul></li><li><p>默认创建的磁盘类型为普通云硬盘，如果用户希望使用该 StorageClass，可以直接创建使用了该 StorageClass 的 PVC 对象：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: test-tencentcbs
  namespace: kube-system
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: cbs-basic-prepaid
  resources:
    requests:
      storage: 10Gi
</code></pre></div></li></ul><p>详情请见 <a href=https://github.com/tkestack/csi-operator/blob/master/examples>CSIOperator Example</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-d5c510eb12ae466242386f0cebdb156b>4.2.5 - 组织资源</h1><div class=lead>组织资源</div><h1 id=组织资源>组织资源</h1><h2 id=概念>概念</h2><p><strong>这里用户可以管理镜像仓库和凭据。</strong></p></div><div class=td-content><h1 id=pg-64d4646ef1291f0db93a3686d23ec15f>4.2.5.1 - 镜像仓库管理</h1><div class=lead>镜像仓库管理</div><h2 id=镜像仓库管理>镜像仓库管理</h2><h3 id=镜像仓库概述>镜像仓库概述</h3><p><strong>镜像仓库</strong>：用于存放 Docker 镜像，Docker 镜像可用于部署容器服务，每个镜像有特定的唯一标识（镜像的 Registry 地址+镜像名称+镜像 Tag）</p><p><strong>镜像类型</strong>：目前镜像支持 Docker Hub 官方镜像和用户私有镜像</p><p><strong>镜像生命周期</strong>：主要包含镜像版本的生成、上传和删除</p><h3 id=新建命名空间>新建命名空间</h3><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择 【组织资源】->【镜像仓库管理】</li><li>点击【新建】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2888%29.png alt></p><ul><li>在弹出的“新建命名空间”页面，填写命名空间信息，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2841%29.png alt></p><ul><li><strong>名称：</strong> 命名空间名字，不超过63字符</li><li><strong>描述：</strong> 命名空间描述信息（可选）</li><li><strong>权限类型：</strong> 选择命名空间权限类型<ul><li><strong>公有：</strong> 所有人均可访问该命名空间下的镜像</li><li><strong>私有：</strong> 个人用户命名空间</li></ul></li><li>单击【确认】按钮</li></ul><h3 id=删除命名空间>删除命名空间</h3><ul><li>登录 TKEStack</li><li>切换至 【平台管理】控制台，选择 【组织资源】->【镜像仓库管理】。点击列表最右侧【删除】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%28106%29.png alt></p><h3 id=镜像上传>镜像上传</h3><ul><li>登录 TKEStack</li><li>切换至 【平台管理】控制台，选择 【组织资源】->【镜像仓库管理】，查看命名空间列表，点击列表中命名空间【名称】，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2881%29.png alt></p><ul><li><p>此时进入了“镜像列表”页面，点击【镜像上传指引】按钮，如下图所示：</p><blockquote><p>注意：此页面可以通过上传的镜像最右边的【删除】按钮来删除上传的镜像</p></blockquote></li></ul><p><img src=../../../../../images/image%20%2868%29.png alt></p><ul><li>根据指引内容，在物理节点上执行相应命令，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2833%29.png alt></p></div><div class=td-content style=page-break-before:always><h1 id=pg-26f3f5de560aa7df709ac0f6721cad7a>4.2.5.2 - Helm模板</h1><div class=lead>Helm模板</div><p>应用功能是 TKEStack 集成的 <a href=https://helm.sh/>Helm 3.0</a> 相关功能，为您提供创建 helm chart、容器镜像、软件服务等各种产品和服务的能力。已创建的应用将在您指定的集群中运行，为您带来相应的能力。</p><h2 id=模板>模板</h2><ul><li>登录 TKEStack</li><li>切换至 【平台管理】控制台，选择 【组织资源】->【 Helm模板】，点击【模板】</li></ul><p><img src=../../../../../images/image-20201203144524973.png alt=image-20201203144524973></p><ol><li><strong>所有模板</strong>：包含下列所有模板</li><li><strong>用户模板</strong>：权限范围为“指定用户”的仓库下的所有模板</li><li><strong>业务模板</strong>：权限范围为“指定业务”的仓库下的所有模板</li><li><strong>公共模板</strong>：权限范围为“公共”的仓库下的所有模板</li></ol><h2 id=仓库>仓库</h2><ul><li>登录 TKEStack</li><li>切换至 【平台管理】控制台，选择 【组织资源】->【 Helm模板】，点击【仓库】</li><li>点击【新建】按钮，如下图所示：</li></ul><p><img src=../../../../../images/Chart%E5%8C%85%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.png alt=&#x65B0;&#x5EFA;Chart&#x5305;&#x547D;&#x540D;&#x7A7A;&#x95F4;></p><ul><li>在弹出的 “新建仓库” 页面，填写 仓库 信息，如下图所示：</li></ul><p><img src=../../../../../images/image-20201203144754466.png alt=image-20201203144754466></p><ul><li><p><strong>仓库名称：</strong> 仓库名字，不超过60个字符</p></li><li><p><strong>权限访问</strong></p><ul><li><strong>指定用户</strong>：选择当前仓库可以被哪些平台的用户访问</li><li><strong>指定业务</strong>：选择当前仓库可以被哪些平台的业务访问，业务下的成员对该仓库的访问权限在【业务管理】中完成</li><li><strong>公共</strong>：平台所有用户都能访问该仓库</li></ul></li><li><p><strong>导入第三方仓库：</strong> 若已有仓库想导入 TKEStack 中使用，请勾选</p><ul><li><strong>第三方仓库地址</strong>：请输入第三方仓库地址</li><li><strong>第三方仓库用户名</strong>：若第三方仓库开启了鉴权，需要输入第三方仓库的用户名</li><li><strong>第三方仓库密码</strong>：若第三方仓库开启了鉴权，需要输入第三方仓库的密码</li></ul></li><li><p><strong>仓库描述：</strong> 请输入仓库描述，不超过255个字符</p></li><li><p>单击【确认】按钮</p><p><strong>删除仓库</strong></p></li><li><p>登录 TKEStack</p></li><li><p>切换至 【平台管理】控制台，选择 【组织资源】-> 【 Helm 模板】，点击【仓库】，查看 “helm模板仓库”列表</p></li><li><p>点击列表最右侧【删除】按钮，如下图所示：</p></li></ul><p><img src=../../../../../images/Chart%E5%8C%85%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%88%A0%E9%99%A4%E6%8C%89%E9%92%AE%20%281%29.png alt=Chart&#x5305;&#x547D;&#x540D;&#x7A7A;&#x95F4;&#x5220;&#x9664;&#x6309;&#x94AE;></p><p><strong>Chart 上传指引</strong></p><ul><li>登录 TKEStack</li><li>切换至 【平台管理】控制台，选择 【组织资源】-> 【 Helm模板】，点击【仓库】，查看 “helm模板仓库”列表</li><li>点击列表最右侧【上传指引】按钮，如下图所示：</li></ul><p><img src=../../../../../images/Chart%E5%8C%85%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%90%8D%E7%A7%B0%20%281%29.png alt=Chart&#x5305;&#x547D;&#x540D;&#x7A7A;&#x95F4;&#x540D;&#x79F0;></p><ul><li>根据指引内容，在物理节点上执行相应命令，如下图所示：</li></ul><p><img src=../../../../../images/Chart%E4%B8%8A%E4%BC%A0%E6%8C%87%E5%BC%95%E5%86%85%E5%AE%B9.png alt=Chart&#x4E0A;&#x4F20;&#x6307;&#x5F15;&#x5185;&#x5BB9;></p><h2 id=同步导入仓库>同步导入仓库</h2><ol><li>登录 TKEStack</li><li>切换至 【平台管理】控制台，选择 【组织资源】->【 Helm模板】，点击【仓库】</li><li>点击导入仓库的【同步仓库】按钮，如下图所示：</li></ol><p><img src=../../../../../images/image-20201203151341971.png alt=image-20201203151341971></p></div><div class=td-content style=page-break-before:always><h1 id=pg-e90c4b8de7956382e8cb823e234fcfdc>4.2.5.3 - 访问凭证</h1><div class=lead>访问凭证</div><h2 id=访问凭证>访问凭证</h2><p><strong>这里用户可以管理自己的凭据，用来登陆平台创建的</strong><a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/products/platform/resource/registry.md><strong>镜像仓库</strong></a><strong>和</strong><a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/products/platform/resource/helm.md><strong>应用仓库</strong></a><strong>。</strong></p><h3 id=新建访问凭证>新建访问凭证</h3><ul><li>登录 TKEStack</li><li>切换至 【平台管理】控制台，选择 【组织资源】下的【访问凭证】，点击【新建】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2899%29.png alt></p><ul><li>在弹出创建访问凭证页面，填写凭证信息，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2811%29.png alt></p><ul><li><strong>凭证描述：</strong> 描述当前凭证信息</li><li><strong>过期时间：</strong> 填写过期时间，选择小时/分钟为单位</li><li>单击【确认】按钮</li></ul><h3 id=使用指引>使用指引</h3><ul><li>登录 TKEStack</li><li>切换至 【平台管理】控制台，选择 【组织资源】下的【访问凭证】，点击【新建】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2844%29.png alt></p><ul><li>根据指引内容，在物理节点上执行相应命令</li></ul><h3 id=停用启用删除访问凭证>停用/启用/删除访问凭证</h3><ul><li><p>登录 TKEStack</p></li><li><p>切换至 【平台管理】控制台，选择 【组织资源】-> 【访问凭证】，查看“访问凭证”列表，单击列表右侧【禁用】/【启用】/【删除】按钮。如下图所示：</p><blockquote><p>注意：点击【禁用】之后，【禁用】按钮就变成了【启用】</p></blockquote></li></ul><p><img src=../../../../../images/image%20%2855%29.png alt></p><ul><li>单击【确认】按钮</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1e2e6f8e38db1566b319ae4dcf54e5bd>4.2.6 - 访问管理</h1><div class=lead>访问管理</div></div><div class=td-content><h1 id=pg-2afb350b927ffbe1b6aefc8291b4faba>4.2.6.1 - 策略管理</h1><div class=lead>策略管理</div><h2 id=策略管理>策略管理</h2><h3 id=平台策略>平台策略</h3><h4 id=新建策略>新建策略</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【访问管理】->【策略管理】</li><li>点击【新建】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2840%29.png alt></p><ul><li>在弹出的新建策略窗口输入策略信息。如下图所示：</li></ul><p><img src=../../../../../images/image%20%2874%29.png alt></p><ul><li><strong>策略名称：</strong> 长度需要小于256个字符</li><li><strong>效果：</strong> 策略动作，允许/拒绝</li><li><strong>服务：</strong> 选择策略应用于哪项服务</li><li><strong>操作：</strong> 选择对应服务的各项操作权限</li><li><strong>资源：</strong> 输入资源label，支持模糊匹配，策略将应用于匹配到的资源</li><li><strong>描述：</strong> 输入策略描述</li><li>单击【保存】按钮</li></ul><h4 id=关联用户和用户组>关联用户和用户组</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【访问管理】->【策略管理】，查看策略列表</li><li>点击列表中最右侧【关联用户】或【关联用户组】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2853%29.png alt></p><ul><li>在弹出的关联用户窗口选择用户或用户组，这里以用户组为例。如下图所示：</li></ul><p><img src=../../../../../images/image%20%2864%29.png alt></p><ul><li>单击【确定】按钮</li></ul><h4 id=编辑策略基本信息>编辑策略基本信息</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【访问管理】->【策略管理】，查看策略列表</li><li>点击列表中的策略名称，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2831%29.png alt></p><ul><li>在策略基本信息页面，单击 “基本信息” 旁的【编辑】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2851%29.png alt></p><ul><li>在弹出的信息框内编辑策略名称和描述</li><li>单击【保存】按钮</li></ul><h3 id=业务策略>业务策略</h3><h4 id=新建策略-1>新建策略</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【访问管理】->【策略管理】->【业务策略】</li><li>点击【新建】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%28129%29.png alt></p><ul><li>在弹出的新建策略窗口输入策略信息，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2862%29.png alt></p><ul><li><strong>策略名称：</strong> 长度需要小于256个字符</li><li><strong>效果：</strong> 策略动作，允许/拒绝</li><li><strong>服务：</strong> 选择策略应用于哪项服务</li><li><strong>操作：</strong> 选择对应服务的各项操作权限</li><li><strong>资源：</strong> 输入资源label，支持模糊匹配，策略将应用于匹配到的资源</li><li><strong>描述：</strong> 输入策略描述</li><li>单击【保存】按钮</li></ul><h4 id=编辑策略基本信息-1>编辑策略基本信息</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【访问管理】->【策略管理】，查看策略列表</li><li>点击列表中的策略名称，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2857%29.png alt></p><ul><li>在策略基本信息页面，单击 “基本信息” 旁的【编辑】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2838%29.png alt></p><ul><li>在弹出的信息框内编辑策略名称和描述</li><li>单击【保存】按钮</li><li>此页面还可以编辑策略语法</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-b8df25d88d18c9314eee7073f7e19ed4>4.2.6.2 - 用户管理</h1><div class=lead>用户管理</div><h2 id=用户管理>用户管理</h2><h3 id=用户>用户</h3><h4 id=新建用户>新建用户</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【访问管理】->【用户管理】</li><li>点击【新建】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2845%29.png alt></p><ul><li>在弹出的添加用户窗口填写用户信息，如下图所示：</li></ul><p><img src=../../../../../images/image%20%281%29.png alt></p><ul><li><strong>用户账号：</strong> 长度3～32位字符，小写字母或数字开头结尾，中间包含小写字母、数字、-</li><li><strong>用户名称：</strong> 长度需小于256字符，用户名称会显示在页面右上角</li><li><strong>用户密码：</strong> 10~16位字符，需包括大小写字母及数字</li><li><strong>确认密码：</strong> 再次输入密码</li><li><strong>手机号：</strong> 输入用户手机号</li><li><strong>邮箱：</strong> 输入用户邮箱</li><li><strong>平台角色：</strong><ul><li><strong>管理员：</strong> 平台预设角色，允许访问和管理所有平台和业务的功能和资源</li><li><strong>平台用户：</strong> 平台预设角色，允许访问和管理大部分平台功能，可以新建集群及业务</li><li><strong>租户：</strong> 平台预设角色，不绑定任何平台权限，仅能登录</li><li><strong>自定义：</strong> 通过勾选下面的策略给用户自定义独立的权限</li></ul></li><li>单击【保存】按钮</li></ul><h4 id=修改密码>修改密码</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【访问管理】->【用户管理】，查看用户列表</li><li>点击用户列表最右侧的【修改密码】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2819%29.png alt></p><ul><li>在弹出的修改密码窗口里输入新的密码并确认，如下图所示：</li></ul><p><img src=../../../../../images/image%20%28101%29.png alt></p><ul><li>单击【保存】按钮</li></ul><h4 id=编辑用户基本信息>编辑用户基本信息</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【访问管理】->【用户管理】，查看用户列表</li><li>点击列表中的用户名称，如下图所示：</li></ul><p><img src=../../../../../images/image%20%28103%29.png alt></p><ul><li>在用户基本信息页面，单击 基本信息 旁的【编辑】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%28112%29.png alt></p><ul><li>在弹出的用户信息框内编辑用户信息</li><li>单击【保存】按钮</li><li>此页面下面可以查看当前用户的 已管理策略、已关联用户组 和 已关联角色</li></ul><h3 id=用户组>用户组</h3><h4 id=新建用户组>新建用户组</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【访问管理】->【用户管理】-> 【用户组】</li><li>点击【新建】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2865%29.png alt></p><ul><li>在弹出的添加用户窗口填写用户信息，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2867%29.png alt></p><ul><li><strong>用户组名称：</strong> 长度需小于60位字符，小写字母或数字开头结尾，中间包含小写字母、数字、-</li><li><strong>用户组描述：</strong> 长度需小于255字符</li><li><strong>关联用户：</strong> 点按用户ID/名称前面的方框可以关联相应的用户，支持全选和按住shift键多选</li><li><strong>平台角色：</strong><ul><li><strong>管理员：</strong> 平台预设角色，允许访问和管理所有平台和业务的功能和资源</li><li><strong>平台用户：</strong> 平台预设角色，允许访问和管理大部分平台功能，可以新建集群及业务</li><li><strong>租户：</strong> 平台预设角色，不绑定任何平台权限，仅能登录</li><li><strong>自定义：</strong> 通过勾选下面的策略给用户自定义独立的权限</li></ul></li><li>单击【提交】按钮</li></ul><h4 id=编辑用户组基本信息>编辑用户组基本信息</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【访问管理】->【用户组管理】，查看用户组列表</li><li>点击列表中的用户组名称，如下图1所示：</li></ul><p><img src=../../../../../images/image%20%2892%29.png alt></p><blockquote><p>此界面也可以更改关联用户，如上图中的2所示，和 新建用户组 ->添加用户组 中一样的步骤来关联用户</p></blockquote><ul><li>在用户组基本信息页面，单击 基本信息 旁的【编辑】按钮，如下图1所示：</li></ul><p><img src=../../../../../images/image%20%2814%29.png alt></p><ul><li><p>在弹出的信息框内可以编辑 用户组名称 和 用户组描述，此时会出现【提交】按钮，点击后可更改用户组基本信息。</p><blockquote><p>如上图中的2所示，此界面也可以更改关联用户，点击蓝色【关联用户】按钮后，和 新建用户组 ->添加用户组 中一样的操作来关联用户。这里还可以点击查看【已关联角色】和【已关联策略】</p></blockquote></li></ul><h4 id=删除用户组>删除用户组</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【访问管理】->【用户组管理】，查看用户组列表</li><li>点击用户组列表最右侧的【删除】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2870%29.png alt></p><ul><li>在弹出的确认删除窗口，单击【确认】</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-b22c0bde169ab6bdc225b49782930706>4.2.7 - 监控&告警</h1><div class=lead>监控&告警</div></div><div class=td-content><h1 id=pg-23a8b7f582c270bcb790b3707905d346>4.2.7.1 - 告警记录</h1><div class=lead>告警记录</div><h3 id=概念>概念</h3><p><strong>这里可以查看历史告警记录</strong></p><h3 id=查看历史告警记录>查看历史告警记录</h3><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择 【监控&告警】->【告警记录】查看“历史告警记录”列表，如下图所示：</li></ul><p><img src=https://github.com/tkestack/tke/raw/master/docs/images/%E5%91%8A%E8%AD%A6%E8%AE%B0%E5%BD%95.png alt=&#x5220;&#x9664;&#x63A5;&#x6536;&#x7EC4;></p></div><div class=td-content style=page-break-before:always><h1 id=pg-c677185f730a103f7429f6161d3c5546>4.2.7.2 - 通知设置</h1><div class=lead>通知设置</div><h2 id=通知设置>通知设置</h2><h3 id=概念>概念</h3><p><strong>这里用户配置平台通知</strong></p><h3 id=通知渠道>通知渠道</h3><h4 id=新建通知渠道>新建通知渠道</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择 【监控&告警】->【通知设置】->【通知渠道】，查看“通知渠道”列表</li><li>点击【新建】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2826%29.png alt></p><ul><li>在“新建通知渠道”页面填写渠道信息，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2889%29.png alt></p><ul><li><strong>名称：</strong> 填写渠道名称</li><li><strong>渠道：</strong> 选择渠道类型，输入渠道信息<ul><li><strong>邮件：</strong> 邮件类型<ul><li><strong>email：</strong> 邮件发送放地址</li><li><strong>password：</strong> 邮件发送方密码</li><li><strong>smtpHost：</strong> smtp IP 地址</li><li><strong>smtpPort：</strong> smtp 端口</li><li><strong>tls：</strong> 是否使用tls加密</li></ul></li><li><strong>短信：</strong> 短信方式<ul><li><strong>appKey：</strong> 短信发送方的 appKey</li><li><strong>sdkAppID：</strong> sdkAppID</li><li><strong>extend：</strong> extend 信息</li></ul></li><li><strong>微信公众号：</strong> 微信公众号方式<ul><li><strong>appID：</strong> 微信公众号 appID</li><li><strong>appSecret：</strong> 微信公众号 appSecret</li></ul></li><li><strong>Webhook：</strong> Webhook 方式<ul><li><strong>URL</strong>：Webhook 的 URL</li><li><strong>Headers：</strong> 自定义 Header</li></ul></li></ul></li><li>单击【保存】按钮</li></ul><h4 id=编辑通知渠道>编辑通知渠道</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择 【监控&告警】->【通知设置】->【通知渠道】，查看“通知渠道”列表</li><li>单击渠道名称，如下图所示：</li></ul><p><img src=../../../../../images/image%20%28120%29.png alt></p><ul><li>在“基本信息”页面，单击【基本信息】右侧的【编辑】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2891%29.png alt></p><ul><li>在“更新渠道通知”页面，编辑渠道信息</li><li>单击【保存】按钮</li></ul><h4 id=删除通知渠道>删除通知渠道</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择 【监控&告警】->【通知设置】->【通知渠道】，查看“通知渠道”列表</li><li>选择要删除的渠道，点击【删除】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2813%29.png alt></p><ul><li>单击删除窗口的【确定】按钮</li></ul><h3 id=通知模板>通知模板</h3><h4 id=新建通知模版>新建通知模版</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择 【监控&告警】->【通知设置】->【通知模板】，查看“通知模板”列表</li><li>点击【新建】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%285%29.png alt></p><ul><li>在“新建通知模版”页面填写模版信息，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2837%29.png alt></p><ul><li><strong>名称：</strong> 模版名称</li><li><strong>渠道：</strong> 选择已创建的渠道</li><li><strong>body：</strong> 填写消息 body</li><li><strong>header：</strong> 填写消息 header</li><li>单击【保存】按钮</li></ul><h4 id=编辑通知模版>编辑通知模版</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择 【监控&告警】->【通知设置】->【通知模板】，查看“通知模板”列表</li><li>单击模版名称，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2835%29.png alt></p><ul><li>在基本信息页面，单击【基本信息】右侧的【编辑】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%28116%29.png alt></p><ul><li>在“更新通知模版”页面，编辑模版信息</li><li>单击【保存】按钮</li></ul><h4 id=删除通知模版>删除通知模版</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择 【监控&告警】->【通知设置】->【通知模板】，查看"通知模板"列表</li><li>选择要删除的模版，点击【删除】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%288%29.png alt></p><ul><li>单击删除窗口的【确定】按钮</li></ul><h3 id=接收人>接收人</h3><h4 id=新建接收人>新建接收人</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择 【监控&告警】->【通知设置】->【接收人】，查看"接收人"列表</li><li>点击【新建】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2816%29.png alt></p><ul><li>在“新建接收人”页面填写模版信息，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2876%29.png alt></p><ul><li><strong>显示名称：</strong> 接收人显示名称</li><li><strong>用户名：</strong> 接收人用户名</li><li><strong>移动电话：</strong> 手机号</li><li><strong>电子邮件：</strong> 接收人邮箱</li><li><strong>微信OpenID：</strong> 接收人微信ID</li><li>单击【保存】按钮</li></ul><h4 id=编辑接收人信息>编辑接收人信息</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择 【监控&告警】->【通知设置】->【接收人】，查看“接收人”列表</li><li>单击接收人名称，如下图所示：</li></ul><p><img src=../../../../../images/image%20%28121%29.png alt></p><ul><li>在“基本信息”页面，单击【基本信息】右侧的【编辑】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2810%29.png alt></p><ul><li>在“更新接收人”页面，编辑接收人信息</li><li>单击【保存】按钮</li></ul><h4 id=删除接收人>删除接收人</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择 【监控&告警】->【通知设置】->【接收人】，查看“接收人”列表</li><li>选择要删除的接收人，点击【删除】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2875%29.png alt></p><ul><li>单击删除窗口的【确定】按钮</li></ul><h3 id=接收组>接收组</h3><h4 id=新建接收组>新建接收组</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择 【监控&告警】->【通知设置】->【接收组】，查看“接收组”列表</li><li>点击【新建】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%28131%29.png alt></p><ul><li>在“新建接收组”页面填写模版信息，如下图所示：</li></ul><p><img src=../../../../../images/image%20%28111%29.png alt></p><ul><li><strong>名称：</strong> 接收组显示名称</li><li><strong>接收组：</strong> 从列表里选择接收人。如没有想要的接收人，请在<a href>接收人</a>里创建</li><li>单击【保存】按钮</li></ul><h4 id=编辑接收组信息>编辑接收组信息</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择 【监控&告警】->【通知设置】->【接收组】，查看“接收组”列表</li><li>单击接收组名称，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2856%29.png alt></p><ul><li>在“基本信息”页面，单击【基本信息】右侧的【编辑】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%28107%29.png alt></p><ul><li>在“更新接收组”页面，编辑接收组信息</li><li>单击【保存】按钮</li></ul><h4 id=删除接收组>删除接收组</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择 【监控&告警】->【通知设置】->【接收组】，查看“接收组”列表</li><li>选择要删除的接收组，点击【删除】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2842%29.png alt></p><ul><li>单击删除窗口的【确定】按钮</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-0a1a33c9e3221ae15fbb22a45f0ce01a>4.2.7.3 - 告警设置</h1><div class=lead>告警设置</div><h2 id=告警设置>告警设置</h2><h3 id=概念>概念</h3><p><strong>这里用户配置平台告警</strong></p><h3 id=前提条件>前提条件</h3><blockquote><p>需要设置告警的集群应该先在其 <a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/products/platform/cluster.md#%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF>基本信息</a> 页里开启<strong>监控告警</strong></p></blockquote><h3 id=新建告警设置>新建告警设置</h3><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择 【监控&告警】下的【告警设置】，查看“告警设置”列表</li><li>选择相应【集群】，点击【新建】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%28110%29.png alt></p><ul><li>在“新建策略”页面填写告警策略信息，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2822%29.png alt></p><ul><li><strong>告警策略名称：</strong> 输入告警策略名称，最长60字符</li><li><strong>策略类型：</strong> 选择告警策略应用类型<ul><li><strong>集群：</strong> 集群监控告警</li><li><strong>Pod：</strong> Pod 监控告警<ul><li><strong>告警对象：</strong> 选择 Pod 相关的告警对象，支持对 namespace 下不同的 deployment、stateful和daemonset 进行监控报警<ul><li><strong>按工作负载选择：</strong> 选择 namespace 下的某个工作负载</li><li><strong>全部选择：</strong> 不区分 namespace，全部监控</li></ul></li></ul></li><li><strong>节点：</strong> 节点监控告警</li></ul></li><li><strong>统计周期：</strong> 选择数据采集周期，支持1、2、3、4、5分钟</li><li><strong>指标：</strong> 选择告警指标，支持对监测值与指标值进行【大于/小于】比较，选择结果持续周期，如下图。指标具体含义可参考：[监控&告警指标含义](../../../../FAQ/Platform/alert&monitor-metrics）</li></ul><p><img src=../../../../../images/image%20%2885%29.png alt></p><ul><li><strong>接收组：</strong> 选择接收组，当出现满足条件当报警信息时，向组内人员发送消息。<strong>接收组需要先在</strong> <a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/products/platform/accessmanagement/user.md#%E7%94%A8%E6%88%B7%E7%BB%84><strong>用户管理</strong></a> <strong>创建</strong></li><li><strong>通知方式：</strong> 选择通知渠道和消息模版。<strong>通知渠道 和 消息模版需要先在</strong> <a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/products/platform/monitor%26alert/notification.md><strong>通知设置</strong></a> <strong>创建</strong><ul><li><strong>添加通知方式</strong> ：如需要添加多种通知方式，点击该按钮</li></ul></li><li>单击【提交】按钮</li></ul><h4 id=复制告警设置>复制告警设置</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择 【监控&告警】下的【告警设置】，查看“告警设置”列表</li><li>选择相应【集群】，点击告警设置列表最右侧的【复制】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%28138%29.png alt></p><ul><li>在“复制策略”页面，编辑告警策略信息</li><li>单击【提交】按钮</li></ul><h4 id=编辑告警设置>编辑告警设置</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择 【监控&告警】下的【告警设置】，查看“告警设置”列表</li><li>选择相应【集群】，点击【告警名称】，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2827%29.png alt></p><ul><li>在“告警策略详情”页面，单击【基本信息】右侧的【编辑】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%28115%29.png alt></p><ul><li>在“更新策略”页面，编辑策略信息</li><li>单击【提交】按钮</li></ul><h4 id=删除告警设置>删除告警设置</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择 【监控&告警】下的【告警设置】，查看“告警设置”列表</li><li>选择相应【集群】，点击列表最右侧的【删除】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2854%29.png alt></p><ul><li>在弹出的删除告警窗口，单击【确定】按钮</li></ul><h3 id=批量删除告警设置>批量删除告警设置</h3><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择 【监控&告警】下的【告警设置】，查看“告警设置”列表</li><li>选择相应【集群】，选择多个告警策略，单击告警设置下方的【删除】按钮。如下图所示：</li></ul><p><img src=../../../../../images/image%20%2895%29.png alt></p><ul><li>在弹出的删除告警窗口，单击【确定】按钮</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-09ccc45f60cc4e226d68fd40cba886e8>4.2.8 - 运维中心</h1><div class=lead>运维中心</div><h1 id=运维中心>运维中心</h1><h2 id=概念>概念</h2><p><strong>这里用户可以管理 Helm 应用、日志和集群事件持久化。</strong></p></div><div class=td-content><h1 id=pg-c33fc9e02cdad664bbb84e3fffcf6b82>4.2.8.1 - Helm应用</h1><div class=lead>Helm应用</div><p>应用功能是 TKEStack 集成的 <a href=https://helm.sh/>Helm 3.0</a> 相关功能，为您提供创建 helm chart、容器镜像、软件服务等各种产品和服务的能力。已创建的应用将在您指定的集群中运行，为您带来相应的能力。</p><h2 id=新建-helm-应用>新建 Helm 应用</h2><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【运维中心】->【 Helm 应用】</li><li>选择相应【集群】，单击【新建】按钮，如下图所示：</li></ul><p><img src=../../../../../images/platformhelm.png alt="&#x65B0;&#x5EFA; Helm &#x6309;&#x94AE;"></p><ul><li>在“新建 Helm 应用”页面填写Helm应用信息，如下图所示：</li></ul><p><img src=../../../../../images/%E6%96%B0%E5%BB%BAHelm%E5%BA%94%E7%94%A8.png alt="&#x65B0;&#x5EFA; Helm &#x5E94;&#x7528;"></p><ul><li><strong>应用名称：</strong> 输入应用名，1～63字符，只能包含小写字母、数字及分隔符("-")，且必须以小写字母开头，数字或小写字母结尾</li><li><strong>运行集群：</strong> 选择应用所在集群</li><li><strong>命名空间：</strong> 选择应用所在集群的命名空间</li><li><strong>类型：</strong> 当前仅支持 HelmV3</li><li><strong>Chart：</strong> 选择需要部署的 chart</li><li><strong>Chart版本：</strong> 选择 chart 的版本</li><li><strong>参数：</strong> 更新时如果选择不同版本的 Helm Chart，参数设置将被覆盖</li><li><strong>拟运行：</strong> 会返回模板渲染清单，即最终将部署到集群的 YAML 资源，不会真正执行安装</li><li>单击【完成】按钮</li></ul><h2 id=删除-helm-应用>删除 Helm 应用</h2><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【运维中心】->【 Helm 应用】</li><li>点击【删除】</li></ul><p><img src=../../../../../images/image-20201203150729694.png alt=image-20201203150729694></p><h2 id=查看-helm-应用资源列表>查看 Helm 应用资源列表</h2><ol><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【运维中心】->【 Helm 应用】</li><li>点击【应用名】后，点击【资源列表】，可查看该应用所有 Kubernetes 资源对象</li></ol><h2 id=查看-helm-应用详情>查看 Helm 应用详情</h2><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【运维中心】->【 Helm 应用】</li><li>点击【应用名】后，点击【应用详情】</li></ul><p><img src=../../../../../images/image-20201203150904452.png alt=image-20201203150904452></p><h2 id=查看-helm-应用版本历史>查看 Helm 应用版本历史</h2><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【运维中心】->【 Helm 应用】</li><li>点击【应用名】后，点击【版本历史】，可查看该应用所部署的历史版本。可以通过选择不同的版本进行参数对比查看其版本区别</li></ul><p><img src=../../../../../images/image-20201203151027616.png alt=image-20201203151027616></p></div><div class=td-content style=page-break-before:always><h1 id=pg-26d04226b313f47a8e04a3e9fee4bd6e>4.2.8.2 - 日志采集</h1><div class=lead>日志采集</div><h2 id=日志采集>日志采集</h2><h3 id=概念>概念</h3><p>TKESTack 提供的集群内日志采集功能，支持将集群内服务或集群节点特定路径文件的日志发送至 Kafka、Elasticsearch 等消费端，支持采集容器标准输出日志，容器内文件日志以及主机内文件日志。更提供事件持久化、审计等功能，实时记录集群事件及操作日志记录，帮助运维人员存储和分析集群内部资源生命周期、资源调度、异常告警等情况。</p><p><img src=../../../../../images/image%20%2830%29.png alt></p><p>日志收集功能需要为每个集群手动开启。日志收集功能开启后，日志收集组件 logagent 会在集群内以 Daemonset 的形式运行。用户可以通过日志收集规则配置日志的采集源和消费端，日志收集 Agent 会从用户配置的采集源进行日志收集，并将日志内容发送至用户指定的消费端。需要注意的是，使用日志收集功能需要您确认 Kubernetes 集群内节点能够访问日志消费端。</p><ul><li><strong>采集容器标准输出日志</strong> ：采集集群内指定容器的标准输出日志，采集到的日志信息将会以 JSON 格式输出到用户指定的消费端，并会自动附加相关的 Kubernetes metadata， 包括容器所属 pod 的 label 和 annotation 等信息。</li><li><strong>采集容器内文件日志</strong> ：采集集群内指定 pod 内文件的日志，用户可以根据自己的需求，灵活的配置所需的容器和路径，采集到的日志信息将会以 JSON 格式输出到用户指定的消费端， 并会附加相关的 Kubernetes metadata，包括容器所属 pod 的 label 和 annotation 等信息。</li><li><strong>采集主机内文件日志</strong> ：采集集群内所有节点的指定主机路径的日志，logagent 会采集集群内所有节点上满足指定路径规则的文件日志，以 JSON 格式输出到用户指定的输出端， 并会附加用户指定的 metadata，包括日志来源文件的路径和用户自定义的 metadata。</li></ul><blockquote><p>注意：日志采集对接外部 Kafka 或 Elasticsearch，该功能需要额外开启，位置在集群 <a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/products/platform/cluster.md#%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF>基本信息</a> 下面，点击开启“日志采集”服务。</p></blockquote><p>​</p><p><img src=../../../../../images/image%20%28137%29.png alt></p><h3 id=新建日志采集规则>新建日志采集规则</h3><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择 【运维中心】->【日志采集】</li><li>选择相应【集群】和【命名空间】，单击【新建】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%28119%29.png alt></p><ul><li>在“新建日志采集”页面填写日志采集信息，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2887%29.png alt></p><ul><li><strong>收集规则名称：</strong> 输入规则名，1～63字符，只能包含小写字母、数字及分隔符("-")，且必须以小写字母开头，数字或小写字母结尾</li><li><strong>所属集群：</strong> 选择所属集群</li><li><strong>类型：</strong> 选择采集类型<ul><li><strong>容器标准输出：</strong> 容器Stdout信息采集<ul><li><strong>日志源：</strong> 可以选择所有容器或者某个namespace下的所有容器/工作负载<ul><li><strong>所有容器：</strong> 所有容器</li><li><strong>指定容器：</strong> 某个Namespace下的所有容器或者工作负载</li></ul></li></ul></li><li><strong>容器文件路径：</strong> 容器内文件内容采集<ul><li><strong>日志源：</strong> 可以采集具体容器内的某个文件路径下的文件内容<ul><li><strong>工作负载选项：</strong> 选择某个namespace下的某种工作负载类型下的某个工作负载</li><li><strong>配置采集路径：</strong> 选择某个容器下的某个文件路径</li></ul></li></ul></li><li><strong>节点文件路径：</strong> 收集节点上某个路径下的文件内容<ul><li><strong>日志源：</strong><ul><li><strong>收集路径：</strong> 节点上日志收集路径</li><li><strong>metadata：</strong> key：value格式，收集的日志会带上metadata信息上报给消费端</li></ul></li></ul></li></ul></li><li><strong>消费端：</strong> 选择日志消费端<ul><li><p><strong>Kafka：</strong></p><ul><li><strong>访问地址：</strong> kafka ip 和端口</li><li><strong>主题（Topic）：</strong> kafka topic 名</li></ul></li><li><p><strong>Elasticsearch：</strong></p><blockquote><p>注意：当前只支持未开启用户登录认证的 ES 集群</p></blockquote><ul><li><strong>Elasticsearch地址：</strong> ES 地址，如：<a href=http://190.0.0.1:200/>http://190.0.0.1:200</a></li><li><strong>索引：</strong> ES索引，最长60个字符，只能包含小写字母、数字及分隔符("-"、"_"、"+")，且必须以小写字母开头</li></ul></li></ul></li><li>单击【完成】按钮</li></ul><h3 id=指定容器运行后的日志目录>指定容器运行后的日志目录</h3><p>LogAgent 除了支持日志规则的创建，也支持指定容器运行后的日志目录，可实现日志文件展示和下载。</p><blockquote><p>前提：需要在创建负载时挂载数据卷，并指定日志目</p></blockquote><p><img src=../../../../../images/image%20%28102%29.png alt></p><p>创建负载以后，在<code>/data/logdir</code>目录下的所有文件可以展示并下载，不仅是日志文件，例如我们在容器的<code>/data/logdir</code>下新建一个名为<code>a.log</code>的文件，如果有内容的话，也可以在这里展示与下载</p><p><img src=../../../../../images/image%20%2886%29.png alt></p></div><div class=td-content style=page-break-before:always><h1 id=pg-771091872cb56b9e533c1ead93c239a3>4.2.8.3 - 审计记录</h1><div class=lead>审计记录</div><h2 id=简介>简介</h2><p>TKEStack 集群审计是基于 <a href=https://kubernetes.io/docs/tasks/debug-application-cluster/audit>Kubernetes Audit</a> 对 kube-apiserver 产生的可配置策略的 JSON 结构日志的记录存储及检索功能。本功能记录了对 kube-apiserver 的访问事件，会按顺序记录每个用户、管理员或系统组件影响集群的活动。</p><h3 id=功能优势>功能优势</h3><p>集群审计功能提供了区别于 metrics 的另一种集群观测维度。开启 TKEStack 集群审计后，<strong>会在集群里的 tke 命名空间下生成 tke-audit-api 的 Deployment</strong>，Kubernetes 可以记录每一次对集群操作的审计日志。每一条审计日志是一个 JSON 格式的结构化记录，包括元数据（metadata）、请求内容（requestObject）和响应内容（responseObject）三个部分。其中元数据（包含了请求的上下文信息，例如谁发起的请求、从哪里发起的、访问的 URI 等信息）一定会存在，请求和响应内容是否存在取决于审计级别。通过日志可以了解到以下内容：</p><ul><li>集群里发生的活动</li><li>活动的发生时间及发生对象。</li><li>活动的触发时间、触发位置及观察点</li><li>活动的结果以及后续处理行为</li></ul><h3 id=阅读审计日志>阅读审计日志</h3><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>{
  &#34;kind&#34;:&#34;Event&#34;,
  &#34;apiVersion&#34;:&#34;audit.k8s.io/v1&#34;,
  &#34;level&#34;:&#34;RequestResponse&#34;,
  &#34;auditID&#34;:0a4376d5-307a-4e16-a049-24e017******,
  &#34;stage&#34;:&#34;ResponseComplete&#34;,
  // 发生了什么
  &#34;requestURI&#34;:&#34;/apis/apps/v1/namespaces/default/deployments&#34;,
  &#34;verb&#34;:&#34;create&#34;,
  // 谁发起的
  &#34;user&#34;:{
    &#34;username&#34;:&#34;admin&#34;,
      &#34;uid&#34;:&#34;admin&#34;,
      &#34;groups&#34;:[
        &#34;system:masters&#34;,
        &#34;system:authenticated&#34;
      ]
  },
  // 从哪里发起
  &#34;sourceIPs&#34;:[
    &#34;10.0.6.68&#34;
  ],
  &#34;userAgent&#34;:&#34;kubectl/v1.16.3 (linux/amd64) kubernetes/ald64d8&#34;,
  // 发生了什么
  &#34;objectRef&#34;:{
    &#34;resource&#34;:&#34;deployments&#34;,
    &#34;namespace&#34;:&#34;default&#34;,
    &#34;name&#34;:&#34;nginx-deployment&#34;,
    &#34;apiGroup&#34;:&#34;apps&#34;,
    &#34;apiVersion&#34;:&#34;v1&#34;
  },
  // 结果是什么
  &#34;responseStatus&#34;:{
    &#34;metadata&#34;:{
    },
    &#34;code&#34;:201
  },
  // 请求及返回具体信息
  &#34;requestObject&#34;:Object{...},
  &#34;responseObject&#34;:Object{...},
  // 什么时候开始/结束
  &#34;requestReceivedTimestamp&#34;:&#34;2020-04-10T10:47:34.315746Z&#34;,
  &#34;stageTimestamp&#34;:&#34;2020-04-10T10:47:34.328942Z&#34;,
  // 请求被接收/拒绝的原因是什么
  &#34;annotations&#34;:{
    &#34;authorization.k8s.io/decision&#34;:&#34;allow&#34;,
    &#34;authorization.k8s.io/reason&#34;:&#34;&#34;
  }
}
</code></pre></div><h2 id=前提条件>前提条件</h2><blockquote><p>在 <a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/installation/installation-procedures.md>Installer 安装页面</a>的控制台安装的第5步中，如下图所示，已经开启平台审计功能，并配置好 ElasticSearch：</p></blockquote><h2 id=查看审计>查看审计</h2><ol><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择 【运维中心】->【审计记录】，查看审计列表：</li></ol><p><img src=../../../../../images/image%20%2821%29.png alt></p><h2 id=参考>参考</h2><p>TKEStack 关于审计的相关配置：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text># kube-apiserver 地址：/etc/kubernetes/manifests/kube-apiserver.yaml

--audit-policy-file=/etc/kubernetes/audit-policy.yaml # 审计策略
--audit-webhook-config-file=/etc/kubernetes/audit-api-client-config.yaml # 指定 Webhook backend 的配置文件

# 获取 TKEStack 审计组件的详细信息
kubectl describe deploy -ntke tke-audit-api 

# 获取 TKEStack 审计的相关配置
kubectl describe cm -ntke tke-audit-api 
</code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-4fbbc556a6db65b71e6c43d79c98e91f>4.2.8.4 - 事件持久化</h1><div class=lead>事件持久化</div><h2 id=persistentevent>PersistentEvent</h2><h3 id=persistentevent-介绍>PersistentEvent 介绍</h3><p>Kubernetes Events 包括了 Kuberntes 集群的运行和各类资源的调度情况，对维护人员日常观察资源的变更以及定位问题均有帮助。TKEStack 支持为您的所有集群配置事件持久化功能，开启本功能后，会将您的集群事件实时导出到 ElasticSearch 的指定索引。</p><h4 id=persistentevent-使用场景>PersistentEvent 使用场景</h4><p>Kubernetes 事件是集群内部资源生命周期、资源调度、异常告警等情况产生的记录，可以通过事件深入了解集群内部发生的事情，例如调度程序做出的决策或者某些pod从节点中被逐出的原因。</p><p>kubernetes 默认仅提供保留一个小时的 kubernetes 事件到集群的 ETCD 里。 PersistentEvent 提供了将 Kubernetes 事件持久化存储的前置功能，允许您通过PersistentEvent 将集群内事件导出到您自有的存储端。</p><h4 id=persistentevent-限制条件>PersistentEvent 限制条件</h4><ol><li><strong>注意：当前只支持版本号为5的 ElasticSearch，且未开启 ElasticSearch 集群的用户登录认证</strong></li><li>安装 PersistentEvent 将占用集群0.2核 CPU,100MB 内存的资源</li><li>仅在1.8版本以上的 kubernetes 集群支持</li></ol><h4 id=部署在集群内kubernetes对象>部署在集群内kubernetes对象</h4><p>在集群内部署PersistentEvent Add-on , 将在集群内部署以下kubernetes对象</p><table><thead><tr><th style=text-align:left>kubernetes对象名称</th><th style=text-align:left>类型</th><th style=text-align:left>默认占用资源</th><th style=text-align:left>所属Namespaces</th></tr></thead><tbody><tr><td style=text-align:left>tke-persistent-event</td><td style=text-align:left>deployment</td><td style=text-align:left>0.2核CPU,100MB内存</td><td style=text-align:left>kube-system</td></tr></tbody></table><h3 id=persistentevent-使用方法>PersistentEvent 使用方法</h3><h4 id=在-扩展组件-里使用>在 扩展组件 里使用</h4><ol><li><p>登录 TKEStack</p></li><li><p>切换至【平台管理】控制台，选择 【扩展组件】，选择需要安装事件持久化组件的集群，安装 PersistentEvent 组件，注意安装 PersistentEvent 时需要在页面下方指定 ElasticSearch 的地址和索引</p><blockquote><p>注意：当前只支持版本号为5，且未开启用户登录认证的 ES 集群</p></blockquote></li></ol><h4 id=在-运维中心-里使用>在 运维中心 里使用</h4><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择 【运维中心】->【事件持久化】，查看事件持久化列表</li><li>单击列表最右侧【设置】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%28114%29.png alt></p><ul><li>在“设置事件持久化”页面填写持久化信息<ul><li><p><strong>事件持久化存储：</strong> 是否进行持久化存储</p><blockquote><p>注意：当前只支持版本号为5，且未开启用户登录认证的 ES 集群</p></blockquote></li><li><p><strong>Elasticsearch地址：</strong> ES 地址，如：<a href=http://190.0.0.1:200/>http://190.0.0.1:200</a></p></li><li><p><strong>索引：</strong> ES索引，最长60个字符，只能包含小写字母、数字及分隔符("-"、"_"、"+")，且必须以小写字母开头</p></li></ul></li><li>单击【完成】按钮</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-dd936ac0eac7e736303553035fa56805>4.3 - 业务管理控制台</h1><div class=lead>业务管理控制台</div><h1 id=业务管理控制台>业务管理控制台</h1></div><div class=td-content><h1 id=pg-402ac28c5481bba81202ae278bdded53>4.3.1 - 应用管理</h1><div class=lead>应用管理</div><h1 id=应用管理>应用管理</h1></div><div class=td-content><h1 id=pg-4e15f7e3621280c263719d94afc30139>4.3.1.1 - 命名空间</h1><div class=lead>命名空间</div><p>Namespaces 是 Kubernetes 在同一个集群中进行逻辑环境划分的对象， 您可以通过 Namespaces 进行管理多个团队多个项目的划分。在 Namespaces 下，Kubernetes 对象的名称必须唯一。您可以通过资源配额进行可用资源的分配，还可以进行不同 Namespaces 网络的访问控制。</p><h2 id=使用方法>使用方法</h2><ul><li>通过 TKEStack 控制台使用：TKEStack 控制台提供 Namespaces 的增删改查功能。<ul><li>【业务管理】平台下不支持对命名空间的直接操作，需在【平台管理】下<a href=../../../platform-console/business-mgmt>【业务管理】</a>中指定业务通过“创建业务下的命名空间”来实现。</li></ul></li><li>通过 Kubectl 使用：更多详情可查看 <a href=https://kubernetes.io/docs/tasks/administer-cluster/namespaces/>Kubernetes 官网文档</a>。</li></ul><h2 id=相关知识>相关知识</h2><h3 id=通过-resourcequota-设置-namespaces-资源的使用配额>通过 ResourceQuota 设置 Namespaces 资源的使用配额</h3><p>一个命名空间下可以拥有多个 ResourceQuota 资源，每个 ResourceQuota 可以设置每个 Namespace 资源的使用约束。可以设置 Namespaces 资源的使用约束如下：</p><ul><li>计算资源的配额，例如 CPU、内存。</li><li>存储资源的配额，例如请求存储的总存储。</li><li>Kubernetes 对象的计数，例如 Deployment 个数配额。</li></ul><p>不同的 Kubernetes 版本，ResourceQuota 支持的配额设置略有差异，更多详情可查看 <a href=https://kubernetes.io/docs/concepts/policy/resource-quotas/>Kubernetes ResourceQuota 官方文档</a>。 ResourceQuota 的示例如下所示：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#204a87;font-weight:700>apiVersion</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>v1</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>kind</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ResourceQuota</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>metadata</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>object-counts</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>namespace</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>default</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>spec</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>hard</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>configmaps</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;10&#34;</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#8f5902;font-style:italic>## 最多10个 ConfigMap</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>replicationcontrollers</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;20&#34;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>## 最多20个 replicationcontroller</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>secrets</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;10&#34;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>## 最多10个 secret</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>services</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;10&#34;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>## 最多10个 service</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>services.loadbalancers</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;2&#34;</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#8f5902;font-style:italic>## 最多2个 Loadbanlacer 模式的 service</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>cpu</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;1000&#34;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>## 该 Namespaces 下最多使用1000个 CPU 的资源</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>memory</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>200Gi</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>## 该 Namespaces 下最多使用200Gi的内存</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-581be5ed4a9d7b276c4f2421596a48bb>4.3.1.2 - 工作负载</h1><div class=lead>工作负载</div><h1 id=工作负载>工作负载</h1></div><div class=td-content><h1 id=pg-283c1811e1a2396cc1491fc9f195b181>4.3.1.2.1 - Deployment</h1><div class=lead>Deployment</div><p>Deployment 声明了 Pod 的模板和控制 Pod 的运行策略，适用于部署无状态的应用程序。您可以根据业务需求，对 Deployment 中运行的 Pod 的副本数、调度策略、更新策略等进行声明。</p><h2 id=deployment-控制台操作指引>Deployment 控制台操作指引</h2><h3 id=创建-deployment>创建 Deployment</h3><ul><li>登录TKEStack，切换到【业务管理】控制台，选择左侧导航栏中的【应用管理】。</li><li>选择需要创建Deployment的【业务】下相应的【命名空间】，展开【工作负载】下拉项，进入【Deployment】管理页面。如下图所示：</li></ul><p><img src=../../../../../../images/image%20%2843%29.png alt></p><ul><li>单击【新建】，进入 “新建Workload” 页面。根据实际需求，设置 Deployment 参数。关键参数信息如下，其中必填项为<strong>工作负载名</strong>、<strong>实例内容器的名称和镜像</strong>：<ul><li><strong>工作负载名</strong>：输入自定义名称。</li><li><strong>标签</strong>：给工作负载添加标签</li><li><strong>命名空间</strong>：根据实际需求进行选择。</li><li><strong>类型</strong>：选择【Deployment（可扩展的部署 Pod）】。</li><li><strong>数据卷</strong>：根据需求，为负载添加数据卷为容器提供存，目前支持临时路径、主机路径、云硬盘数据卷、文件存储NFS、配置文件、PVC，还需挂载到容器的指定路径中</li><li><strong>临时目录</strong>：主机上的一个临时目录，生命周期和Pod一致</li><li><strong>主机路径</strong>：主机上的真实路径，可以重复使用，不会随Pod一起销毁</li><li><strong>NFS盘</strong>：挂载外部NFS到Pod，用户需要指定相应NFS地址，格式：127.0.0.1:/data</li><li><strong>ConfigMap</strong>：用户在业务Namespace下创建的<a href=../../pei-zhi-guan-li/configmap>ConfigMap</a></li><li><strong>Secret</strong>：用户在业务namespace下创建的<a href=../../pei-zhi-guan-li/secret>Secret</a></li><li><strong>PVC</strong>：用户在业务namespace下创建的<a href=../../cun-chu/pv-he-pvc>PVC</a></li><li><strong>实例内容器</strong>：根据实际需求，为 Deployment 的一个 Pod 设置一个或多个不同的容器。</li></ul></li></ul><p><img src=../../../../../../images/image%20%28136%29.png alt></p><ul><li><strong>名称</strong>：自定义</li><li><strong>镜像</strong>：根据实际需求进行选择<ul><li><p><strong>镜像版本（Tag）</strong>：根据实际需求进行填写，不填默认为<code>latest</code></p></li><li><p><strong>CPU/内存限制</strong>：可根据 <a href=https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/>Kubernetes 资源限制</a> 进行设置 CPU 和内存的限制范围，提高业务的健壮性（<strong>建议使用默认值</strong>）</p></li><li><p><strong>GPU限制</strong>：如容器内需要使用GPU，此处填GPU需求</p></li><li><p><strong>环境变量</strong>：用于设置容器内的变量，变量名只能包含大小写字母、数字及下划线，并且不能以数字开头</p></li><li><p><strong>新增变量</strong>：自己设定变量键值对</p></li><li><p><strong>引用ConfigMap/Secret</strong>：引用已有键值对</p></li><li><p><strong>高级设置</strong>：可设置 “<strong>工作目录</strong>”、“<strong>运行命令</strong>”、“<strong>运行参数</strong>”、“<strong>镜像更新策略</strong>”、“<strong>容器健康检查</strong>”和“<strong>特权级</strong>”等参数。这里介绍一下镜像更新策略。</p></li><li><p><strong>镜像更新策略</strong>：提供以下3种策略，请按需选择</p><p>若不设置镜像拉取策略，当镜像版本为空或 <code>latest</code> 时，使用 Always 策略，否则使用 IfNotPresent 策略</p><ul><li><strong>Always</strong>：总是从远程拉取该镜像</li><li><strong>IfNotPresent</strong>：默认使用本地镜像，若本地无该镜像则远程拉取该镜像</li><li><strong>Never</strong>：只使用本地镜像，若本地没有该镜像将报异常</li></ul></li></ul></li><li><strong>实例数量</strong>：根据实际需求选择调节方式，设置实例数量。</li></ul><p><img src=../../../../../../images/image%20%2846%29.png alt></p><ul><li><strong>手动调节</strong>：直接设定实例个数</li><li><strong>自动调节</strong>：根据设定的触发条件自动调节实例个数，目前支持根据CPU、内存利用率和利用量出入带宽等调节实例个数</li><li><strong>定时调节</strong>：根据Crontab 语法周期性设置实例个数</li><li><strong>imagePullSecrets</strong>：镜像拉取密钥，用于拉取用户的私有镜像</li><li><strong>节点调度策略</strong>：根据配置的调度规则，将Pod调度到预期的节点。支持指定节点调度和条件选择调度</li><li><strong>注释（Annotations）</strong>：给Deployment添加相应Annotation，如用户信息等</li><li><strong>网络模式</strong>：选择Pod网络模式<ul><li><strong>OverLay（虚拟网络）</strong>：基于 IPIP 和 Host Gateway 的 Overlay 网络方案</li><li><strong>FloatingIP（浮动 IP）</strong>：支持容器、物理机和虚拟机在同一个扁平面中直接通过IP进行通信的 Underlay 网络方案。提供了 IP 漂移能力，支持 Pod 重启或迁移时 IP 不变</li><li><strong>NAT（端口映射）</strong>：Kubernetes 原生 NAT 网络方案</li><li><strong>Host（主机网络）</strong>：Kubernetes 原生 Host 网络方案</li></ul></li><li><strong>Service</strong>：勾选【启用】按钮，配置负载端口访问</li></ul><p><img src=../../../../../../images/image%20%2866%29.png alt></p><ul><li><p><strong>服务访问方式</strong>：选择是【仅在集群内部访问】该负载还是集群外部通过【主机端口访问】该负载</p><ul><li><strong>仅在集群内访问</strong>：使用 Service 的 ClusterIP 模式，自动分配 Service 网段中的 IP，用于集群内访问。数据库类等服务如 MySQL 可以选择集群内访问，以保证服务网络隔离</li><li><strong>主机端口访问</strong>：提供一个主机端口映射到容器的访问方式，支持 TCP、UDP、Ingress。可用于业务定制上层 LB 转发到 Node</li><li><strong>Headless Service</strong>：不创建用于集群内访问的ClusterIP，访问Service名称时返回后端Pods IP地址，用于适配自有的服务发现机制。解析域名时返回相应 Pod IP 而不是 Cluster IP</li></ul></li><li><p><strong>端口映射</strong>：输入负载要暴露的端口并指定通信协议类型（<strong>容器和服务端口建议都使用80</strong>）</p></li><li><p><strong>Session Affinity:</strong> 点击【显示高级设置】出现，会话保持，设置会话保持后，会根据请求IP把请求转发给这个IP之前访问过的Pod。默认None，按需使用</p></li><li><p>单击【创建Workload】，完成创建。如下图所示：</p><p>当“运行/期望Pod数量”相等时，即表示 Deployment 下的所有 Pod 已创建完成。</p></li></ul><p><img src=../../../../../../images/workLoad.png alt></p><h3 id=更新-deployment>更新 Deployment</h3><h4 id=更新-yaml>更新 YAML</h4><ul><li>登录TKEStack，切换到【业务管理】控制台，选择左侧导航栏中的【应用管理】。</li><li>选择需要更新的【业务】下相应的【命名空间】，展开【工作负载】列表，进入【Deployment】管理页面。如下图所示：</li></ul><p><img src=../../../../../../images/deployment.png alt></p><ul><li>在需要更新 YAML 的 Deployment 行中，单击【更多】>【编辑YAML】，进入“更新 Deployment” 页面。如下图所示：</li></ul><p><img src=../../../../../../images/updateYaml.png alt></p><ul><li>在 “更新Deployment” 页面，编辑 YAML，单击【完成】，即可更新 YAML。如下图所示：</li></ul><p><img src=../../../../../../images/editYaml.png alt=&#x66F4;&#x65B0;YAML></p><h3 id=回滚-deployment>回滚 Deployment</h3><ul><li>登录 TKEStack，切换到【业务管理】控制台，选择左侧导航栏中的【应用管理】。</li><li>选择要变更的业务下相应的【命名空间】，展开【工作负载】列表，进入【 Deployment】 管理页面，点击进入要回滚的 Deployment 详情页面，单击【修订历史】。如下图所示：</li></ul><p><img src=../../../../../../images/podManagement.png alt></p><ul><li>选择合适版本进行回顾。</li><li>在弹出的 “回滚资源” 提示框中，单击【确定】即可完成回滚。</li></ul><h3 id=调整-pod-数量>调整 Pod 数量</h3><ul><li>登录 TKEStack，切换到【业务管理】控制台，选择左侧导航栏中的【应用管理】。</li><li>选择要变更的业务下相应的命名空间，展开工作负载列表，进入 Deployment 管理页面。</li><li>点击 Deployment 列表操作栏的【更新实例数量】按钮。如下图所示：</li></ul><p><img src=../../../../../../images/updateNum.png alt></p><ul><li>根据实际需求调整 Pod 数量，单击【更新实例数目】即可完成调整。</li></ul><h3 id=查看deployment监控数据>查看Deployment监控数据</h3><ol><li>登录 TKEStack，切换到【业务管理】控制台，选择左侧导航栏中的【应用管理】，。</li><li>选择要变更的业务下相应的【命名空间】，点击进入 【Deployment】 管理页面。</li><li>单击【监控】按钮，在弹出的工作负载监控页面选择工作负载查看监控信息。如下图所示：</li></ol><p><img src=../../../../../../images/workloaddata.png alt></p><h2 id=kubectl-操作-deployment-指引>Kubectl 操作 Deployment 指引</h2><h3 id=yaml-示例>YAML 示例</h3><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#204a87;font-weight:700>apiVersion</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>apps/v1beta2</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>kind</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Deployment</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>metadata</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx-deployment</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>namespace</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>default</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>labels</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>app</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx-deployment</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>spec</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>replicas</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>selector</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>matchLabels</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>app</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx-deployment</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>template</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>metadata</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>labels</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>app</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx-deployment</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>spec</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>containers</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span>- <span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>image</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx:latest</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>ports</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span>- <span style=color:#204a87;font-weight:700>containerPort</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>80</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><ul><li><strong>kind</strong>：标识 Deployment 资源类型。</li><li><strong>metadata</strong>：Deployment 的名称、Namespace、Label 等基本信息。</li><li><strong>metadata.annotations</strong>：对 Deployment 的额外说明，可通过该参数设置腾讯云 TKE 的额外增强能力。</li><li><strong>spec.replicas</strong>：Deployment 管理的 Pod 数量。</li><li><strong>spec.selector</strong>：Deployment 管理 Seletor 选中的 Pod 的 Label。</li><li><strong>spec.template</strong>：Deployment 管理的 Pod 的详细模板配置。</li></ul><p>更多参数详情可查看 <a href=https://kubernetes.io/docs/concepts/workloads/controllers/deployment/>Kubernetes Deployment 官方文档</a>。</p><h3 id=kubectl-创建-deployment>Kubectl 创建 Deployment</h3><ol><li><p>参考 <a href=../development#YAMLSample>YAML 示例</a>，准备 Deployment YAML 文件。</p></li><li><p>安装 Kubectl，并连接集群。操作详情请参考 <a href=https://cloud.tencent.com/document/product/457/8438>通过 Kubectl 连接集群</a>。</p></li><li><p>执行以下命令，创建 Deployment YAML 文件。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl create -f 【Deployment YAML 文件名称】
</code></pre></div><p>例如，创建一个文件名为 nginx.Yaml 的 Deployment YAML 文件，则执行以下命令：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl create -f nginx.yaml
</code></pre></div></li><li><p>执行以下命令，验证创建是否成功。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl get deployments
</code></pre></div><p>返回类似以下信息，即表示创建成功。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>NAME             DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
first-workload   1         1         1            0           6h
ng               1         1         1            1           42m
</code></pre></div></li></ol><h3 id=kubectl-更新-deployment>Kubectl 更新 Deployment</h3><p>通过 Kubectl 更新 Deployment 有以下三种方法。其中，<a href=../development#%E6%96%B9%E6%B3%95%E4%B8%80>方法一</a> 和 <a href=../development#%E6%96%B9%E6%B3%95%E4%BA%8C>方法二</a> 均支持 <strong>Recreate</strong> 和 <strong>RollingUpdate</strong> 两种更新策略。</p><ul><li>Recreate 更新策略为先销毁全部 Pod，再重新创建 Deployment。</li><li>RollingUpdate 更新策略为滚动更新策略，逐个更新 Deployment 的 Pod。RollingUpdate 还支持暂停、设置更新时间间隔等。</li></ul><h4 id=方法一>方法一</h4><p>执行以下命令，更新 Deployment。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl edit  deployment/【name】
</code></pre></div><p>此方法适用于简单的调试验证，不建议在生产环境中直接使用。您可以通过此方法更新任意的 Deployment 参数。</p><h4 id=方法二>方法二</h4><p>执行以下命令，更新指定容器的镜像。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl set image deployment/【name】 【containerName】=【image:tag】
</code></pre></div><p>建议保持 Deployment 的其他参数不变，业务更新时，仅更新容器镜像。</p><h4 id=方法三>方法三</h4><p>执行以下命令，滚动更新指定资源。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl rolling-update 【NAME】 -f 【FILE】
</code></pre></div><p>更多滚动更新可参见 <a href=https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/>滚动更新说明</a>。</p><h3 id=kubectl-回滚-deployment>Kubectl 回滚 Deployment</h3><ol><li><p>执行以下命令，查看 Deployment 的更新历史。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl rollout history deployment/【name】
</code></pre></div></li><li><p>执行以下命令，查看指定版本详情。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl rollout history deployment/【name】 --revision=【REVISION】
</code></pre></div></li><li><p>执行以下命令，回滚到前一个版本。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl rollout undo deployment/【name】
</code></pre></div><p>如需指定回滚版本号，可执行以下命令。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl rollout undo deployment/【name】 --to-revision=【REVISION】
</code></pre></div></li></ol><h3 id=kubectl-调整-pod-数量>Kubectl 调整 Pod 数量</h3><h4 id=手动更新-pod-数量>手动更新 Pod 数量</h4><p>执行以下命令，手动更新 Pod 数量。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl scale deployment 【NAME】 --replicas=【NUMBER】
</code></pre></div><h4 id=自动更新-pod-数量>自动更新 Pod 数量</h4><p><strong>前提条件</strong></p><p>开启集群中的 HPA 功能。TKE 创建的集群默认开启 HPA 功能。</p><p><strong>操作步骤</strong></p><p>执行以下命令，设置 Deployment 的自动扩缩容。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl autoscale deployment 【NAME】 --min=10 --max=15 --cpu-percent=80
</code></pre></div><h3 id=kubectl-删除-deployment>Kubectl 删除 Deployment</h3><p>执行以下命令，删除 Deployment。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl delete deployment 【NAME】
</code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-66e0e51b3c40c38b649dd3f8274df967>4.3.1.2.2 - StatefulSet</h1><div class=lead>StatefulSet</div><p>StatefulSet 主要用于管理<strong>有状态</strong>的应用，创建的 Pod 拥有根据规范创建的持久型标识符。Pod 迁移或销毁重启后，<strong>标识符仍会保留</strong>。 在需要持久化存储时，您可以通过标识符对存储卷进行一一对应。如果应用程序不需要持久的标识符，建议您使用 Deployment 部署应用程序。</p><h2 id=statefulset-控制台操作指引>StatefulSet 控制台操作指引</h2><h3 id=创建-statefulset>创建 StatefulSet</h3><ul><li>登录TKEStack，切换到【业务管理】控制台，选择左侧导航栏中的【应用管理】。</li><li>选择需要创建StatefulSet的【业务】下相应的【命名空间】，展开【工作负载】下拉项，进入【StatefulSet】管理页面。如下图所示：</li></ul><p><img src=../../../../../../images/StatefulSet.png alt></p><ul><li><p>单击【新建】，进入 “新建Workload” 页面。根据实际需求，设置 StatefulSet 参数。</p></li><li><p>关键参数信息如下，其中必填项为<strong>工作负载名</strong>、<strong>实例内容器的名称和镜像</strong>：</p><ul><li><strong>工作负载名</strong>：输入自定义名称。</li><li><strong>标签</strong>：给工作负载添加标签</li><li><strong>命名空间</strong>：根据实际需求进行选择。</li><li><strong>类型</strong>：选择【StatefulSet】。</li><li><strong>数据卷</strong>：根据需求，为负载添加数据卷为容器提供存，目前支持临时路径、主机路径、云硬盘数据卷、文件存储NFS、配置文件、PVC，还需挂载到容器的指定路径中</li><li><strong>临时目录</strong>：主机上的一个临时目录，生命周期和Pod一致</li><li><strong>主机路径</strong>：主机上的真实路径，可以重复使用，不会随Pod一起销毁</li><li><strong>NFS盘</strong>：挂载外部NFS到Pod，用户需要指定相应NFS地址，格式：127.0.0.1:/data</li><li><strong>ConfigMap</strong>：用户在业务Namespace下创建的<a href=../../pei-zhi-guan-li/configmap>ConfigMap</a></li><li><strong>Secret</strong>：用户在业务namespace下创建的<a href=../../pei-zhi-guan-li/secret>Secret</a></li><li><strong>PVC</strong>：用户在业务namespace下创建的<a href=../../cun-chu/pv-he-pvc>PVC</a></li><li><strong>实例内容器</strong>：根据实际需求，为 StatefulSet的一个 Pod 设置一个或多个不同的容器。</li><li><strong>名称</strong>：自定义</li><li><strong>镜像</strong>：根据实际需求进行选择<ul><li><strong>镜像版本（Tag）</strong>：根据实际需求进行填写，不填默认为<code>latest</code></li><li><strong>CPU/内存限制</strong>：可根据 <a href=https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/>Kubernetes 资源限制</a> 进行设置 CPU 和内存的限制范围，提高业务的健壮性（<strong>建议使用默认值</strong>）</li><li><strong>GPU限制</strong>：如容器内需要使用GPU，此处填GPU需求</li><li><strong>环境变量</strong>：用于设置容器内的变量，变量名只能包含大小写字母、数字及下划线，并且不能以数字开头<ul><li><strong>新增变量</strong>：自己设定变量键值对</li><li><strong>引用ConfigMap/Secret</strong>：引用已有键值对</li></ul></li><li><strong>高级设置</strong>：可设置 “<strong>工作目录</strong>”、“<strong>运行命令</strong>”、“<strong>运行参数</strong>”、“<strong>镜像更新策略</strong>”、“<strong>容器健康检查</strong>”和“<strong>特权级</strong>”等参数。这里介绍一下镜像更新策略。<ul><li><p><strong>镜像更新策略</strong>：提供以下3种策略，请按需选择</p><p>若不设置镜像拉取策略，当镜像版本为空或 <code>latest</code> 时，使用 Always 策略，否则使用 IfNotPresent 策略</p><ul><li><strong>Always</strong>：总是从远程拉取该镜像</li><li><strong>IfNotPresent</strong>：默认使用本地镜像，若本地无该镜像则远程拉取该镜像</li><li><strong>Never</strong>：只使用本地镜像，若本地没有该镜像将报异常</li></ul></li></ul></li></ul></li><li><strong>实例数量</strong>：根据实际需求选择调节方式，设置实例数量。</li><li><strong>手动调节</strong>：直接设定实例个数</li><li><strong>自动调节</strong>：根据设定的触发条件自动调节实例个数，目前支持根据CPU、内存利用率和利用量出入带宽等调节实例个数</li><li><strong>定时调节</strong>：根据Crontab 语法周期性设置实例个数</li><li><strong>imagePullSecrets</strong>：镜像拉取密钥，用于拉取用户的私有镜像</li><li><strong>节点调度策略</strong>：根据配置的调度规则，将Pod调度到预期的节点。支持指定节点调度和条件选择调度</li><li><strong>注释（Annotations）</strong>：给StatefulSet添加相应Annotation，如用户信息等</li><li><strong>网络模式</strong>：选择Pod网络模式</li><li><strong>OverLay（虚拟网络）</strong>：基于 IPIP 和 Host Gateway 的 Overlay 网络方案</li><li><strong>FloatingIP（浮动 IP）</strong>：支持容器、物理机和虚拟机在同一个扁平面中直接通过IP进行通信的 Underlay 网络方案。提供了 IP 漂移能力，支持 Pod 重启或迁移时 IP 不变</li><li><strong>NAT（端口映射）</strong>：Kubernetes 原生 NAT 网络方案</li><li><strong>Host（主机网络）</strong>：Kubernetes 原生 Host 网络方案</li><li><strong>Service</strong>：勾选【启用】按钮，配置负载端口访问</li></ul><blockquote><p>注意：如果不勾选【启用】则不会创建Service</p></blockquote></li><li><p><strong>服务访问方式</strong>：选择是【仅在集群内部访问】该负载还是集群外部通过【主机端口访问】该负载</p><ul><li><strong>仅在集群内访问</strong>：使用 Service 的 ClusterIP 模式，自动分配 Service 网段中的 IP，用于集群内访问。数据库类等服务如 MySQL 可以选择集群内访问，以保证服务网络隔离</li><li><strong>主机端口访问</strong>：提供一个主机端口映射到容器的访问方式，支持 TCP、UDP、Ingress。可用于业务定制上层 LB 转发到 Node</li><li><strong>Headless Service</strong>：不创建用于集群内访问的ClusterIP，访问Service名称时返回后端Pods IP地址，用于适配自有的服务发现机制。解析域名时返回相应 Pod IP 而不是 Cluster IP</li></ul></li><li><p><strong>端口映射</strong>：输入负载要暴露的端口并指定通信协议类型（<strong>容器和服务端口建议都使用80</strong>）</p></li><li><p><strong>Session Affinity:</strong> 点击【显示高级设置】出现，会话保持，设置会话保持后，会根据请求IP把请求转发给这个IP之前访问过的Pod。默认None，按需使用</p></li><li><p>单击【创建Workload】，完成创建。</p></li></ul><h3 id=更新-statefulset>更新 StatefulSet</h3><h4 id=更新-yaml>更新 YAML</h4><ol><li>登录TKEStack，切换到【业务管理】控制台，选择左侧导航栏中的【应用管理】。</li><li>选择需要更新的【业务】下相应的【命名空间】，展开【工作负载】列表，进入【StatefulSet】管理页面。</li><li>在需要更新 YAML 的 StatefulSet 行中，选择【更多】>【编辑YAML】，进入更新 StatefulSet 页面。</li><li>在 “更新StatefulSet” 页面编辑 YAML，并单击【完成】即可更新 YAML。</li></ol><h2 id=kubectl-操作-statefulset-指引>Kubectl 操作 StatefulSet 指引</h2><h3 id=yaml-示例>YAML 示例</h3><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#204a87;font-weight:700>apiVersion</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>v1</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>kind</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Service </span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>## 创建一个 Headless Service，用于控制网络域</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>metadata</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>namespace</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>default</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>labels</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>app</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>spec</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>ports</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span>- <span style=color:#204a87;font-weight:700>port</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>80</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>web</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>clusterIP</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>None</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>selector</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>app</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>---</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>apiVersion</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>apps/v1</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>kind</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>StatefulSet</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>### 创建一个 Nginx的StatefulSet</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>metadata</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>web</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>namespace</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>default</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>spec</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>selector</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>matchLabels</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>app</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>serviceName</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;nginx&#34;</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>replicas</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic># by default is 1</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>template</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>metadata</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>labels</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>app</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>spec</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>terminationGracePeriodSeconds</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>containers</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span>- <span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>image</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx:latest</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>ports</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span>- <span style=color:#204a87;font-weight:700>containerPort</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>80</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>          </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>web</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>volumeMounts</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span>- <span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>www</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>          </span><span style=color:#204a87;font-weight:700>mountPath</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>/usr/share/nginx/html</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>volumeClaimTemplates</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span>- <span style=color:#204a87;font-weight:700>metadata</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>www</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>spec</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>accessModes</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>[</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;ReadWriteOnce&#34;</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>]</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>storageClassName</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;cbs&#34;</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>resources</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>requests</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>          </span><span style=color:#204a87;font-weight:700>storage</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>10Gi</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><ul><li><strong>kind</strong>：标识 StatefulSet 资源类型。</li><li><strong>metadata</strong>：StatefulSet 的名称、Label等基本信息。</li><li><strong>metadata.annotations</strong>：对 StatefulSet 的额外说明，可通过该参数设置腾讯云 TKE 的额外增强能力。</li><li><strong>spec.template</strong>：StatefulSet 管理的 Pod 的详细模板配置。</li><li><strong>spec.volumeClaimTemplates</strong>：提供创建 PVC&PV 的模板。</li></ul><p>更多参数详情可查看 <a href=https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/>Kubernetes StatefulSet 官方文档</a>。</p><h3 id=创建-statefulset-1>创建 StatefulSet</h3><ol><li><p>参考 <a href=../statefulset#YAMLSample>YAML 示例</a>，准备 StatefulSet YAML 文件。</p></li><li><p>安装 Kubectl，并连接集群。操作详情请参考 <a href=https://cloud.tencent.com/document/product/457/8438>通过 Kubectl 连接集群</a>。</p></li><li><p>执行以下命令，创建 StatefulSet YAML 文件。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl create -f StatefulSet YAML 文件名称
</code></pre></div><p>例如，创建一个文件名为 web.yaml 的 StatefulSet YAML 文件，则执行以下命令：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl create -f web.yaml
</code></pre></div></li><li><p>执行以下命令，验证创建是否成功。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl get StatefulSet
</code></pre></div><p>返回类似以下信息，即表示创建成功。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>NAME      DESIRED   CURRENT   AGE
test      1         1         10s
</code></pre></div></li></ol><h3 id=更新-statefulset-1>更新 StatefulSet</h3><p>执行以下命令，查看 StatefulSet 的更新策略类型。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl get ds/&lt;daemonset-name&gt; -o go-template=&#39;{{.spec.updateStrategy.type}}{{&#34;\n&#34;}}&#39;
</code></pre></div><p>StatefulSet 有以下两种更新策略类型：</p><ul><li>OnDelete：默认更新策略。该更新策略在更新 StatefulSet 后，需手动删除旧的 StatefulSet Pod 才会创建新的 StatefulSet Pod。</li><li>RollingUpdate：支持 Kubernetes 1.7或更高版本。该更新策略在更新 StatefulSet 模板后，旧的 StatefulSet Pod 将被终止，并且以滚动更新方式创建新的 StatefulSet Pod（Kubernetes 1.7或更高版本）。</li></ul><h4 id=方法一>方法一</h4><p>执行以下命令，更新 StatefulSet。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl edit StatefulSet/[name]
</code></pre></div><p>此方法适用于简单的调试验证，不建议在生产环境中直接使用。您可以通过此方法更新任意的 StatefulSet 参数。</p><h4 id=方法二>方法二</h4><p>执行以下命令，更新指定容器的镜像。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl patch statefulset &lt;NAME&gt; --type=&#39;json&#39; -p=&#39;[{&#34;op&#34;: &#34;replace&#34;, &#34;path&#34;: &#34;/spec/template/spec/containers/0/image&#34;, &#34;value&#34;:&#34;&lt;newImage&gt;&#34;}]&#39;
</code></pre></div><p>建议保持 StatefulSet 的其他参数不变，业务更新时，仅更新容器镜像。</p><p>如果更新的 StatefulSet 是滚动更新方式的策略，可执行以下命令查看更新状态：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl rollout status sts/&lt;StatefulSet-name&gt;
</code></pre></div><h3 id=删除-statefulset>删除 StatefulSet</h3><p>执行以下命令，删除 StatefulSet。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl delete  StatefulSet [NAME] --cascade=false
</code></pre></div><p>&ndash;cascade=false 参数表示 Kubernetes 仅删除 StatefulSet，且不删除任何 Pod。如需删除 Pod，则执行以下命令：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl delete  StatefulSet [NAME]
</code></pre></div><p>更多 StatefulSet 相关操作可查看 <a href=https://kubernetes.io/docs/tutorials/stateful-application/basic-stateful-set/#scaling-a-statefulset>Kubernetes官方指引</a>。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-1b3dcfb569c1dd11bfb7abfcf169910a>4.3.1.2.3 - DaomonSet</h1><div class=lead>DaomonSet</div><h2 id=daomonset>DaomonSet</h2><p>DaemonSet 主要用于部署常驻集群内的后台程序，例如节点的日志采集。DaemonSet 保证在所有或部分节点上均运行指定的 Pod。 新节点添加到集群内时，也会有自动部署 Pod；节点被移除集群后，Pod 将自动回收。</p><h2 id=调度说明>调度说明</h2><p>若配置了 Pod 的 nodeSelector 或 affinity 参数，DaemonSet 管理的 Pod 将按照指定的调度规则调度。若未配置 Pod 的 nodeSelector 或 affinity 参数，则将在所有的节点上部署 Pod。</p><h2 id=daemonset-控制台操作指引>DaemonSet 控制台操作指引</h2><h3 id=创建-daemonset>创建 DaemonSet</h3><ul><li>登录TKEStack，切换到【业务管理】控制台，选择左侧导航栏中的【应用管理】。</li><li>选择需要创建DaemonSet的【业务】下相应的【命名空间】，展开【工作负载】下拉项，进入【DaemonSet】管理页面。如下图所示：</li></ul><p><img src=../../../../../../images/DaemonSet.png alt></p><ul><li><p>单击【新建】，进入 “新建Workload” 页面。</p><p>根据实际需求，设置 DaemonSet 参数。关键参数信息如下：</p><ul><li><strong>工作负载名</strong>：输入自定义名称。</li><li><strong>标签</strong>：给工作负载添加标签</li><li><strong>命名空间</strong>：根据实际需求进行选择。</li><li><strong>类型</strong>：选择【DaemonSet】。</li><li><strong>数据卷</strong>：根据需求，为负载添加数据卷为容器提供存，目前支持临时路径、主机路径、云硬盘数据卷、文件存储NFS、配置文件、PVC，还需挂载到容器的指定路径中</li><li><strong>临时目录</strong>：主机上的一个临时目录，生命周期和Pod一致</li><li><strong>主机路径</strong>：主机上的真实路径，可以重复使用，不会随Pod一起销毁</li><li><strong>NFS盘</strong>：挂载外部NFS到Pod，用户需要指定相应NFS地址，格式：127.0.0.1:/data</li><li><strong>ConfigMap</strong>：用户在业务Namespace下创建的<a href=../../pei-zhi-guan-li/configmap>ConfigMap</a></li><li><strong>Secret</strong>：用户在业务namespace下创建的<a href=../../pei-zhi-guan-li/secret>Secret</a></li><li><strong>PVC</strong>：用户在业务namespace下创建的<a href=../../cun-chu/pv-he-pvc>PVC</a></li><li><strong>实例内容器</strong>：根据实际需求，为 DaemonSet 的一个 Pod 设置一个或多个不同的容器。<ul><li><strong>名称</strong>：自定义。</li><li><strong>镜像</strong>：根据实际需求进行选择。</li><li><strong>镜像版本（Tag）</strong>：根据实际需求进行填写。</li><li><strong>CPU/内存限制</strong>：可根据 <a href=https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/>Kubernetes 资源限制</a> 进行设置 CPU 和内存的限制范围，提高业务的健壮性。</li><li><strong>GPU限制</strong>：如容器内需要使用GPU，此处填GPU需求</li><li><strong>环境变量</strong>：用于设置容器内的变量，变量名只能包含大小写字母、数字及下划线，并且不能以数字开头<ul><li><p><strong>新增变量</strong>：自己设定变量键值对</p></li><li><p><strong>引用ConfigMap/Secret</strong>：引用已有键值对</p></li><li><p><strong>高级设置</strong>：可设置 “<strong>工作目录</strong>”、“<strong>运行命令</strong>”、“<strong>运行参数</strong>”、“<strong>镜像更新策略</strong>”、“<strong>容器健康检查</strong>”和“<strong>特权级</strong>”等参数。这里介绍一下镜像更新策略。</p></li><li><p><strong>镜像更新策略</strong>：提供以下3种策略，请按需选择</p><p>若不设置镜像拉取策略，当镜像版本为空或 <code>latest</code> 时，使用 Always 策略，否则使用 IfNotPresent 策略</p><ul><li><strong>Always</strong>：总是从远程拉取该镜像</li><li><strong>IfNotPresent</strong>：默认使用本地镜像，若本地无该镜像则远程拉取该镜像</li><li><strong>Never</strong>：只使用本地镜像，若本地没有该镜像将报异常</li></ul></li></ul></li></ul></li><li><strong>imagePullSecrets</strong>：镜像拉取密钥，用于拉取用户的私有镜像</li><li><strong>节点调度策略</strong>：根据配置的调度规则，将Pod调度到预期的节点。支持指定节点调度和条件选择调度</li><li><strong>注释（Annotations）</strong>：给DaemonSet添加相应Annotation，如用户信息等</li><li><strong>网络模式</strong>：选择Pod网络模式<ul><li><strong>OverLay（虚拟网络）</strong>：基于 IPIP 和 Host Gateway 的 Overlay 网络方案</li><li><strong>FloatingIP（浮动 IP）</strong>：支持容器、物理机和虚拟机在同一个扁平面中直接通过IP进行通信的 Underlay 网络方案。提供了 IP 漂移能力，支持 Pod 重启或迁移时 IP 不变</li><li><strong>NAT（端口映射）</strong>：Kubernetes 原生 NAT 网络方案</li><li><strong>Host（主机网络）</strong>：Kubernetes 原生 Host 网络方案</li></ul></li></ul></li><li><p>单击【创建Workload】，完成创建。</p></li></ul><h3 id=更新-daemonset>更新 DaemonSet</h3><h4 id=更新-yaml>更新 YAML</h4><ol><li>登录TKEStack，切换到【业务管理】控制台，选择左侧导航栏中的【应用管理】。</li><li>选择需要更新的【业务】下相应的命名空间，展开【工作负载】列表，进入【DaemonSet】管理页面。</li><li>在需要更新 YAML 的 DaemonSet 行中，选择【更多】>【编辑YAML】，进入更新 DaemonSet 页面。</li><li>在 “更新DaemonSet” 页面编辑 YAML，并单击【完成】即可更新 YAML。</li></ol><h2 id=kubectl-操作-daemonset-指引>Kubectl 操作 DaemonSet 指引</h2><h3 id=yaml-示例>YAML 示例</h3><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#204a87;font-weight:700>apiVersion</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>apps/v1</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>kind</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>DaemonSet</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>metadata</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>fluentd-elasticsearch</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>namespace</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>kube-system</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>labels</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>k8s-app</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>fluentd-logging</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>spec</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>selector</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>matchLabels</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>fluentd-elasticsearch</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>template</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>metadata</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>labels</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>fluentd-elasticsearch</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>spec</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>tolerations</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span>- <span style=color:#204a87;font-weight:700>key</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>node-role.kubernetes.io/master</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>effect</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>NoSchedule</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>containers</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span>- <span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>fluentd-elasticsearch</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>image</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>k8s.gcr.io/fluentd-elasticsearch:1.20</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>resources</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>          </span><span style=color:#204a87;font-weight:700>limits</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>            </span><span style=color:#204a87;font-weight:700>memory</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>200Mi</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>          </span><span style=color:#204a87;font-weight:700>requests</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>            </span><span style=color:#204a87;font-weight:700>cpu</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>100m</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>            </span><span style=color:#204a87;font-weight:700>memory</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>200Mi</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>volumeMounts</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span>- <span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>varlog</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>          </span><span style=color:#204a87;font-weight:700>mountPath</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>/var/log</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span>- <span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>varlibdockercontainers</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>          </span><span style=color:#204a87;font-weight:700>mountPath</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>/var/lib/docker/containers</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>          </span><span style=color:#204a87;font-weight:700>readOnly</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>true</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>terminationGracePeriodSeconds</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>30</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>volumes</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span>- <span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>varlog</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>hostPath</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>          </span><span style=color:#204a87;font-weight:700>path</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>/var/log</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span>- <span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>varlibdockercontainers</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>hostPath</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>          </span><span style=color:#204a87;font-weight:700>path</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>/var/lib/docker/containers</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><blockquote><p>!以上 YAML 示例引用于 <code>https://kubernetes.io/docs/concepts/workloads/controllers/daemonset</code>， 创建时可能存在容器镜像拉取不成功的情况，仅用于本文介绍 DaemonSet 的组成。</p></blockquote><ul><li><strong>kind</strong>：标识 DaemonSet 资源类型。</li><li><strong>metadata</strong>：DaemonSet 的名称、Label等基本信息。</li><li><strong>metadata.annotations</strong>：DaemonSet 的额外说明，可通过该参数设置腾讯云 TKE 的额外增强能力。</li><li><strong>spec.template</strong>：DaemonSet 管理的 Pod 的详细模板配置。</li></ul><p>更多可查看 <a href=https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/>Kubernetes DaemonSet 官方文档</a>。</p><h3 id=kubectl-创建-daemonset>Kubectl 创建 DaemonSet</h3><ol><li><p>参考 <a href=../daomonset#YAMLSample>YAML 示例</a>，准备 DaemonSet YAML 文件。</p></li><li><p>安装 Kubectl，并连接集群。操作详情请参考 <a href=https://cloud.tencent.com/document/product/457/8438>通过 Kubectl 连接集群</a>。</p></li><li><p>执行以下命令，创建 DaemonSet YAML 文件。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl create -f DaemonSet YAML 文件名称
</code></pre></div><p>例如，创建一个文件名为 fluentd-elasticsearch.yaml 的 DaemonSet YAML 文件，则执行以下命令：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl create -f fluentd-elasticsearch.yaml
</code></pre></div></li><li><p>执行以下命令，验证创建是否成功。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl get DaemonSet
</code></pre></div><p>返回类似以下信息，即表示创建成功。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>NAME       DESIRED   CURRENT   READY     UP-TO-DATE   AVAILABLE   NODE SELECTOR       AGE
frontend   0         0         0         0            0           app=frontend-node   16d
</code></pre></div></li></ol><h3 id=kubectl-更新-daemonset>Kubectl 更新 DaemonSet</h3><p>执行以下命令，查看 DaemonSet 的更新策略类型。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl get ds/&lt;daemonset-name&gt; -o go-template=&#39;{{.spec.updateStrategy.type}}{{&#34;\n&#34;}}&#39;
</code></pre></div><p>DaemonSet 有以下两种更新策略类型：</p><ul><li>OnDelete：默认更新策略。该更新策略在更新 DaemonSet 后，需手动删除旧的 DaemonSet Pod 才会创建新的DaemonSet Pod。</li><li>RollingUpdate：支持 Kubernetes 1.6或更高版本。该更新策略在更新 DaemonSet 模板后，旧的 DaemonSet Pod 将被终止，并且以滚动更新方式创建新的 DaemonSet Pod。</li></ul><h4 id=方法一>方法一</h4><p>执行以下命令，更新 DaemonSet。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl edit DaemonSet/[name]
</code></pre></div><p>此方法适用于简单的调试验证，不建议在生产环境中直接使用。您可以通过此方法更新任意的 DaemonSet 参数。</p><h4 id=方法二>方法二</h4><p>执行以下命令，更新指定容器的镜像。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl set image ds/[daemonset-name][container-name]=[container-new-image]
</code></pre></div><p>建议保持 DaemonSet 的其他参数不变，业务更新时，仅更新容器镜像。</p><h3 id=kubectl-回滚-daemonset>Kubectl 回滚 DaemonSet</h3><ol><li><p>执行以下命令，查看 DaemonSet 的更新历史。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl rollout history daemonset /[name]
</code></pre></div></li><li><p>执行以下命令，查看指定版本详情。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl rollout history daemonset /[name] --revision=[REVISION]
</code></pre></div></li><li><p>执行以下命令，回滚到前一个版本。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl rollout undo daemonset /[name]
</code></pre></div><p>如需指定回滚版本号，可执行以下命令。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl rollout undo daemonset /[name] --to-revision=[REVISION]
</code></pre></div></li></ol><h3 id=kubectl-删除-daemonset>Kubectl 删除 DaemonSet</h3><p>执行以下命令，删除 DaemonSet。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl delete  DaemonSet [NAME]
</code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-ca95b6ae5265a54d37b41c7ecda011ff>4.3.1.2.4 - Job</h1><div class=lead>Job</div><h2 id=job>Job</h2><p>Job 控制器会创建 1-N 个 Pod，这些 Pod 按照运行规则运行，直至运行结束。Job 可用于批量计算、数据分析等场景。通过设置重复执行次数、并行度、重启策略等满足业务述求。 Job 执行完成后，不再创建新的 Pod，也不会删除 Pod，您可在 “日志” 中查看已完成的 Pod 的日志。如果您删除了 Job，Job 创建的 Pod 也会同时被删除，将查看不到该 Job 创建的 Pod 的日志。</p><h2 id=job-控制台操作指引>Job 控制台操作指引</h2><h3 id=创建-job>创建 Job</h3><ol><li><p>登录TKEStack，切换到【业务管理】控制台，选择左侧导航栏中的【应用管理】。</p></li><li><p>选择需要创建 Job 的【业务】下相应的【命名空间】，展开【工作负载】下拉项，进入【 Job】 管理页面。</p></li><li><p>单击【新建】，进入 “新建Workload” 页面。如下图所示：</p><p><img src=../../../../../../images/NewJob.png alt=&#x65B0;&#x5EFA;Workload></p></li><li><p>根据实际需求，设置 Job 参数。关键参数信息如下：</p><ul><li><p><strong>工作负载名</strong>：输入自定义名称。</p></li><li><p><strong>标签</strong>：给工作负载添加标签</p></li><li><p><strong>命名空间</strong>：根据实际需求进行选择。</p></li><li><p><strong>类型</strong>：选择【Job（单次任务）】。</p></li><li><p><strong>Job设置</strong></p><ul><li><strong>重复执行次数</strong>：Job 管理的 Pod 需要重复执行的次数。</li><li><strong>并行度</strong>：Job 并行执行的 Pod 数量。</li><li><strong>失败重启策略</strong>：Pod下容器异常推出后的重启策略。<ul><li><strong>Never</strong>：不重启容器，直至 Pod 下所有容器退出。</li><li><strong>OnFailure</strong>：Pod 继续运行，容器将重新启动。</li></ul></li></ul></li><li><p><strong>数据卷</strong>：根据需求，为负载添加数据卷为容器提供存，目前支持临时路径、主机路径、云硬盘数据卷、文件存储NFS、配置文件、PVC，还需挂载到容器的指定路径中</p></li><li><p><strong>临时目录</strong>：主机上的一个临时目录，生命周期和Pod一致</p></li><li><p><strong>主机路径</strong>：主机上的真实路径，可以重复使用，不会随Pod一起销毁</p></li><li><p><strong>NFS盘</strong>：挂载外部 NFS 到 Pod，用户需要指定相应 NFS 地址，格式：127.0.0.1:/data</p></li><li><p><strong>ConfigMap</strong>：用户在业务Namespace下创建的<a href=../../pei-zhi-guan-li/configmap>ConfigMap</a></p></li><li><p><strong>Secret</strong>：用户在业务namespace下创建的<a href=../../pei-zhi-guan-li/secret>Secret</a></p></li><li><p><strong>PVC</strong>：用户在业务namespace下创建的<a href=../../cun-chu/pv-he-pvc>PVC</a></p></li><li><p><strong>实例内容器</strong>：根据实际需求，为 Job 的一个 Pod 设置一个或多个不同的容器。</p><ul><li><strong>名称</strong>：自定义。</li><li><strong>镜像</strong>：根据实际需求进行选择。</li><li><strong>镜像版本（Tag）</strong>：根据实际需求进行填写。</li><li><strong>CPU/内存限制</strong>：可根据 <a href=https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/>Kubernetes 资源限制</a> 进行设置 CPU 和内存的限制范围，提高业务的健壮性。</li><li><strong>GPU限制</strong>：如容器内需要使用GPU，此处填GPU需求</li><li><strong>环境变量</strong>：用于设置容器内的变量，变量名只能包含大小写字母、数字及下划线，并且不能以数字开头<ul><li><p><strong>新增变量</strong>：自己设定变量键值对</p></li><li><p><strong>引用ConfigMap/Secret</strong>：引用已有键值对</p></li><li><p><strong>高级设置</strong>：可设置 “<strong>工作目录</strong>”、“<strong>运行命令</strong>”、“<strong>运行参数</strong>”、“<strong>镜像更新策略</strong>”、“<strong>容器健康检查</strong>”和“<strong>特权级</strong>”等参数。这里介绍一下镜像更新策略。</p></li><li><p><strong>镜像更新策略</strong>：提供以下3种策略，请按需选择</p><p>若不设置镜像拉取策略，当镜像版本为空或 <code>latest</code> 时，使用 Always 策略，否则使用 IfNotPresent 策略</p><ul><li><strong>Always</strong>：总是从远程拉取该镜像</li><li><strong>IfNotPresent</strong>：默认使用本地镜像，若本地无该镜像则远程拉取该镜像</li><li><strong>Never</strong>：只使用本地镜像，若本地没有该镜像将报异常</li></ul></li></ul></li></ul></li><li><p><strong>imagePullSecrets</strong>：镜像拉取密钥，用于拉取用户的私有镜像</p></li><li><p><strong>节点调度策略</strong>：根据配置的调度规则，将Pod调度到预期的节点。支持指定节点调度和条件选择调度</p></li><li><p><strong>注释（Annotations）</strong>：给Pod添加相应Annotation，如用户信息等</p></li><li><p><strong>网络模式</strong>：选择Pod网络模式</p><ul><li><strong>OverLay（虚拟网络）</strong>：基于 IPIP 和 Host Gateway 的 Overlay 网络方案</li><li><strong>FloatingIP（浮动 IP）</strong>：支持容器、物理机和虚拟机在同一个扁平面中直接通过IP进行通信的 Underlay 网络方案。提供了 IP 漂移能力，支持 Pod 重启或迁移时 IP 不变</li><li><strong>NAT（端口映射）</strong>：Kubernetes 原生 NAT 网络方案</li><li><strong>Host（主机网络）</strong>：Kubernetes 原生 Host 网络方案</li></ul></li><li><p>单击【创建Workload】，完成创建。</p><p><strong>查看 Job 状态</strong></p></li></ul></li><li><p>登录 TKEStack，切换到【业务管理】控制台，选择左侧导航栏中的【应用管理】。</p></li><li><p>选择需要创建 Job 的业务下相应的【命名空间】，展开【工作负载】下拉项，进入【 Job 】管理页面。</p></li><li><p>单击需要查看状态的【 Job 名称】，即可查看 Job 详情。</p></li></ol><h3 id=删除-job>删除 Job</h3><p>Job 执行完成后，不再创建新的 Pod，也不会删除 Pod，您可在【业务管理】控制台下的【应用管理】下的 【日志】 中查看已完成的 Pod 的日志。如果您删除了 Job，Job 创建的 Pod 也会同时被删除，将查看不到该 Job 创建的 Pod 的日志。</p><h2 id=kubectl-操作-job-指引>Kubectl 操作 Job 指引</h2><h3 id=yaml-示例>YAML 示例</h3><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#204a87;font-weight:700>apiVersion</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>batch/v1</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>kind</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Job</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>metadata</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>pi</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>spec</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>completions</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>parallelism</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>template</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>spec</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>containers</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span>- <span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>pi</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>image</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>perl</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>command</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>[</span><span style=color:#4e9a06>&#34;perl&#34;</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#4e9a06>&#34;-Mbignum=bpi&#34;</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;-wle&#34;</span><span style=color:#000;font-weight:700>,</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;print bpi(2000)&#34;</span><span style=color:#000;font-weight:700>]</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>restartPolicy</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Never</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>backoffLimit</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><ul><li>kind：标识 Job 资源类型。</li><li>metadata：Job 的名称、Label等基本信息。</li><li>metadata.annotations：Job 的额外说明，可通过该参数设置腾讯云 TKE 的额外增强能力。</li><li>spec.completions：Job 管理的 Pod 重复执行次数。</li><li>spec.parallelism：Job 并行执行的 Pod 数。</li><li>spec.template：Job 管理的 Pod 的详细模板配置。</li></ul><h3 id=创建-job-1>创建 Job</h3><ol><li><p>参考 <a href=../job#YAMLSample>YAML 示例</a>，准备 Job YAML 文件。</p></li><li><p>安装 Kubectl，并连接集群。操作详情请参考 <a href=https://cloud.tencent.com/document/product/457/8438>通过 Kubectl 连接集群</a>。</p></li><li><p>创建 Job YAML 文件。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl create -f Job YAML 文件名称
</code></pre></div><p>例如，创建一个文件名为 pi.yaml 的 Job YAML 文件，则执行以下命令：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl create -f pi.yaml
</code></pre></div></li><li><p>执行以下命令，验证创建是否成功。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl get job
</code></pre></div><p>返回类似以下信息，即表示创建成功。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>NAME      DESIRED   SUCCESSFUL   AGE
job       1         0            1m
</code></pre></div></li></ol><h3 id=删除-job-1>删除 Job</h3><p>执行以下命令，删除 Job。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl delete job [NAME]
</code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-1a3700b417d983d15f664242eb43d9d2>4.3.1.2.5 - CronJob</h1><div class=lead>CronJob</div><h2 id=cronjob>CronJob</h2><p>一个 CronJob 对象类似于 crontab（cron table）文件中的一行。它根据指定的预定计划周期性地运行一个 Job，格式可以参考 Cron。 Cron 格式说明如下：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text># 文件格式说明
#  ——分钟（0 - 59）
# |  ——小时（0 - 23）
# | |  ——日（1 - 31）
# | | |  ——月（1 - 12）
# | | | |  ——星期（0 - 6）
# | | | | |
# * * * * *
</code></pre></div><h2 id=cronjob-控制台操作指引>CronJob 控制台操作指引</h2><h3 id=创建-cronjob>创建 CronJob</h3><ol><li><p>登录TKEStack，切换到【业务管理】控制台，选择左侧导航栏中的【应用管理】。</p></li><li><p>选择需要创建CronJob的业务下相应的【命名空间】，展开【工作负载】下拉项，进入【CronJob】管理页面。如下图所示：</p><p><img src=../../../../../../images/CronJobNew.png alt></p></li><li><p>单击【创建】按钮，进入 新建Workload页面。</p></li><li><p>根据实际需求，设置 CronJob 参数。关键参数信息如下：</p><ul><li><strong>工作负载名</strong>：输入自定义名称。</li><li><strong>标签</strong>：给工作负载添加标签</li><li><strong>命名空间</strong>：根据实际需求进行选择。</li><li><strong>类型</strong>：选择【CronJob（按照Cron的计划定时运行）】。</li><li><strong>执行策略</strong>：根据 Cron 格式设置任务的定期执行策略。</li><li><strong>Job设置</strong><ul><li><strong>重复执行次数</strong>：Job 管理的 Pod 需要重复执行的次数。</li><li><strong>并行度</strong>：Job 并行执行的 Pod 数量。</li><li><strong>失败重启策略</strong>：Pod下容器异常推出后的重启策略。<ul><li><strong>Never</strong>：不重启容器，直至 Pod 下所有容器退出。</li><li><strong>OnFailure</strong>：Pod 继续运行，容器将重新启动。</li></ul></li></ul></li><li><strong>数据卷</strong>：根据需求，为负载添加数据卷为容器提供存，目前支持临时路径、主机路径、云硬盘数据卷、文件存储NFS、配置文件、PVC，还需挂载到容器的指定路径中</li><li><strong>临时目录</strong>：主机上的一个临时目录，生命周期和Pod一致</li><li><strong>主机路径</strong>：主机上的真实路径，可以重复使用，不会随Pod一起销毁</li><li><strong>NFS盘</strong>：挂载外部NFS到Pod，用户需要指定相应NFS地址，格式：127.0.0.1:/data</li><li><strong>ConfigMap</strong>：用户在业务Namespace下创建的<a href=../../pei-zhi-guan-li/configmap>ConfigMap</a></li><li><strong>Secret</strong>：用户在业务namespace下创建的<a href=../../pei-zhi-guan-li/secret>Secret</a></li><li><strong>PVC</strong>：用户在业务namespace下创建的<a href=../../cun-chu/pv-he-pvc>PVC</a></li><li><strong>实例内容器</strong>：根据实际需求，为 CronJob 的一个 Pod 设置一个或多个不同的容器。<ul><li><strong>名称</strong>：自定义。</li><li><strong>镜像</strong>：根据实际需求进行选择。</li><li><strong>镜像版本（Tag）</strong>：根据实际需求进行填写。</li><li><strong>CPU/内存限制</strong>：可根据 <a href=https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/>Kubernetes 资源限制</a> 进行设置 CPU 和内存的限制范围，提高业务的健壮性。</li><li><strong>GPU限制</strong>：如容器内需要使用GPU，此处填GPU需求</li><li><strong>环境变量</strong>：用于设置容器内的变量，变量名只能包含大小写字母、数字及下划线，并且不能以数字开头<ul><li><p><strong>新增变量</strong>：自己设定变量键值对</p></li><li><p><strong>引用ConfigMap/Secret</strong>：引用已有键值对</p></li><li><p><strong>高级设置</strong>：可设置 “<strong>工作目录</strong>”、“<strong>运行命令</strong>”、“<strong>运行参数</strong>”、“<strong>镜像更新策略</strong>”、“<strong>容器健康检查</strong>”和“<strong>特权级</strong>”等参数。这里介绍一下镜像更新策略。</p></li><li><p><strong>镜像更新策略</strong>：提供以下3种策略，请按需选择</p><p>若不设置镜像拉取策略，当镜像版本为空或 <code>latest</code> 时，使用 Always 策略，否则使用 IfNotPresent 策略</p><ul><li><strong>Always</strong>：总是从远程拉取该镜像</li><li><strong>IfNotPresent</strong>：默认使用本地镜像，若本地无该镜像则远程拉取该镜像</li><li><strong>Never</strong>：只使用本地镜像，若本地没有该镜像将报异常</li></ul></li></ul></li></ul></li><li><strong>imagePullSecrets</strong>：镜像拉取密钥，用于拉取用户的私有镜像</li><li><strong>节点调度策略</strong>：根据配置的调度规则，将Pod调度到预期的节点。支持指定节点调度和条件选择调度</li><li><strong>注释（Annotations）</strong>：给Pod添加相应Annotation，如用户信息等</li><li><strong>网络模式</strong>：选择Pod网络模式<ul><li><strong>OverLay（虚拟网络）</strong>：基于 IPIP 和 Host Gateway 的 Overlay 网络方案</li><li><strong>FloatingIP（浮动 IP）</strong>：支持容器、物理机和虚拟机在同一个扁平面中直接通过IP进行通信的 Underlay 网络方案。提供了 IP 漂移能力，支持 Pod 重启或迁移时 IP 不变</li><li><strong>NAT（端口映射）</strong>：Kubernetes 原生 NAT 网络方案</li><li><strong>Host（主机网络）</strong>：Kubernetes 原生 Host 网络方案</li></ul></li></ul></li><li><p>单击【创建Workload】，完成创建。</p></li></ol><h3 id=查看-cronjob-状态>查看 CronJob 状态</h3><ol><li>登录TKEStack，切换到【业务管理】控制台，选择左侧导航栏中的【应用管理】。</li><li>选择需要创建CronJob的【业务】下相应的【命名空间】，展开【工作负载】下拉项，进入【CronJob】管理页面。</li><li>单击需要查看状态的 CronJob 名称，即可查看 CronJob 详情。</li></ol><h2 id=kubectl-操作-cronjob-指引>Kubectl 操作 CronJob 指引</h2><h3 id=yaml-示例>YAML 示例</h3><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#204a87;font-weight:700>apiVersion</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>batch/v1beta1</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>kind</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>CronJob</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>metadata</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>hello</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>spec</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>schedule</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;*/1 * * * *&#34;</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>jobTemplate</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>spec</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>template</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>spec</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>          </span><span style=color:#204a87;font-weight:700>containers</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>          </span>- <span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>hello</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>            </span><span style=color:#204a87;font-weight:700>image</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>busybox</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>            </span><span style=color:#204a87;font-weight:700>args</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>            </span>- <span style=color:#000>/bin/sh</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>            </span>- -<span style=color:#000>c</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>            </span>- <span style=color:#000>date; echo Hello from the Kubernetes cluster</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>          </span><span style=color:#204a87;font-weight:700>restartPolicy</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>OnFailure</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><ul><li>kind：标识 CronJob 资源类型。</li><li>metadata：CronJob 的名称、Label等基本信息。</li><li>metadata.annotations：对 CronJob 的额外说明，可通过该参数设置腾讯云 TKE 的额外增强能力。</li><li>spec.schedule：CronJob 执行的 Cron 的策略。</li><li>spec.jobTemplate：Cron 执行的 Job 模板。</li></ul><h3 id=创建-cronjob-1>创建 CronJob</h3><h4 id=方法一>方法一</h4><ol><li><p>参考 <a href=../cronjob#YAMLSample>YAML 示例</a>，准备 CronJob YAML 文件。</p></li><li><p>安装 Kubectl，并连接集群。操作详情请参考 <a href=https://cloud.tencent.com/document/product/457/8438>通过 Kubectl 连接集群</a>。</p></li><li><p>执行以下命令，创建 CronJob YAML 文件。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl create -f CronJob YAML 文件名称
</code></pre></div><p>例如，创建一个文件名为 cronjob.yaml 的 CronJob YAML 文件，则执行以下命令：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl create -f cronjob.yaml
</code></pre></div></li></ol><h4 id=方法二>方法二</h4><ol><li><p>通过执行<code>kubectl run</code>命令，快速创建一个 CronJob。</p><p>例如，快速创建一个不需要写完整配置信息的 CronJob，则执行以下命令：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl run hello --schedule=&#34;*/1 * * * *&#34; --restart=OnFailure --image=busybox -- /bin/sh -c &#34;date; echo Hello&#34;
</code></pre></div></li><li><p>执行以下命令，验证创建是否成功。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl get cronjob [NAME]
</code></pre></div><p>返回类似以下信息，即表示创建成功。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>NAME      SCHEDULE    SUSPEND   ACTIVE    LAST SCHEDULE   AGE
cronjob   * * * * *   False     0         &lt;none&gt;          15s
</code></pre></div></li></ol><h3 id=删除-cronjob>删除 CronJob</h3><blockquote><p>!</p><ul><li>执行此删除命令前，请确认是否存在正在创建的 Job，否则执行该命令将终止正在创建的 Job。</li><li>执行此删除命令时，已创建的 Job 和已完成的 Job 均不会被终止或删除。</li><li>如需删除 CronJob 创建的 Job，请手动删除。</li></ul><p>执行以下命令，删除 CronJob。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl delete cronjob [NAME]
</code></pre></div></blockquote></div><div class=td-content style=page-break-before:always><h1 id=pg-942ebebfffb5f5766dfc29a3ff54c3d9>4.3.1.2.6 - TApp</h1><div class=lead>TApp</div><h2 id=tapp>TApp</h2><p>Kubernetes现有应用类型（如：Deployment、StatefulSet等）无法满足很多非微服务应用的需求，比如：操作（升级、停止等）应用中的指定pod、应用支持多版本的pod。如果要将这些应用改造为适合于这些workload的应用，需要花费很大精力，这将使大多数用户望而却步。</p><p>为解决上述复杂应用管理场景，TKEStack基于Kubernetes CRD开发了一种新的应用类型TAPP，它是一种通用类型的workload，同时支持service和batch类型作业，满足绝大部分应用场景，它能让用户更好的将应用迁移到Kubernetes集群。</p><p>查询<a href=../../../../../key-features/tapp>TApp</a>可查看更多相关信息</p><h2 id=tapp控制台操作指引>TApp控制台操作指引</h2><h3 id=创建-tapp>创建 TApp</h3><blockquote><p>注意：使用前提，在<a href=../../../../platform-console/addon-mgmt/>【扩展组件】</a>安装TApp</p></blockquote><ul><li>登录TKEStack，切换到【业务管理】控制台，选择左侧导航栏中的【应用管理】。</li><li>选择需要创建TApp的【业务】下相应的【命名空间】，展开【工作负载】下拉项，进入【TApp】管理页面。如下图所示：</li></ul><p><img src=../../../../../../images/tapp-1.png alt></p><ul><li><p>单击【新建】，进入 “新建Workload” 页面。根据实际需求，设置 TApp 参数。关键参数信息如下，其中必填项为<strong>工作负载名</strong>、<strong>实例内容器的名称和镜像</strong>：</p><ul><li><strong>工作负载名</strong>：输入自定义名称。</li><li><strong>标签</strong>：给工作负载添加标签</li><li><strong>命名空间</strong>：根据实际需求进行选择。</li><li><strong>类型</strong>：选择【TApp】。</li><li>节点异常策略<ul><li>迁移，调度策略与Deployment一致，Pod会迁移到新的节点</li><li>不迁移，调度策略与StatefulSel一致，异常pod不会被迁移</li></ul></li><li><strong>数据卷</strong>：根据需求，为负载添加数据卷为容器提供存，目前支持临时路径、主机路径、云硬盘数据卷、文件存储NFS、配置文件、PVC，还需挂载到容器的指定路径中</li><li><strong>临时目录</strong>：主机上的一个临时目录，生命周期和Pod一致</li><li><strong>主机路径</strong>：主机上的真实路径，可以重复使用，不会随Pod一起销毁</li><li><strong>NFS盘</strong>：挂载外部NFS到Pod，用户需要指定相应NFS地址，格式：127.0.0.1:/data</li><li><strong>ConfigMap</strong>：用户在业务Namespace下创建的<a href=../../pei-zhi-guan-li/configmap>ConfigMap</a></li><li><strong>Secret</strong>：用户在业务namespace下创建的<a href=../../pei-zhi-guan-li/secret>Secret</a></li><li><strong>PVC</strong>：用户在业务namespace下创建的<a href=../../cun-chu/pv-he-pvc>PVC</a></li><li><strong>实例内容器</strong>：根据实际需求，为 TApp 的一个 Pod 设置一个或多个不同的容器。<ul><li><strong>名称</strong>：自定义</li><li><strong>镜像</strong>：根据实际需求进行选择<ul><li><p><strong>镜像版本（Tag）</strong>：根据实际需求进行填写，不填默认为<code>latest</code></p></li><li><p><strong>CPU/内存限制</strong>：可根据 <a href=https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/>Kubernetes 资源限制</a> 进行设置 CPU 和内存的限制范围，提高业务的健壮性（<strong>建议使用默认值</strong>）</p></li><li><p><strong>GPU限制</strong>：如容器内需要使用GPU，此处填GPU需求</p></li><li><p><strong>环境变量</strong>：用于设置容器内的变量，变量名只能包含大小写字母、数字及下划线，并且不能以数字开头</p></li><li><p><strong>新增变量</strong>：自己设定变量键值对</p></li><li><p><strong>引用ConfigMap/Secret</strong>：引用已有键值对</p></li><li><p><strong>高级设置</strong>：可设置 “<strong>工作目录</strong>”、“<strong>运行命令</strong>”、“<strong>运行参数</strong>”、“<strong>镜像更新策略</strong>”、“<strong>容器健康检查</strong>”和“<strong>特权级</strong>”等参数。这里介绍一下镜像更新策略。</p></li><li><p><strong>镜像更新策略</strong>：提供以下3种策略，请按需选择</p><p>若不设置镜像拉取策略，当镜像版本为空或 <code>latest</code> 时，使用 Always 策略，否则使用 IfNotPresent 策略</p><ul><li><strong>Always</strong>：总是从远程拉取该镜像</li><li><strong>IfNotPresent</strong>：默认使用本地镜像，若本地无该镜像则远程拉取该镜像</li><li><strong>Never</strong>：只使用本地镜像，若本地没有该镜像将报异常</li></ul></li></ul></li></ul></li><li><strong>实例数量</strong>：根据实际需求选择调节方式，设置实例数量。</li><li><strong>手动调节</strong>：直接设定实例个数</li><li><strong>自动调节</strong>：根据设定的触发条件自动调节实例个数，目前支持根据CPU、内存利用率和利用量出入带宽等调节实例个数</li><li><strong>定时调节</strong>：根据Crontab 语法周期性设置实例个数</li><li><strong>imagePullSecrets</strong>：镜像拉取密钥，用于拉取用户的私有镜像</li><li><strong>节点调度策略</strong>：根据配置的调度规则，将Pod调度到预期的节点。支持指定节点调度和条件选择调度</li><li><strong>注释（Annotations）</strong>：给TApp添加相应Annotation，如用户信息等</li><li><strong>网络模式</strong>：选择Pod网络模式<ul><li><strong>OverLay（虚拟网络）</strong>：基于 IPIP 和 Host Gateway 的 Overlay 网络方案</li><li><strong>FloatingIP（浮动 IP）</strong>：支持容器、物理机和虚拟机在同一个扁平面中直接通过IP进行通信的 Underlay 网络方案。提供了 IP 漂移能力，支持 Pod 重启或迁移时 IP 不变</li><li><strong>NAT（端口映射）</strong>：Kubernetes 原生 NAT 网络方案</li><li><strong>Host（主机网络）</strong>：Kubernetes 原生 Host 网络方案</li></ul></li><li><strong>Service</strong>：勾选【启用】按钮，配置负载端口访问</li></ul><blockquote><p>注意：如果不勾选【启用】则不会创建Service</p></blockquote></li><li><p><strong>服务访问方式</strong>：选择是【仅在集群内部访问】该负载还是集群外部通过【主机端口访问】该负载</p><ul><li><strong>仅在集群内访问</strong>：使用 Service 的 ClusterIP 模式，自动分配 Service 网段中的 IP，用于集群内访问。数据库类等服务如 MySQL 可以选择集群内访问，以保证服务网络隔离</li><li><strong>主机端口访问</strong>：提供一个主机端口映射到容器的访问方式，支持 TCP、UDP、Ingress。可用于业务定制上层 LB 转发到 Node</li><li><strong>Headless Service</strong>：不创建用于集群内访问的ClusterIP，访问Service名称时返回后端Pods IP地址，用于适配自有的服务发现机制。解析域名时返回相应 Pod IP 而不是 Cluster IP</li></ul></li><li><p><strong>端口映射</strong>：输入负载要暴露的端口并指定通信协议类型（<strong>容器和服务端口建议都使用80</strong>）</p></li><li><p><strong>Session Affinity:</strong> 点击【显示高级设置】出现，会话保持，设置会话保持后，会根据请求IP把请求转发给这个IP之前访问过的Pod。默认None，按需使用</p></li><li><p>单击【创建Workload】，完成创建。如下图所示：</p><p>当“运行/期望Pod数量”相等时，即表示 TApp 下的所有 Pod 已创建完成。</p></li></ul><p><img src=../../../../../../images/tapp-2.png alt></p><h3 id=更新-tapp>更新 TApp</h3><h4 id=更新-yaml>更新 YAML</h4><ul><li>登录TKEStack，切换到【业务管理】控制台，选择左侧导航栏中的【应用管理】。</li><li>选择需要更新的【业务】下相应的【命名空间】，展开【工作负载】列表，进入【TApp】管理页面。在需要更新 YAML 的 TApp 行中，单击【更多】>【编辑YAML】，进入“更新 TApp” 页面。如下图所示：</li></ul><p><img src=../../../../../../images/tapp-3.png alt></p><ul><li>在 “更新TApp” 页面，编辑 YAML，单击【完成】，即可更新 YAML。如下图所示：</li></ul><p><img src=../../../../../../images/tapp-4.png alt=&#x66F4;&#x65B0;YAML></p><h3 id=调整-pod-数量>调整 Pod 数量</h3><ul><li>登录 TKEStack，切换到【业务管理】控制台，选择左侧导航栏中的【应用管理】。</li><li>选择要变更的业务下相应的命名空间，展开工作负载列表，进入 TApp 管理页面。</li><li>点击 TApp 列表操作栏的【更新实例数量】按钮。如下图所示：</li></ul><p><img src=../../../../../../images/tapp-5.png alt></p><ul><li>根据实际需求调整 Pod 数量，如3，单击页面下方的【更新实例数目】即可完成调整。</li></ul><h3 id=tapp特色功能-指定pod灰度升级>TApp特色功能-指定pod灰度升级</h3><ul><li>登录 TKEStack，切换到【业务管理】控制台，选择左侧导航栏中的【应用管理】。</li><li>选择要变更的业务下相应的【命名空间】，展开【工作负载】列表，进入【 TApp】 管理页面，点击进入要灰度升级的 TApp名称。如下图所示：</li></ul><p><img src=../../../../../../images/tapp-6.png alt></p><ul><li>如下图标签1所示，可选指定需要灰度升级的pod，然后点击下图中标签2 的【灰度升级】即可升级指定pod。</li></ul><p><img src=../../../../../../images/tapp-7.png alt></p><ul><li><p>在弹出的 “回滚资源” 提示框中，单击【确定】即可完成回滚。</p><blockquote><p>注意：此页面同时可完成指定Pod监控和删除</p></blockquote></li></ul><p>查询<a href=../../../../../key-features/tapp>TApp</a>可查看更多相关信息</p></div><div class=td-content style=page-break-before:always><h1 id=pg-8f31787affb2101a550d608ac7166151>4.3.1.2.7 - 工作负载的请求与限制</h1><div class=lead>工作负载的请求与限制</div><h2 id=工作负载的请求与限制>工作负载的请求与限制</h2><p><strong>Request</strong>：容器使用的最小资源需求，作为容器调度时资源分配的判断依赖。只有当节点上可分配资源量 >= 容器资源请求数时才允许将容器调度到该节点。但 Request 参数不限制容器的最大可使用资源值。 <strong>Limit</strong>： 容器能使用的资源最大值。</p><blockquote><p>! 更多 <strong>Limit</strong> 和 <strong>Request</strong> 参数介绍，单击 <a href=https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/>查看详情</a>。</p></blockquote><h2 id=cpu-限制说明>CPU 限制说明</h2><p>CPU 资源允许设置 CPU 请求和 CPU 限制的资源量，以核（U）为单位，允许为小数。</p><blockquote><p>!</p><ul><li>CPU Request 作为调度时的依据，在创建时为该容器在节点上分配 CPU 使用资源，称为 “已分配 CPU” 资源。</li><li>CPU Limit 限制容器 CPU 资源的上限，不设置表示不做限制（CPU Limit >= CPU Request）。</li></ul></blockquote><h2 id=内存限制说明>内存限制说明</h2><p>内存资源只允许限制容器最大可使用内存量。以 MiB 为单位，允许为小数。</p><blockquote><p>!</p><ul><li>内存 Request 作为调度时的依据，在创建时为该容器在节点上分配内存，称为 “已分配内存” 资源。</li><li>内存资源为不可伸缩资源。当节点上所有容器使用内存均超量时，存在 OOM 的风险。因此不设置 Limit 时，默认 Limit = Request，保证容器的正常运作。</li></ul></blockquote><h2 id=cpu-使用量和-cpu-使用率>CPU 使用量和 CPU 使用率</h2><ul><li>CPU 使用量为绝对值，表示实际使用的 CPU 的物理核数，CPU 资源请求和 CPU 资源限制的判断依据都是 CPU 使用量。</li><li>CPU 使用率为相对值，表示 CPU 的使用量与 CPU 单核的比值（或者与节点上总 CPU 核数的比值）。</li></ul><h2 id=使用示例>使用示例</h2><p>一个简单的示例说明 Request 和 Limit 的作用，测试集群包括1个 4U4G 的节点、已经部署的两个 Pod ( Pod1，Pod2 )，每个 Pod 的资源设置为（CPU Requst，CPU Limit，Memory Requst，Memory Limit）=（1U，2U，1G，1G）。（1.0G = 1000MiB） 节点上 CPU 和内存的资源使用情况如下图所示： <img src=https://mc.qcloudimg.com/static/img/b021e644c31ddcacf13930a412c51e5a/image.png alt="Alt text"> 已经分配的 CPU 资源为：1U（分配 Pod1） + 1U（分配 Pod2） = 2U，剩余可以分配的 CPU 资源为2U。 已经分配的内存资源为：1G（分配 Pod1） + 1G（分配 Pod2） = 2G，剩余可以分配的内存资源为2G。 所以该节点可以再部署一个 ( CPU Requst， Memory Requst ) =( 2U，2G )的 Pod 部署，或者部署2个（CPU Requst，Memory Requst） = （1U，1G） 的 Pod 部署。</p><p>在资源限制方面，每个 Pod1 和 Pod2 使用资源的上限为 ( 2U，1G )，即在资源空闲的情况下，Pod 使用 CPU 的量最大能达到2U。</p><h2 id=服务资源限制推荐>服务资源限制推荐</h2><p>CCS 会根据您当前容器镜像的历史负载来推荐 Request 与 Limit 值，使用推荐值会保证您的容器更加平稳的运行，大大减小出现异常的概率。</p><p><strong>推荐算法</strong>： 我们首先会取出过去7天当前容器镜像分钟级别负载，并辅以百分位统计第95%的值来最终确定推荐的 Request，Limit 为 Request 的2倍。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>Request = Percentile(实际负载[7d],0.95)
Limit = Request * 2
</code></pre></div><p>如果当前的样本数量（实际负载）不满足推荐计算的数量要求，我们会相应的扩大样本取值范围，尝试重新计算。例如，去掉镜像 tag，namespace，serviceName 等筛选条件。若经过多次计算后同样未能得到有效值，则推荐值为空。</p><p><strong>推荐值为空</strong>： 在使用过程中，您会发现有部分值暂无推荐的情况，可能由于以下几点造成： 1. 当前数据并不满足计算的需求，我们需要待计算的样本数量（实际负载）大于1440个，即有一天的数据。 2. 推荐值小于您当前容器已经配置的 Request 或者 Limit。</p><blockquote><p>! 1. 由于推荐值是根据历史负载来计算的，原则上，容器镜像运行真实业务的时间越长，推荐的值越准确。 2. 使用推荐值创建服务，可能会因为集群资源不足造成容器无法调度成功。在保存时，须确认当前集群的剩余资源。 3. 推荐值是建议值，您可以根据自己业务的实际情况做相应的调整。</p></blockquote></div><div class=td-content style=page-break-before:always><h1 id=pg-728de0d6037af6e8c4dd3d3cd18a58aa>4.3.1.3 - 服务</h1><div class=lead>服务</div><h1 id=服务>服务</h1></div><div class=td-content><h1 id=pg-c01661de03c27cf20d354588e9284d09>4.3.1.3.1 - Service</h1><div class=lead>Service</div><p>Service 定义访问后端 Pod 的访问方式，并提供固定的虚拟访问 IP。您可以在 Service 中通过设置来访问后端的 Pod，不同访问方式的服务可提供不同网络能力。 腾讯云容器服务（TKE）提供以下四种服务访问方式：</p><table><thead><tr><th style=text-align:left>&#x8BBF;&#x95EE;&#x65B9;&#x5F0F;</th><th style=text-align:left>&#x8BF4;&#x660E;</th></tr></thead><tbody><tr><td style=text-align:left>&#x4EC5;&#x5728;&#x96C6;&#x7FA4;&#x5185;&#x8BBF;&#x95EE;</td><td style=text-align:left><ul><li>&#x4F7F;&#x7528; Service &#x7684; ClusterIP &#x6A21;&#x5F0F;&#xFF0C;&#x81EA;&#x52A8;&#x5206;&#x914D;
Service &#x7F51;&#x6BB5;&#x4E2D;&#x7684; IP&#xFF0C;&#x7528;&#x4E8E;&#x96C6;&#x7FA4;&#x5185;&#x8BBF;&#x95EE;&#x3002;&#x6570;&#x636E;&#x5E93;&#x7C7B;&#x7B49;&#x670D;&#x52A1;&#x5982;
MySQL &#x53EF;&#x4EE5;&#x9009;&#x62E9;&#x96C6;&#x7FA4;&#x5185;&#x8BBF;&#x95EE;&#xFF0C;&#x4EE5;&#x4FDD;&#x8BC1;&#x670D;&#x52A1;&#x7F51;&#x7EDC;&#x9694;&#x79BB;&#x3002;</li><li>&#x521B;&#x5EFA;&#x5B8C;&#x6210;&#x540E;&#x7684;&#x670D;&#x52A1;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;<b>&#x670D;&#x52A1;&#x540D; + &#x670D;&#x52A1;&#x7AEF;&#x53E3;</b>&#x8BBF;&#x95EE;&#x670D;&#x52A1;&#x3002;</li></ul></td></tr><tr><td style=text-align:left>&#x4E3B;&#x673A;&#x7AEF;&#x53E3;&#x8BBF;&#x95EE;</td><td style=text-align:left><ul><li>&#x63D0;&#x4F9B;&#x4E00;&#x4E2A;&#x4E3B;&#x673A;&#x7AEF;&#x53E3;&#x6620;&#x5C04;&#x5230;&#x5BB9;&#x5668;&#x7684;&#x8BBF;&#x95EE;&#x65B9;&#x5F0F;&#xFF0C;&#x652F;&#x6301;
TCP&#x3001;UDP&#x3001;Ingress&#x3002;&#x53EF;&#x7528;&#x4E8E;&#x4E1A;&#x52A1;&#x5B9A;&#x5236;&#x4E0A;&#x5C42;
LB &#x8F6C;&#x53D1;&#x5230; Node&#x3002;</li><li>&#x521B;&#x5EFA;&#x5B8C;&#x6210;&#x540E;&#x7684;&#x670D;&#x52A1;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;<b>&#x4E91;&#x670D;&#x52A1;&#x5668; IP+&#x4E3B;&#x673A;&#x7AEF;&#x53E3;</b>&#x6216;<b>&#x670D;&#x52A1;&#x540D; + &#x670D;&#x52A1;&#x7AEF;&#x53E3;</b>&#x8BBF;&#x95EE;&#x670D;&#x52A1;&#x3002;</li></ul></td></tr></tbody></table><blockquote><p>集群内进行 Service 访问时，建议不要通过负载均衡 IP 进行访问，以避免出现访问不通的情况。</p></blockquote><p>一般情况下，4层负载均衡（LB）会绑定多台 Node 作为 real server（rs） ，使用时需要限制 client 和 rs 不能存在于同一台云服务器上，否则会有一定概率导致报文回环出不去。 当 Pod 去访问 LB 时，Pod 就是源 IP，当其传输到内网时 LB 也不会做 snat 处理将源 IP 转化成 Node IP，那么 LB 收到报文也就不能判断是从哪个 Node 发送的，LB 的避免回环策略也就不会生效，所有的 rs 都可能被转发。当转发到 client 所在的 Node 上时，LB 就无法收到回包，从而导致访问不通。</p><p>集群内访问时，支持Headless Service，解析服务名时直接返回对应Pod IP而不是Cluster IP，可以适配自有的服务发现机制。 两种访问方式均支持Session Affinity，设置会话保持后，会根据请求IP把请求转发给这个IP之前访问过的Pod.</p><h2 id=service-控制台操作指引>Service 控制台操作指引</h2><h3 id=创建-service>创建 Service</h3><ul><li>登录TKEStack，切换到【业务管理】控制台，选择左侧导航栏中的【应用管理】。</li><li>选择需要创建 Service 的【业务】下相应的【命名空间】，展开【服务】列表，进入【Service】管理页面。</li><li>单击【新建】，进入 “新建 Service” 页面。如下图所示：</li></ul><p><img src=../../../../../../images/image%20%28133%29.png alt></p><ul><li>根据实际需求，设置 Service 参数。关键参数信息如下：<ul><li>服务名称：自定义。</li><li>命名空间：根据实际需求进行选择。</li><li>访问设置：请参考 <a href=../service#%E7%AE%80%E4%BB%8B>简介</a> 并根据实际需求进行设置。</li></ul></li><li>单击【创建服务】，完成创建。</li></ul><h3 id=更新-service>更新 Service</h3><h4 id=更新-yaml>更新 YAML</h4><ol><li>登录TKEStack，切换到业务管理控制台，选择左侧导航栏中的【应用管理】。</li><li>选择需要创建Service的业务下相应的命名空间，展开服务列表，进入Service管理页面。</li><li>在需要更新 YAML 的 Service 行中，单击【编辑YAML】，进入更新 Service 页面。</li><li>在 “更新Service” 页面，编辑 YAML，单击【完成】，即可更新 YAML。</li></ol><h2 id=kubectl-操作-service-指引>Kubectl 操作 Service 指引</h2><h3 id=yaml-示例>YAML 示例</h3><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#204a87;font-weight:700>kind</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Service</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>apiVersion</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>v1</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>metadata</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>my-service</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>spec</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>selector</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>app</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>MyApp</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>ports</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span>- <span style=color:#204a87;font-weight:700>protocol</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>TCP</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>port</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>80</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>targetPort</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>9376</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>type</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>LoadBalancer</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><ul><li>kind：标识 Service 资源类型。</li><li>metadata：Service 的名称、Label等基本信息。</li><li>spec.type：标识 Service 的被访问形式<ul><li>ClusterIP：在集群内部公开服务，可用于集群内部访问。</li><li>NodePort：使用节点的端口映射到后端 Service，集群外可以通过节点 IP:NodePort 访问。</li><li>LoadBalancer：使用腾讯云提供的负载均衡器公开服务，默认创建公网 CLB， 指定 annotations 可创建内网 CLB。</li><li>ExternalName：将服务映射到 DNS，仅适用于 kube-dns1.7及更高版本。</li></ul></li></ul><h3 id=创建-service-1>创建 Service</h3><ol><li><p>参考 <a href=../service#YAMLSample>YAML 示例</a>，准备 StatefulSet YAML 文件。</p></li><li><p>安装 Kubectl，并连接集群。操作详情请参考 <a href=https://cloud.tencent.com/document/product/457/8438>通过 Kubectl 连接集群</a>。</p></li><li><p>执行以下命令，创建 Service YAML 文件。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl create -f Service YAML 文件名称
</code></pre></div><p>例如，创建一个文件名为 my-service.yaml 的 Service YAML 文件，则执行以下命令：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl create -f my-service.yaml
</code></pre></div></li><li><p>执行以下命令，验证创建是否成功。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl get services
</code></pre></div><p>返回类似以下信息，即表示创建成功。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE
kubernetes   ClusterIP   172.16.255.1   &lt;none&gt;        443/TCP   38d
</code></pre></div></li></ol><h3 id=更新-service-1>更新 Service</h3><h4 id=方法一>方法一</h4><p>执行以下命令，更新 Service。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl edit service/[name]
</code></pre></div><h4 id=方法二>方法二</h4><ol><li><p>手动删除旧的 Service。</p></li><li><p>执行以下命令，重新创建 Service。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl create/apply
</code></pre></div></li></ol><h3 id=删除-service>删除 Service</h3><p>执行以下命令，删除 Service。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl delete service [NAME]
</code></pre></div><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>.params{margin-bottom:0px !important;}  
</code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-633c3237aaeb2d075e5d341846481ed4>4.3.1.3.2 - Ingress</h1><div class=lead>Ingress</div><p>Ingress 是允许访问到集群内 Service 的规则的集合，您可以通过配置转发规则，实现不同 URL 可以访问到集群内不同的 Service。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-789101fc549a9485b823279e9954eed5>4.3.1.4 - 配置管理</h1><div class=lead>配置管理</div><h1 id=配置管理>配置管理</h1></div><div class=td-content><h1 id=pg-0c72d80fcd8fcfd427fcdb7f64153f05>4.3.1.4.1 - ConfigMap</h1><div class=lead>ConfigMap</div><p>通过 ConfigMap 您可以将配置和运行的镜像进行解耦，使得应用程序有更强的移植性。ConfigMap 是有 key-value 类型的键值对，您可以通过控制台的 Kubectl 工具创建对应的 ConfigMap 对象，可以通过挂载数据卷、环境变量或在容器的运行命令中使用 ConfigMap。 ConfigMap 有两种使用方式，创建负载时做为数据卷挂载到容器和作为环境变量映射到容器。</p><h2 id=configmap-控制台操作指引>ConfigMap 控制台操作指引</h2><h3 id=创建-configmap>创建 ConfigMap</h3><ul><li>登录TKEStack，切换到【业务管理】控制台，选择左侧导航栏中的【应用管理】。</li><li>选择需要创建ConfigMap的【业务】下相应的【命名空间】，展开【配置管理】列表，进入ConfigMap管理页面。</li><li>单击【新建】，进入 “新建ConfigMap” 页面。如下图所示：</li></ul><p><img src=../../../../../../images/new-config-map.png alt=&#x65B0;&#x5EFA;ConfigMap></p><ul><li>根据实际需求，设置 ConfigMap 参数。关键参数信息如下：<ul><li>名称：自定义。</li><li>命名空间：根据实际需求进行选择命名空间类型</li><li>定义变量名和变量值。</li></ul></li><li>单击【创建ConfigMap】，完成创建。</li></ul><h3 id=更新-configmap>更新 ConfigMap</h3><ol><li><p>登录TKEStack，切换到业务管理控制台，选择左侧导航栏中的【应用管理】。</p></li><li><p>选择需要创建ConfigMap的业务下相应的命名空间，展开配置管理列表，进入ConfigMap管理页面。</p></li><li><p>在需要更新 YAML 的 ConfigMap 行中，单击【编辑YAML】，进入更新 ConfigMap 页面。</p></li><li><p>在 “更新ConfigMap” 页面，编辑 YAML，单击【完成】，即可更新 YAML。</p><blockquote><p>如需修改 key-values，编辑 YAML 中 data 的参数值，单击【完成】，即可完成更新。</p></blockquote></li></ol><h2 id=kubectl-操作-configmap-指引>Kubectl 操作 ConfigMap 指引</h2><h3 id=yaml-示例>YAML 示例</h3><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#204a87;font-weight:700>apiVersion</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>v1</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>data</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>key1</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>value1</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>key2</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>value2</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>key3</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>value3</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>kind</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>ConfigMap</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>metadata</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>test-config</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>namespace</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>default</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><ul><li>data：ConfigMap 的数据，以 key-value 形式呈现。</li><li>kind：标识 ConfigMap 资源类型。</li><li>metadata：ConfigMap 的名称、Label等基本信息。</li><li>metadata.annotations：ConfigMap 的额外说明，可通过该参数设置腾讯云 TKE 的额外增强能力。</li></ul><h3 id=创建-configmap-1>创建 ConfigMap</h3><h4 id=方式一通过-yaml-示例文件方式创建>方式一：通过 YAML 示例文件方式创建</h4><ol><li><p>参考 <a href=../configmap#YAMLSample>YAML 示例</a>，准备 ConfigMap YAML 文件。</p></li><li><p>安装 Kubectl，并连接集群。操作详情请参考 <a href=https://cloud.tencent.com/document/product/457/8438>通过 Kubectl 连接集群</a>。</p></li><li><p>执行以下命令，创建 ConfigMap YAML 文件。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl create -f ConfigMap YAML 文件名称
</code></pre></div><p>例如，创建一个文件名为 web.yaml 的 ConfigMap YAML 文件，则执行以下命令：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl create -f web.yaml
</code></pre></div></li><li><p>执行以下命令，验证创建是否成功。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl get configmap
</code></pre></div><p>返回类似以下信息，即表示创建成功。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>NAME          DATA      AGE
test          2         39d
test-config   3         18d
</code></pre></div></li></ol><h4 id=方式二通过执行命令方式创建>方式二：通过执行命令方式创建</h4><p>执行以下命令，在目录中创建 ConfigMap。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl create configmap &lt;map-name&gt; &lt;data-source&gt;
</code></pre></div><ul><li>&lt;map-name>：表示 ConfigMap 的名字。</li><li>&lt;data-source>：表示目录、文件或者字面值。</li></ul><p>更多参数详情可参见 <a href=https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#create-a-configmap>Kubernetes configMap 官方文档</a>。</p><h3 id=使用-configmap>使用 ConfigMap</h3><h4 id=方式一数据卷使用-configmap-类型>方式一：数据卷使用 ConfigMap 类型</h4><p>YAML 示例如下：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#204a87;font-weight:700>apiVersion</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>v1</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>kind</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Pod</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>metadata</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>   </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>spec</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>   </span><span style=color:#204a87;font-weight:700>containers</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>     </span>- <span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>       </span><span style=color:#204a87;font-weight:700>image</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx:latest</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>       </span><span style=color:#204a87;font-weight:700>volumeMounts</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>config-volume</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>mountPath</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>/etc/config</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>   </span><span style=color:#204a87;font-weight:700>volumes</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>config-volume</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>configMap</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>          </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>test-config</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>## 设置 ConfigMap 来源</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>          </span><span style=color:#8f5902;font-style:italic>## items:  ## 设置指定 ConfigMap 的 Key 挂载</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>          </span><span style=color:#8f5902;font-style:italic>##   key: key1  ## 选择指定 Key</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>          </span><span style=color:#8f5902;font-style:italic>##   path: keys ## 挂载到指定的子路径</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>   </span><span style=color:#204a87;font-weight:700>restartPolicy</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Never</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><h4 id=方式二环境变量中使用-configmap-类型>方式二：环境变量中使用 ConfigMap 类型</h4><p>YAML 示例如下：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#204a87;font-weight:700>apiVersion</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>v1</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>kind</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Pod</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>metadata</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>   </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>spec</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>   </span><span style=color:#204a87;font-weight:700>containers</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>     </span>- <span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>       </span><span style=color:#204a87;font-weight:700>image</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx:latest</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>       </span><span style=color:#204a87;font-weight:700>env</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>         </span>- <span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>key1</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>           </span><span style=color:#204a87;font-weight:700>valueFrom</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>             </span><span style=color:#204a87;font-weight:700>configMapKeyRef</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>               </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>test-config</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>## 设置来源 ConfigMap 文件名</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>               </span><span style=color:#204a87;font-weight:700>key</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>test-config.key1 </span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>## 设置该环境变量的 Value 来源项</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>   </span><span style=color:#204a87;font-weight:700>restartPolicy</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Never</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-5a27b72a9f3556b1c20ff0496d3c3d0e>4.3.1.4.2 - Sercet</h1><div class=lead>Sercet</div><h2 id=sercet>Sercet</h2><p>Secret 可用于存储密码、令牌、密钥等敏感信息，降低直接对外暴露的风险。Secret 是 key-value 类型的键值对，您可以通过控制台的 Kubectl 工具创建对应的 Secret 对象，也可以通过挂载数据卷、环境变量或在容器的运行命令中使用 Secret。</p><h2 id=secret-控制台操作指引>Secret 控制台操作指引</h2><h3 id=创建-secret>创建 Secret</h3><ul><li>登录 TKEStack，切换到【业务管理】控制台，选择左侧导航栏中的【应用管理】。</li><li>选择需要创建 Secret 的【业务】下相应的【命名空间】，展开【配置管理】列表，进入 Secret 管理页面。</li><li>单击【新建】，进入“新建 Secret ”页面。</li><li>在“新建 Secret ”页面，根据实际需求，进行如下参数设置。如下图所示：</li></ul><p><img src=../../../../../../images/secret.png alt></p><ul><li><strong>名称</strong>：请输入自定义名称。</li><li><strong>Secret类型</strong>：提供【Opaque】和【Dockercfg】两种类型，请根据实际需求进行选择。<ul><li><strong>Opaque</strong>：适用于保存秘钥证书和配置文件，Value 将以 base64 格式编码。</li><li><strong>Dockercfg</strong>：适用于保存私有 Docker Registry 的认证信息。</li></ul></li><li><strong>生效范围</strong>：提供以下两种范围，请根据实际需求进行选择。<ul><li><strong>存量所有命名空间</strong>：不包括 kube-system、kube-public 和后续增量命名空间。</li><li><strong>指定命名空间</strong>：支持选择当前集群下一个或多个可用命名空间。</li></ul></li><li><strong>内容</strong>：根据不同的 Secret 类型，进行配置。<ul><li>当 Secret 类型为【Opaque】时：根据实际需求，设置变量名和变量值。</li><li>当 Secret 类型为【Dockercfg】时：<ul><li><p>仓库域名：请根据实际需求输入域名或 IP。</p></li><li><p>用户名：请根据实际需求输入第三方仓库的用户名。</p></li><li><p>密码：请根据实际需求设置第三方仓库的登录密码。</p><blockquote><p>如果本次为首次登录系统，则会新建用户，相关信息写入 <code>~/.dockercrg</code> 文件中。</p></blockquote></li></ul></li></ul></li><li>单击【创建 Secret】，即可完成创建。</li></ul><h3 id=使用-secret>使用 Secret</h3><blockquote><p>Secret 在 Workload中有三种使用场景： 1. 数据卷使用 Secret 类型 2. 环境变量中使用 Secret 类型 3. 使用第三方镜像仓库时引用</p></blockquote><h3 id=更新-secret>更新 Secret</h3><ol><li><p>登录 TKEStack，切换到业务管理控制台，选择左侧导航栏中的【应用管理】。</p></li><li><p>选择需要创建 Secret 的业务下相应的命名空间，展开配置管理列表，进入 Secret 管理页面。</p></li><li><p>在需要更新 YAML 的 Secret 行中，单击【编辑YAML】，进入更新 Secret 页面。</p></li><li><p>在“更新Secret”页面，编辑 YAML，并单击【完成】即可更新 YAML。</p><blockquote><p>如需修改 key-values，则编辑 YAML 中 data 的参数值，并单击【完成】即可完成更新。</p></blockquote></li></ol><h2 id=kubectl-操作-secret-指引>Kubectl 操作 Secret 指引</h2><h3 id=创建-secret-1>创建 Secret</h3><h4 id=方式一通过指定文件创建-secret>方式一：通过指定文件创建 Secret</h4><ol><li><p>依次执行以下命令，获取 Pod 的用户名和密码。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>$ echo -n &#39;username&#39; &gt; ./username.txt
$ echo -n &#39;password&#39; &gt; ./password.txt
</code></pre></div></li><li><p>执行 Kubectl 命令，创建 Secret。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>$ kubectl create secret generic test-secret --from-file=./username.txt --from-file=./password.txt
secret &#34;testSecret&#34; created
</code></pre></div></li><li><p>执行以下命令，查看 Secret 详情。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>kubectl describe secrets/ test-secret
</code></pre></div></li></ol><h4 id=方式二yaml-文件手动创建>方式二：YAML 文件手动创建</h4><blockquote><p>? 通过 YAML 手动创建 Secret，需提前将 Secret 的 data 进行 Base64 编码。</p></blockquote><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#204a87;font-weight:700>apiVersion</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>v1</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>kind</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Secret</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>metadata</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>test-secret</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>type</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Opaque</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>data</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>username</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>dXNlcm5hbWU= </span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>## 由echo -n &#39;username&#39; | base64生成</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>password</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>cGFzc3dvcmQ= </span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>## 由echo -n &#39;password&#39; | base64生成</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><h3 id=使用-secret-1>使用 Secret</h3><h4 id=方式一-数据卷使用-secret-类型>方式一： 数据卷使用 Secret 类型</h4><p>YAML 示例如下：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#204a87;font-weight:700>apiVersion</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>v1</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>kind</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Pod</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>metadata</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>   </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>spec</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>   </span><span style=color:#204a87;font-weight:700>containers</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>     </span>- <span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>       </span><span style=color:#204a87;font-weight:700>image</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx:latest</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>       </span><span style=color:#204a87;font-weight:700>volumeMounts</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>secret-volume</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>mountPath</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>/etc/config</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>   </span><span style=color:#204a87;font-weight:700>volumes</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>secret-volume</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>secret</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>          </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#000>test-secret</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>## 设置 secret 来源</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>          </span><span style=color:#8f5902;font-style:italic>## items:  ## 设置指定 secret的 Key 挂载</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>          </span><span style=color:#8f5902;font-style:italic>##   key: username  ## 选择指定 Key</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>          </span><span style=color:#8f5902;font-style:italic>##   path: group/user ## 挂载到指定的子路径</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>          </span><span style=color:#8f5902;font-style:italic>##   mode: 256  ## 设置文件权限</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>   </span><span style=color:#204a87;font-weight:700>restartPolicy</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Never</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><h4 id=方式二-环境变量中使用-secret-类型>方式二： 环境变量中使用 Secret 类型</h4><p>YAML 示例如下：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#204a87;font-weight:700>apiVersion</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>v1</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>kind</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Pod</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>metadata</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>   </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>spec</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>   </span><span style=color:#204a87;font-weight:700>containers</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>     </span>- <span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>       </span><span style=color:#204a87;font-weight:700>image</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx:latest</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>       </span><span style=color:#204a87;font-weight:700>env</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>         </span>- <span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SECRET_USERNAME</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>           </span><span style=color:#204a87;font-weight:700>valueFrom</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>             </span><span style=color:#204a87;font-weight:700>secretKeyRef</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>               </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>test-secret</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>## 设置来源 Secret 文件名</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>               </span><span style=color:#204a87;font-weight:700>key</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>username </span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>## 设置该环境变量的 Value 来源项</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>   </span><span style=color:#204a87;font-weight:700>restartPolicy</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Never</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><h4 id=方法三使用第三方镜像仓库时引用>方法三：使用第三方镜像仓库时引用</h4><p>YAML 示例如下：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#204a87;font-weight:700>apiVersion</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>v1</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>kind</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Pod</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>metadata</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>   </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#204a87;font-weight:700>spec</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>   </span><span style=color:#204a87;font-weight:700>containers</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>     </span>- <span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>       </span><span style=color:#204a87;font-weight:700>image</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>nginx:latest</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>   </span><span style=color:#204a87;font-weight:700>imagePullSecrets</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>   </span>- <span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>test-secret</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#8f5902;font-style:italic>## 设置来源 Secret 文件名</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>   </span><span style=color:#204a87;font-weight:700>restartPolicy</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Never</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-5133b2fd66402e8287da92f8bc3afb8a>4.3.1.5 - 存储</h1><div class=lead>存储</div><h1 id=存储>存储</h1></div><div class=td-content><h1 id=pg-29f3e5641963f81595c61e48c46454d2>4.3.1.5.1 - PV和PVC</h1><div class=lead>PV和PVC</div><p>PersistentVolume（PV）：集群内的存储资源。例如，节点是集群的资源。PV 独立于 Pod 的生命周期，根据不同的 StorageClass 类型创建不同类型的 PV。 PersistentVolumeClaim（PVC）：集群内的存储请求。例如，PV 是 Pod 使用节点资源，PVC 则声明使用 PV 资源。当 PV 资源不足时，PVC 也可以动态创建 PV。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-1ac5657bc83221fe31967a09022efbb7>4.3.1.5.2 - StorageClass</h1><div class=lead>StorageClass</div><p>StorageClass 描述存储的类型，集群管理员可以为集群定义不同的存储类别。可通过 StorageClass 配合 PersistentVolumeClaim 可以动态创建需要的存储资源。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-8c2e6b2266588f17239be429af65c27b>4.3.1.6 - 事件</h1><div class=lead>事件</div><p>日志针对的是容器。包括了 Kuberntes 集群的运行容器的日志情况和各类资源的调度情况，对维护人员日常观察资源的变更以及定位问题均有帮助。</p><h2 id=日志控制台操作指引>日志控制台操作指引</h2><ul><li>登录 TKEStack，切换到【业务管理】控制台，点击【应用管理】，选择【日志】。</li><li>进入“日志”页面。</li><li>可以按照不用的命名空间和资源类型进行筛选。</li></ul><p><img src=../../../../../images/image%20%2869%29.png alt></p><blockquote><p>注意：Kubernetes 默认只将最近一个小时的事件存储在 ETCD 中，若想实现事件的持久化存储和查询操作</p></blockquote><blockquote><p>您可以参考 <a href=https://github.com/tkestack/tke/blob/master/hack/addon/readme/PersistentEvent.md>事件持久化</a> 将事件导入外部存储，实现事件的持久化存储</p></blockquote></div><div class=td-content style=page-break-before:always><h1 id=pg-14f8919cb8baa3bde4981e98721ae227>4.3.1.7 - 日志</h1><div class=lead>日志</div><p>时间针对的是负载。Kubernetes Events 包括了 Kuberntes 集群的运行和各类资源的调度情况，对维护人员日常观察资源的变更以及定位问题均有帮助。</p><h2 id=event-控制台操作指引>Event 控制台操作指引</h2><ul><li>登录 TKEStack，切换到【业务管理】控制台，点击【应用管理】中的【事件】，进入“事件”页面。</li><li>可以按照不用的命名空间和资源类型进行筛选。</li></ul><p><img src=../../../../../images/image%20%28122%29.png alt></p><p>您可以参考 <a href=../../operation-mgmt/log-collection>日志采集</a> 将日志导入外部存储，实现日志的高级管理。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-3057610a99f7aa499109de1965002074>4.3.2 - 业务管理</h1><div class=lead>业务管理</div><p><strong>这里用户可以管理业务。</strong></p><h2 id=更改业务成员>更改业务成员</h2><ol><li><p>登录 TKEStack。</p></li><li><p>切换至 【业务管理】控制台，点击【业务管理】。</p></li><li><p>在“业务管理”页面中，可以看到已创建的业务列表。鼠标移动到要修改的业务上(无需点击)，成员列会出现修改图标按钮。如下图所示： <img src=../../../../images/%E4%BF%AE%E6%94%B9%E4%B8%9A%E5%8A%A1%E6%88%90%E5%91%98%E5%9B%BE%E6%A0%871.png alt=&#x4FEE;&#x6539;&#x56FE;&#x6807;&#x6309;&#x94AE;></p><blockquote><p>注意：修改业务成员仅限状态为Active的业务，这里可以新建和删除成员。</p></blockquote></li></ol><h2 id=查看业务监控>查看业务监控</h2><ol><li><p>登录 TKEStack。</p></li><li><p>切换至 【业务管理】控制台，点击【业务管理】。</p></li><li><p>在“业务管理”页面中，可以看到已创建的业务列表。点击监控按钮，如下图所示：</p><p><img src=../../../../images/%E6%9F%A5%E7%9C%8B%E4%B8%9A%E5%8A%A1%E7%9B%91%E6%8E%A71.png alt=&#x76D1;&#x63A7;&#x6309;&#x94AE;></p></li><li><p>在右侧弹出窗口里查看业务监控情况，如下图所示：</p><p><img src=../../../../images/%E4%B8%9A%E5%8A%A1%E7%9B%91%E6%8E%A7%E8%AF%A6%E6%83%851.png alt=&#x4E1A;&#x52A1;&#x76D1;&#x63A7;&#x8BE6;&#x60C5;></p></li></ol><h2 id=删除业务>删除业务</h2><ol><li><p>登录 TKEStack。</p></li><li><p>切换至 【业务管理】控制台，点击【业务管理】。</p></li><li><p>在“业务管理”页面中，可以看到已创建的业务列表。点击删除按钮，如下图所示：</p><p><img src=../../../../images/%E5%88%A0%E9%99%A4%E4%B8%9A%E5%8A%A11.png alt=&#x5220;&#x9664;&#x4E1A;&#x52A1;></p><blockquote><p>注意：删除业务成员仅限状态为Active的业务</p></blockquote></li></ol><h2 id=对业务的操作>对业务的操作</h2><ul><li>登录 TKEStack。</li><li>在【业务管理】控制台的【业务管理】中，单击【业务id】。如下图所示：</li></ul><p><img src=../../../../images/businessid1.png alt=&#x4E1A;&#x52A1;id></p><p>a. <strong>业务信息：</strong> 在这里可以对业务名称、关联的集群、关联集群的资源进行限制等操作。</p><p><img src=../../../../images/%E4%B8%9A%E5%8A%A1%E4%BF%A1%E6%81%AF1.png alt=&#x4E1A;&#x52A1;&#x4FE1;&#x606F;></p><p>b. <strong>成员列表：</strong> 在这里可以对业务名称、关联的集群、关联集群的资源进行限制等操作。</p><p><img src=../../../../images/%E6%88%90%E5%91%98%E5%88%97%E8%A1%A8%E8%AE%BE%E7%BD%AE.png alt=&#x4E1A;&#x52A1;&#x4FE1;&#x606F;></p><p>c. <strong>子业务：</strong> 在这里可以<strong>新建本业务的子业务</strong>或<strong>通过导入子业务将已有业务变成本业务的子业务</strong></p><p><img src=../../../../images/%E5%AD%90%E4%B8%9A%E5%8A%A1.png alt=&#x4E1A;&#x52A1;&#x4FE1;&#x606F;></p><p>d. <strong>业务下Namespace列表：</strong> 这里可以管理业务下的Namespace</p><p><img src=../../../../images/%E4%B8%9A%E5%8A%A1Namespace%E5%88%97%E8%A1%A8.png alt=&#x4E1A;&#x52A1;&#x4FE1;&#x606F;></p><p>​ 单击【新建Namespace】。在“新建Namespace”页面中，填写相关信息。如下图所示：</p><p><img src=../../../../images/my-ns.png alt=&#x65B0;&#x5EFA;&#x7A7A;&#x95F4;&#x5217;&#x8868;></p><p>​ <strong>名称</strong>：不能超过63个字符，这里以<code>new-ns</code>为例</p><p>​ <strong>集群</strong>：<code>my-business</code>业务中的集群，这里以<code>global</code>集群为例</p><p>​ <em>资源限制*</em>：这里可以限制当前命名空间下各种资源的使用量，可以不设置。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-0833d65e8a0923cb315f467023b013b7>4.3.3 - 组织资源</h1><div class=lead>组织资源</div><h1 id=组织资源>组织资源</h1></div><div class=td-content><h1 id=pg-f5322afb855665547246929ce62f630e>4.3.3.1 - 镜像仓库管理</h1><div class=lead>镜像仓库管理</div><p><strong>这里用户可以管理镜像仓库。</strong></p><blockquote><p>注意：TKEStack的【业务管理】控制台不支持命名空间的创建，可以在【平台管理】下的<a href=../../../platform-console/registry-mgmt/>【组织资源】</a>下的【镜像仓库管理】新建命名空间。</p></blockquote><h2 id=删除命名空间>删除命名空间</h2><ol><li>登录 TKEStack。</li><li>切换至 【业务管理】控制台，选择 【组织资源】->【仓库管理】。点击列表最右侧【删除】按钮。如下图所示：</li><li>点击【确认】</li></ol><p><img src=../../../../../images/ming-ming-kong-jian-shan-chu-an-niu-1.png alt></p><h3 id=镜像上传>镜像上传</h3><ul><li>登录 TKEStack。</li><li>切换至 【业务管理】控制台，选择 【组织资源】->【仓库管理】，查看“命名空间”列表。点击列表中命名空间【名称】。如下图所示：</li></ul><p><img src=../../../../../images/image%20%28104%29.png alt></p><ul><li><p>此时进入了“镜像列表”页面，点击【镜像上传指引】按钮。如下图所示：</p><blockquote><p>注意：此页面可以通过上传的镜像最右边的【删除】按钮来删除上传的镜像</p></blockquote></li></ul><p><img src=../../../../../images/image%20%2858%29.png alt></p><ul><li>根据指引内容，在物理节点上执行相应命令。如下图所示：</li></ul><p><img src=../../../../../images/image%20%2883%29.png alt></p></div><div class=td-content style=page-break-before:always><h1 id=pg-f0a95e137c43ada900e73e5db88f8ac3>4.3.3.2 - Helm模板</h1><div class=lead>Helm模板</div><p>应用功能是 TKEStack 集成的 <a href=https://helm.sh/>Helm 3.0</a> 相关功能，为您提供创建 helm chart、容器镜像、软件服务等各种产品和服务的能力。已创建的应用将在您指定的集群中运行，为您带来相应的能力。</p><h2 id=模板>模板</h2><ol><li><p>登录 TKEStack</p></li><li><p>切换至 【平台管理】控制台，选择 【组织资源】->【 Helm模板】，点击【模板】 1. <strong>所有模板</strong>：包含下列所有模板 2. <strong>用户模板</strong>：权限范围为“指定用户”的仓库下的所有模板 3. <strong>业务模板</strong>：权限范围为“指定业务”的仓库下的所有模板 4. <strong>公共模板</strong>：权限范围为“公共”的仓库下的所有模板</p><p><img src=../../../../../images/image-20201203144524973.png alt=image-20201203144524973></p></li></ol><h2 id=仓库>仓库</h2><ol><li><p>登录 TKEStack</p></li><li><p>切换至 【平台管理】控制台，选择 【组织资源】->【 Helm模板】，点击【仓库】</p></li><li><p>点击【新建】按钮，如下图所示： <img src=../../../../../images/Chart%E5%8C%85%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.png alt=&#x65B0;&#x5EFA;Chart&#x5305;&#x547D;&#x540D;&#x7A7A;&#x95F4;></p><ul><li><p>在弹出的 “新建仓库” 页面，填写 仓库 信息，如下图所示：</p><p><img src=../../../../../images/image-20201203144754466.png alt=image-20201203144754466></p></li><li><p><strong>仓库名称：</strong> 仓库名字，不超过60个字符</p></li><li><p><strong>权限访问</strong></p><ul><li><strong>指定用户</strong>：选择当前仓库可以被哪些平台的用户访问</li><li><strong>指定业务</strong>：选择当前仓库可以被哪些平台的业务访问，业务下的成员对该仓库的访问权限在【业务管理】中完成</li><li><strong>公共</strong>：平台所有用户都能访问该仓库</li></ul></li><li><p><strong>导入第三方仓库：</strong> 若已有仓库想导入 TKEStack 中使用，请勾选</p><ul><li><strong>第三方仓库地址</strong>：请输入第三方仓库地址</li><li><strong>第三方仓库用户名</strong>：若第三方仓库开启了鉴权，需要输入第三方仓库的用户名</li><li><strong>第三方仓库密码</strong>：若第三方仓库开启了鉴权，需要输入第三方仓库的密码</li></ul></li><li><p><strong>仓库描述：</strong> 请输入仓库描述，不超过255个字符</p></li></ul></li><li><p>单击【确认】按钮</p><p><strong>删除仓库</strong></p></li><li><p>登录 TKEStack</p></li><li><p>切换至 【平台管理】控制台，选择 【组织资源】-> 【 Helm 模板】，点击【仓库】，查看 “helm模板仓库”列表</p></li><li><p>点击列表最右侧【删除】按钮，如下图所示：</p><p><img src=../../../../../images/Chart%E5%8C%85%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%88%A0%E9%99%A4%E6%8C%89%E9%92%AE%20%281%29.png alt=Chart&#x5305;&#x547D;&#x540D;&#x7A7A;&#x95F4;&#x5220;&#x9664;&#x6309;&#x94AE;></p><p><strong>Chart 上传指引</strong></p></li><li><p>登录 TKEStack</p></li><li><p>切换至 【平台管理】控制台，选择 【组织资源】-> 【 Helm模板】，点击【仓库】，查看 “helm模板仓库”列表</p></li><li><p>点击列表最右侧【上传指引】按钮，如下图所示：</p><p><img src=../../../../../images/Chart%E5%8C%85%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%90%8D%E7%A7%B0%20%281%29.png alt=Chart&#x5305;&#x547D;&#x540D;&#x7A7A;&#x95F4;&#x540D;&#x79F0;></p></li><li><p>根据指引内容，在物理节点上执行相应命令，如下图所示：</p><p><img src=../../../../../images/Chart%E4%B8%8A%E4%BC%A0%E6%8C%87%E5%BC%95%E5%86%85%E5%AE%B9.png alt=Chart&#x4E0A;&#x4F20;&#x6307;&#x5F15;&#x5185;&#x5BB9;></p></li></ol><h2 id=同步导入仓库>同步导入仓库</h2><ol><li><p>登录 TKEStack</p></li><li><p>切换至 【平台管理】控制台，选择 【组织资源】->【 Helm模板】，点击【仓库】</p></li><li><p>点击导入仓库的【同步仓库】按钮，如下图所示：</p><p><img src=../../../../../images/image-20201203151341971.png alt=image-20201203151341971></p></li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-c94ea67b479a34ed1633b3f44f2a27d9>4.3.3.3 - 访问凭证</h1><div class=lead>访问凭证</div><p><strong>这里用户可以管理自己的凭据。</strong></p><h2 id=新建访问凭证>新建访问凭证</h2><ol><li>登录 TKEStack。</li><li>切换至 【业务管理】控制台，选择【组织资源】->【访问凭证】，点击【新建】按钮。</li><li>在弹出“创建访问凭证”页面，填写凭证信息。如下图所示：</li></ol><ul><li>凭证描述：描述当前凭证信息</li><li>过期时间：填写过期时间，选择小时/分钟为单位</li></ul><ol><li>单击【确认】按钮</li></ol><p><img src=../../../../../images/xin-jian-fang-wen-ping-zheng-resource.png alt></p><p><img src=../../../../../images/xin-jian-fang-wen-ping-zheng-resource1.png alt></p><h2 id=停用启用删除访问凭证>停用/启用/删除访问凭证</h2><ol><li><p>登录 TKEStack。</p></li><li><p>切换至 【业务管理】控制台，选择 【组织资源】-> 【访问凭证】，查看“访问凭证”列表。单击列表右侧【禁用】/【启用】/【删除】按钮。如下图所示：</p><blockquote><p>注意：点击【禁用】之后，【禁用】按钮就变成了【启用】</p></blockquote></li><li><p>单击【确认】按钮</p></li></ol><p><img src=../../../../../images/access-card.png alt></p></div><div class=td-content style=page-break-before:always><h1 id=pg-546cb0ff5126c40169ac9e848ea02681>4.3.4 - 监控与告警</h1><div class=lead>监控与告警</div><h1 id=监控与告警>监控与告警</h1></div><div class=td-content><h1 id=pg-79be2d16b5d7949b81dad31c17ccfb47>4.3.4.1 - 设置告警</h1><div class=lead>设置告警</div><h2 id=概念>概念</h2><p><strong>这里用户配置平台告警。</strong></p><h2 id=前提条件>前提条件</h2><blockquote><ul><li>需要设置告警的命名空间所在的集群，应该先在<a href=../../../platform-console/addon-mgmt/>【扩展组件】</a>安装<strong>Prometheus组件</strong></li></ul></blockquote><h2 id=操作步骤>操作步骤</h2><h3 id=新建告警设置>新建告警设置</h3><ul><li>登录 TKEStack。</li><li>切换至【业务管理】控制台，选择【监控&告警】-> 【告警设置】，查看“告警设置”列表。</li><li>选择相应【项目】和【namespace】，点击【新建】按钮。如下图所示：</li></ul><p><img src=../../../../../images/%E6%96%B0%E5%BB%BA%E5%91%8A%E8%AD%A6.png alt=&#x65B0;&#x5EFA;&#x544A;&#x8B66;></p><ul><li>在“新建策略”页面填写告警策略信息。如下图所示：</li></ul><p><img src=../../../../../images/%E6%96%B0%E5%BB%BA%E5%91%8A%E8%AD%A6%E7%AD%96%E7%95%A5-1.png alt=&#x65B0;&#x5EFA;&#x544A;&#x8B66;&#x7B56;&#x7565;></p><ul><li><strong>告警策略名称：</strong> 输入告警策略名称，最长60字符</li><li><strong>策略类型：</strong> 选择告警策略应用类型<ul><li><strong>集群：</strong> 集群监控告警</li><li><strong>Pod：</strong> Pod 监控告警<ul><li><strong>告警对象：</strong> 选择Pod相关的告警对象，支持对namespace下不同对deployment、stateful和daemonset 进行监控报警<ul><li><strong>按工作负载选择：</strong> 选择namespace下的某个工作负载</li><li><strong>全部选择：</strong> 不区分namespace，全部监控</li></ul></li></ul></li><li><strong>节点：</strong> 节点监控告警</li></ul></li><li><strong>统计周期：</strong> 选择数据采集周期，支持1、2、3、4、5分钟</li><li><strong>指标：</strong> 选择告警指标，支持对监测值与指标值进行【大于/小于】比较，选择结果持续周期。如下图：</li></ul><p><img src=../../../../../images/%E6%8C%87%E6%A0%87%E8%AE%BE%E7%BD%AE.png alt=&#x6307;&#x6807;&#x8BBE;&#x7F6E;></p><ul><li><strong>接收组：</strong> 选择接收组，当出现满足条件当报警信息时，向组内人员发送消息。<strong>接收组需要先在</strong> <a href=../alerts#%E9%80%9A%E7%9F%A5%E8%AE%BE%E7%BD%AE><strong>通知设置</strong></a> <strong>创建</strong></li><li><strong>通知方式：</strong> 选择通知渠道和消息模版。<strong>通知渠道 和 消息模版需要先在</strong> <a href=../alerts#%E9%80%9A%E7%9F%A5%E8%AE%BE%E7%BD%AE><strong>通知设置</strong></a> <strong>创建</strong><ul><li><strong>添加通知方式</strong> 如需要添加多种通知方式，点击该按钮。<ol><li>单击【提交】按钮。</li></ol></li></ul></li></ul><h3 id=复制告警设置>复制告警设置</h3><ul><li>登录 TKEStack。</li><li>切换至【业务管理】控制台，选择 【监控&告警】->【告警设置】，查看告警设置列表。</li><li>选择相应【项目】和【namespace】，点击“告警设置”列表最右侧的【复制】按钮。如下图所示：</li></ul><p><img src=../../../../../images/%E5%91%8A%E8%AD%A6%E5%A4%8D%E5%88%B6%E6%8C%89%E9%92%AE-1.png alt=&#x544A;&#x8B66;&#x590D;&#x5236;&#x6309;&#x94AE;></p><ul><li><p>在复制策略页面，编辑告警策略信息。</p></li><li><p>单击【提交】按钮。</p><p><strong>编辑告警设置</strong></p></li><li><p>登录 TKEStack。</p></li><li><p>切换至 【业务管理】控制台，选择 【监控&告警】->【告警设置】，查看告警设置列表。</p></li><li><p>选择相应【项目】和【namespace】，点击【告警名称】。如下图所示：</p></li></ul><p><img src=../../../../../images/%E5%91%8A%E8%AD%A6%E5%90%8D%E7%A7%B0-1.png alt=&#x544A;&#x8B66;&#x540D;&#x79F0;></p><ul><li>在“告警策略详情”页面，单击【基本信息】右侧的【编辑】按钮。如下图所示：</li></ul><p><img src=../../../../../images/%E5%91%8A%E8%AD%A6%E7%BC%96%E8%BE%91-1.png alt=&#x544A;&#x8B66;&#x7F16;&#x8F91;></p><ul><li><p>在更新策略页面，编辑策略信息。</p></li><li><p>单击【提交】按钮。</p><p><strong>删除告警设置</strong></p></li><li><p>登录 TKEStack。</p></li><li><p>切换至 【业务管理】控制台，选择 【监控&告警】->【告警设置】，查看“告警设置”列表。</p></li><li><p>选择相应【项目】和【namespace】，点击列表最右侧的【删除】按钮。如下图所示：</p></li></ul><p><img src=../../../../../images/%E5%91%8A%E8%AD%A6%E5%88%A0%E9%99%A4-1.png alt=&#x544A;&#x8B66;&#x5220;&#x9664;></p><ul><li>在弹出的删除告警窗口，单击【确定】按钮。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-845ad2011e5c3014b6adbbdc05f6c385>4.3.4.2 - 通知设置</h1><div class=lead>通知设置</div><h2 id=概念>概念</h2><p><strong>这里用户配置平台通知。</strong></p><h2 id=操作步骤>操作步骤</h2><p>这部分和【平台管理】控制台下【监控&告警】下的【通知设置】完全一致。故这里使用【平台管理】控制台下的截图。</p><h3 id=通知渠道>通知渠道</h3><h4 id=新建通知渠道>新建通知渠道</h4><ul><li>登录 TKEStack。</li><li>切换至【业务管理】控制台，选择 【监控&告警】->【通知设置】->【通知渠道】，查看“通知渠道”列表。</li><li>点击【新建】按钮。如下图所示：</li></ul><p><img src=../../../../../images/xin-jian-tong-zhi-qu-dao-an-niu-%20%283%29.png alt=&#x65B0;&#x5EFA;&#x901A;&#x77E5;&#x6E20;&#x9053;&#x6309;&#x94AE;></p><ul><li>在“新建通知渠道”页面填写渠道信息。如下图所示：</li></ul><p><img src=../../../../../images/%E6%96%B0%E5%BB%BA%E9%80%9A%E7%9F%A5%E6%B8%A0%E9%81%93%20%281%29.png alt=&#x65B0;&#x5EFA;&#x901A;&#x77E5;&#x6E20;&#x9053;></p><ul><li><strong>名称：</strong> 填写渠道名称</li><li><strong>渠道：</strong> 选择渠道类型，输入渠道信息</li><li><strong>邮件：</strong> 邮件类型<ul><li><strong>email：</strong> 邮件发送放地址</li><li><strong>password：</strong> 邮件发送方密码</li><li><strong>smtpHost：</strong> smtp IP地址</li><li><strong>smtpPort：</strong> smtp端口</li><li><strong>tls：</strong> 是否tls加密</li></ul></li><li><strong>短信：</strong> 短信方式<ul><li><strong>appKey：</strong> 短信发送方的appKey</li><li><strong>sdkAppID：</strong> sdkAppID</li><li><strong>extend：</strong> extend 信息</li></ul></li><li><strong>微信公众号：</strong> 微信公众号方式<ul><li><strong>appID：</strong> 微信公众号appID</li><li><strong>appSecret：</strong> 微信公众号app密钥</li></ul></li><li>单击【保存】按钮。</li></ul><h4 id=编辑通知渠道>编辑通知渠道</h4><ul><li>登录 TKEStack。</li><li>切换至【业务管理】控制台，选择 【监控&告警】->【通知设置】->【通知渠道】，查看“通知渠道”列表。</li><li>单击渠道名称。如下图所示：</li></ul><p><img src=../../../../../images/qu-dao-ming-cheng-%20%281%29%20%282%29.png alt=&#x6E20;&#x9053;&#x540D;&#x79F0;></p><ul><li>在“基本信息”页面，单击【基本信息】右侧的【编辑】按钮。如下图所示：</li></ul><p><img src=../../../../../images/%E6%B8%A0%E9%81%93%E7%BC%96%E8%BE%91%E6%8C%89%E9%92%AE%20%282%29%20%281%29.png alt=&#x6E20;&#x9053;&#x7F16;&#x8F91;&#x6309;&#x94AE;></p><ul><li>在“更新渠道通知”页面，编辑渠道信息。</li><li>单击【保存】按钮。</li></ul><h4 id=删除通知渠道>删除通知渠道</h4><ul><li>登录 TKEStack。</li><li>切换至【业务管理】控制台，选择 【监控&告警】->【通知设置】->【通知渠道】，查看“通知渠道”列表。</li><li>选择要删除的渠道，点击【删除】按钮。如下图所示：</li></ul><p><img src=../../../../../images/%E6%B8%A0%E9%81%93%E7%BC%96%E8%BE%91%E6%8C%89%E9%92%AE%20%282%29%20%286%29.png alt=&#x5220;&#x9664;&#x6E20;&#x9053;></p><ul><li>单击删除窗口的【确定】按钮。</li></ul><h3 id=通知模板>通知模板</h3><h4 id=新建通知模版>新建通知模版</h4><ul><li>登录 TKEStack。</li><li>切换至【业务管理】控制台，选择 【监控&告警】->【通知设置】->【通知模板】，查看“通知模板”列表。</li><li>点击【新建】按钮。如下图所示：</li></ul><p><img src=../../../../../images/xin-jian-tong-zhi-mo-ban-%20%281%29.png alt=&#x65B0;&#x5EFA;&#x901A;&#x77E5;&#x6A21;&#x7248;></p><ul><li>在“新建通知模版”页面填写模版信息。如下图所示：</li></ul><p><img src=../../../../../images/%E9%80%9A%E7%9F%A5%E6%A8%A1%E7%89%88.png alt=&#x901A;&#x77E5;&#x6A21;&#x7248;></p><ul><li><strong>名称：</strong> 模版名称</li><li><strong>渠道：</strong> 选择已创建的渠道</li><li><strong>body：</strong> 填写消息body体</li><li><strong>header：</strong> 填写消息标题</li><li>单击【保存】按钮。</li></ul><h4 id=编辑通知模版>编辑通知模版</h4><ul><li>登录 TKEStack。</li><li>切换至【业务管理】控制台，选择 【监控&告警】->【通知设置】->【通知模板】，查看“通知模板”列表。</li><li>单击模版名称。如下图所示：</li></ul><p><img src=../../../../../images/%E6%A8%A1%E7%89%88%E5%90%8D%E7%A7%B0%20%282%29.png alt=&#x6A21;&#x7248;&#x540D;&#x79F0;></p><ul><li>在基本信息页面，单击【基本信息】右侧的【编辑】按钮。如下图所示：</li></ul><p><img src=../../../../../images/%E6%A8%A1%E7%89%88%E7%BC%96%E8%BE%91%E6%8C%89%E9%92%AE%20%281%29%20%281%29.png alt=&#x6A21;&#x7248;&#x7F16;&#x8F91;&#x6309;&#x94AE;></p><ul><li>在“更新通知模版”页面，编辑模版信息。</li><li>单击【保存】按钮。</li></ul><h4 id=删除通知模版>删除通知模版</h4><ul><li>登录 TKEStack。</li><li>切换至【业务管理】控制台，选择 【监控&告警】->【通知设置】->【通知模板】，查看"通知模板"列表。</li><li>选择要删除的模版，点击【删除】按钮。如下图所示：</li></ul><p><img src=../../../../../images/%E5%88%A0%E9%99%A4%E6%A8%A1%E7%89%88%20%281%29.png alt=&#x5220;&#x9664;&#x6A21;&#x7248;></p><ul><li>单击删除窗口的【确定】按钮。</li></ul><h3 id=接收人>接收人</h3><h4 id=新建接收人>新建接收人</h4><ul><li>登录 TKEStack。</li><li>切换至【业务管理】控制台，选择 【监控&告警】->【通知设置】->【接收人】，查看"接收人"列表。</li><li>点击【新建】按钮。如下图所示：</li></ul><p><img src=../../../../../images/xin-jian-jie-shou-ren-%20%281%29.png alt=&#x65B0;&#x5EFA;&#x63A5;&#x6536;&#x4EBA;></p><ul><li>在“新建接收人”页面填写模版信息。如下图所示：</li></ul><p><img src=../../../../../images/%E6%8E%A5%E6%94%B6%E4%BA%BA%20%281%29%20%281%29.png alt=&#x63A5;&#x6536;&#x4EBA;></p><ul><li><strong>显示名称：</strong> 接收人显示名称</li><li><strong>用户名：</strong> 接收人用户名</li><li><strong>移动电话：</strong> 手机号</li><li><strong>电子邮件：</strong> 接收人邮箱</li><li><strong>微信OpenID：</strong> 接收人微信ID</li><li>单击【保存】按钮。</li></ul><h4 id=编辑接收人信息>编辑接收人信息</h4><ul><li>登录 TKEStack。</li><li>切换至【业务管理】控制台，选择 【监控&告警】->【通知设置】->【接收人】，查看“接收人”列表。</li><li>单击接收人名称。如下图所示：</li></ul><p><img src=../../../../../images/jie-shou-ren-ming-cheng-%20%281%29.png alt=&#x63A5;&#x6536;&#x4EBA;&#x540D;&#x79F0;></p><ul><li>在“基本信息”页面，单击【基本信息】右侧的【编辑】按钮。如下图所示：</li></ul><p><img src=../../../../../images/%E6%8E%A5%E6%94%B6%E4%BA%BA%E7%BC%96%E8%BE%91%E6%8C%89%E9%92%AE.png alt=&#x63A5;&#x6536;&#x4EBA;&#x7F16;&#x8F91;&#x6309;&#x94AE;></p><ul><li>在“更新接收人”页面，编辑接收人信息。</li><li>单击【保存】按钮。</li></ul><h4 id=删除接收人>删除接收人</h4><ul><li>登录 TKEStack。</li><li>切换至【业务管理】控制台，选择 【监控&告警】->【通知设置】->【接收人】，查看“接收人”列表。</li><li>选择要删除的接收人，点击【删除】按钮。如下图所示：</li></ul><p><img src=../../../../../images/image%20%28135%29.png alt></p><ul><li>单击删除窗口的【确定】按钮。</li></ul><h3 id=接收组>接收组</h3><h4 id=新建接收组>新建接收组</h4><ul><li>登录 TKEStack。</li><li>切换至【业务管理】控制台，选择 【监控&告警】->【通知设置】->【接收组】，查看“接收组”列表。</li><li>点击【新建】按钮。如下图所示：</li></ul><p><img src=../../../../../images/%E6%96%B0%E5%BB%BA%E6%8E%A5%E6%94%B6%E7%BB%84%20%282%29%20%285%29.png alt=&#x65B0;&#x5EFA;&#x63A5;&#x6536;&#x7EC4;></p><ul><li>在“新建接收组”页面填写模版信息。如下图所示：</li></ul><p><img src=../../../../../images/%E6%96%B0%E5%BB%BA%E6%8E%A5%E6%94%B6%E7%BB%84%20%282%29.png alt=&#x63A5;&#x6536;&#x7EC4;></p><ul><li><strong>名称：</strong> 接收组显示名称</li><li><strong>接收组：</strong> 从列表里选择接收人。如没有想要的接收人，请在<a href=../notifier#%E6%8E%A5%E6%94%B6%E4%BA%BA>接收人</a>里创建。</li><li>单击【保存】按钮。</li></ul><h4 id=编辑接收组信息>编辑接收组信息</h4><ul><li>登录 TKEStack。</li><li>切换至【业务管理】控制台，选择 【监控&告警】->【通知设置】->【接收组】，查看“接收组”列表。</li><li>单击接收组名称。如下图所示：</li></ul><p><img src=../../../../../images/jie-shou-zu-ming-cheng-%20%281%29.png alt=&#x63A5;&#x6536;&#x7EC4;&#x540D;&#x79F0;></p><ul><li>在“基本信息”页面，单击【基本信息】右侧的【编辑】按钮。如下图所示：</li></ul><p><img src=../../../../../images/%E6%8E%A5%E6%94%B6%E7%BB%84%E7%BC%96%E8%BE%91%E6%8C%89%E9%92%AE%20%281%29.png alt=&#x63A5;&#x6536;&#x7EC4;&#x7F16;&#x8F91;&#x6309;&#x94AE;></p><ul><li>在“更新接收组”页面，编辑接收组信息。</li><li>单击【保存】按钮。</li></ul><h4 id=删除接收组>删除接收组</h4><ul><li>登录 TKEStack。</li><li>切换至【业务管理】控制台，选择 【监控&告警】->【通知设置】->【接收组】，查看“接收组”列表。</li><li>选择要删除的接收组，点击【删除】按钮。如下图所示：</li></ul><p><img src=../../../../../images/%E5%88%A0%E9%99%A4%E6%8E%A5%E6%94%B6%E7%BB%84%20%281%29%20%281%29.png alt=&#x5220;&#x9664;&#x63A5;&#x6536;&#x7EC4;></p><ul><li>单击删除窗口的【确定】按钮。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-22fc8e15cadbee096a9ba8d919957ba0>4.3.5 - 运维中心</h1><div class=lead>运维中心</div><h1 id=运维中心>运维中心</h1></div><div class=td-content><h1 id=pg-55a60e4dfe4f04261ba0510de35132f8>4.3.5.1 - Helm应用</h1><div class=lead>Helm应用</div><p>应用功能是 TKEStack 集成的 <a href=https://helm.sh/>Helm 3.0</a> 相关功能，为您提供创建 helm chart、容器镜像、软件服务等各种产品和服务的能力。已创建的应用将在您指定的集群中运行，为您带来相应的能力。</p><h2 id=新建-helm-应用>新建 Helm 应用</h2><ul><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【运维中心】->【 Helm 应用】</li><li>选择相应【集群】，单击【新建】按钮，如下图所示：</li></ul><p><img src=../../../../../images/platformhelm.png alt="&#x65B0;&#x5EFA; Helm &#x6309;&#x94AE;"></p><ul><li>在“新建 Helm 应用”页面填写Helm应用信息，如下图所示：</li></ul><p><img src=../../../../../images/%E6%96%B0%E5%BB%BAHelm%E5%BA%94%E7%94%A8.png alt="&#x65B0;&#x5EFA; Helm &#x5E94;&#x7528;"></p><ul><li><strong>应用名称：</strong> 输入应用名，1～63字符，只能包含小写字母、数字及分隔符("-")，且必须以小写字母开头，数字或小写字母结尾</li><li><strong>运行集群：</strong> 选择应用所在集群</li><li><strong>命名空间：</strong> 选择应用所在集群的命名空间</li><li><strong>类型：</strong> 当前仅支持 HelmV3</li><li><strong>Chart：</strong> 选择需要部署的 chart</li><li><strong>Chart版本：</strong> 选择 chart 的版本</li><li><strong>参数：</strong> 更新时如果选择不同版本的 Helm Chart，参数设置将被覆盖</li><li><strong>拟运行：</strong> 会返回模板渲染清单，即最终将部署到集群的 YAML 资源，不会真正执行安装</li><li>单击【完成】按钮</li></ul><h2 id=删除-helm-应用>删除 Helm 应用</h2><ol><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【运维中心】->【 Helm 应用】</li><li>点击【删除】</li></ol><p><img src=../../../../../images/image-20201203150729694.png alt=image-20201203150729694></p><h2 id=查看-helm-应用资源列表>查看 Helm 应用资源列表</h2><ol><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【运维中心】->【 Helm 应用】</li><li>点击【应用名】后，点击【资源列表】，可查看该应用所有 Kubernetes 资源对象</li></ol><h2 id=查看-helm-应用详情>查看 Helm 应用详情</h2><ol><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【运维中心】->【 Helm 应用】</li><li>点击【应用名】后，点击【应用详情】</li></ol><p><img src=../../../../../images/image-20201203150904452.png alt=image-20201203150904452></p><h2 id=查看-helm-应用版本历史>查看 Helm 应用版本历史</h2><ol><li>登录 TKEStack</li><li>切换至【平台管理】控制台，选择【运维中心】->【 Helm 应用】</li><li>点击【应用名】后，点击【版本历史】，可查看该应用所部署的历史版本。可以通过选择不同的版本进行参数对比查看其版本区别</li></ol><p><img src=../../../../../images/image-20201203151027616.png alt=image-20201203151027616></p></div><div class=td-content style=page-break-before:always><h1 id=pg-aecfc90660f6fc8ff8c08c88ca759f90>4.3.5.2 - 日志采集</h1><div class=lead>日志采集</div><p>TKESTack 提供的集群内日志采集功能，支持将集群内服务或集群节点特定路径文件的日志发送至 Kafka、Elasticsearch 等消费端，支持采集容器标准输出日志，容器内文件日志以及主机内文件日志。更提供事件持久化、审计等功能，实时记录集群事件及操作日志记录，帮助运维人员存储和分析集群内部资源生命周期、资源调度、异常告警等情况</p><p><img src=../../../../../images/image%20%2818%29.png alt></p><p>日志收集功能需要为每个集群手动开启。日志收集功能开启后，日志收集组件 logagent 会在集群内以 Daemonset 的形式运行。用户可以通过日志收集规则配置日志的采集源和消费端，日志收集 Agent 会从用户配置的采集源进行日志收集，并将日志内容发送至用户指定的消费端。需要注意的是，<strong>使用日志收集功能需要您确认 Kubernetes 集群内节点能够访问日志消费端。</strong></p><ul><li><strong>采集容器标准输出日志</strong> ：采集集群内指定<strong>容器的 Stderr 和 Stdout 日志。</strong>，采集到的日志信息将会以 JSON 格式输出到用户指定的消费端，并会自动附加相关的 Kubernetes metadata， 包括容器所属 Pod 的 label 和 annotation 等信息。</li><li><strong>采集容器内文件日志</strong> ：采集集群内指定<strong>容器内文件路径的日志</strong>，用户可以根据自己的需求，灵活的配置所需的容器和路径，采集到的日志信息将会以 JSON 格式输出到用户指定的消费端， 并会附加相关的 Kubernetes metadata，包括容器所属 pod 的 label 和 annotation 等信息。</li><li><strong>采集主机内文件日志</strong> ：采集集群内所有节点的指定<strong>主机文件路径的日志</strong>，logagent 会采集集群内所有节点上满足指定路径规则的文件日志，以 JSON 格式输出到用户指定的输出端， 并会附加用户指定的 metadata，包括日志来源文件的路径和用户自定义的 metadata。</li></ul><blockquote><p>注意：日志采集对接外部 Kafka 或 Elasticsearch，该功能需要额外开启，位置在集群 <a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/products/platform/cluster.md#%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF>基本信息</a> 下面，点击开启“日志采集”服务</p></blockquote><p><img src=../../../../../images/image%20%28100%29.png alt></p><h3 id=使用日志采集服务>使用日志采集服务</h3><h4 id=业务管理侧>业务管理侧</h4><ul><li>登录 TKEStack</li><li>切换至【业务管理】控制台，选择 【运维中心】->【日志采集】</li><li>选择相应【业务】和【命名空间】，单击【新建】按钮，如下图所示：</li></ul><p><img src=../../../../../images/image%20%2825%29.png alt></p><ul><li>在“新建日志采集”页面填写日志采集信息，如下图所示：</li></ul><p><img src=../../../../../images/image%20%28130%29.png alt></p><ul><li><strong>收集规则名称：</strong> 输入规则名，1～63字符，只能包含小写字母、数字及分隔符("-")，且必须以小写字母开头，数字或小写字母结尾</li><li><strong>业务：</strong> 选择所属业务（业务管理侧才会出现）</li><li><strong>集群：</strong> 选择所属集群（平台管理侧才会出现）</li><li><strong>类型：</strong> 选择采集类型<ul><li><strong>容器标准输出：</strong> 容器 Stderr 和 Stdout 日志信息采集<ul><li><strong>日志源：</strong> 可以选择所有容器或者某个 Namespace 下的所有容器/工作负载<ul><li><strong>所有容器：</strong> 所有容器</li><li><strong>指定容器：</strong> 某个 Namespace 下的所有容器或者工作负载</li></ul></li></ul></li><li><strong>容器文件路径：</strong> 容器内文件内容采集<ul><li><p><strong>日志源：</strong> 可以采集具体容器内的某个文件路径下的文件内容</p><ul><li><strong>工作负载选项：</strong> 选择某个 Namespace 下的某种工作负载类型下的某个工作负载</li><li><strong>配置采集路径：</strong> 选择某个容器下的某个文件路径</li></ul><blockquote><ul><li>文件路径若输入<code>stdout</code>，则转为容器标准输出模式</li><li>可配置多个路径。路径必须以<code>/</code>开头和结尾，文件名支持通配符（*）。文件路径和文件名最长支持63个字符</li><li>请保证容器的日志文件保存在数据卷，否则收集规则无法生效，详见<a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/products/business-control-pannel/operation/logcollect.md#%E6%8C%87%E5%AE%9A%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E5%90%8E%E7%9A%84%E6%97%A5%E5%BF%97%E7%9B%AE%E5%BD%95>指定容器运行后的日志目录</a></li></ul></blockquote></li></ul></li><li><strong>节点文件路径：</strong> 收集节点上某个路径下的文件内容<ul><li><strong>日志源：</strong> 可以采集具体节点内的某个文件路径下的文件内容<ul><li><strong>收集路径：</strong> 节点上日志收集路径。路径必须以<code>/</code>开头和结尾，文件名支持通配符（*）。文件路径和文件名最长支持63个字符</li></ul></li><li><strong>metadata：</strong> key：value 格式，收集的日志会带上 metadata 信息上报给消费端</li></ul></li></ul></li><li><strong>消费端：</strong> 选择日志消费端<ul><li><strong>Kafka：</strong><ul><li><strong>访问地址：</strong> Kafka IP 和端口</li><li><strong>主题（Topic）：</strong> Kafka Topic 名</li></ul></li><li><strong>Elasticsearch：</strong><ul><li><p><strong>Elasticsearch 地址：</strong> ES 地址，如：<a href=http://190.0.0.1:200/>http://190.0.0.1:200</a></p><blockquote><p>注意：当前只支持未开启用户登录认证的 ES 集群</p></blockquote></li><li><p><strong>索引：</strong> ES索引，最长60个字符，只能包含小写字母、数字及分隔符("-"、"_"、"+")，且必须以小写字母开头</p></li></ul></li></ul></li><li>单击【完成】按钮</li></ul><h4 id=平台管理侧>平台管理侧</h4><p>在平台管理侧也支持日志采集规则的创建，创建方式和业务管理处相同。详情可点击平台侧的<a href=https://github.com/tkestack/tke/blob/master/docs/guide/zh-CN/products/platform/operation/log.md>日志采集</a>。</p><h3 id=指定容器运行后的日志目录>指定容器运行后的日志目录</h3><p>LogAgent 除了支持日志规则的创建，也支持指定容器运行后的日志目录，可实现日志文件展示和下载。</p><blockquote><p>前提：需要在创建负载时挂载数据卷，并指定日志目</p></blockquote><p><img src=../../../../../images/image%20%2878%29.png alt></p><p>创建负载以后，在容器内的<code>/data/logdir</code>目录下的所有文件可以展示并下载，例如我们在容器的<code>/data/logdir</code>下新建一个名为<code>a.log</code>的文件，如果有内容的话，也可以在这里展示与下载</p><p><img src=../../../../../images/image%20%28143%29.png alt></p></div><div class=td-content style=page-break-before:always><h1 id=pg-08c4350de537017097f922dfdd8dceaf>4.3.6 -</h1><h1 id=helm应用>Helm应用</h1><h2 id=概念>概念</h2><p><strong>这里业务端用户可以管理通过 helm 创建的应用。</strong></p><h3 id=操作步骤>操作步骤</h3><h4 id=新建helm应用>新建Helm应用</h4><ol><li>登录 TKEStack。</li><li>切换至 【业务管理】控制台，选择【 Helm应用】。</li><li>选择相应【业务】和【namespace】，单击【新建】按钮。如下图所示：</li><li>在“新建Helm应用”页面填写Helm应用信息。如下图所示：</li></ol><ul><li><strong>应用名：</strong> 输入应用名，1～63字符，只能包含小写字母、数字及分隔符("-")，且必须以小写字母开头，数字或小写字母结尾</li><li><strong>命名空间：</strong> 选择该应用运行的命名空间</li><li><strong>Chart_Url：</strong> 输入Chart 文件地址</li><li><strong>类型：</strong> 选择应用类型</li><li><strong>公有：</strong> 公有类型</li><li><strong>私有：</strong> 私有类型<ul><li><strong>用户名：</strong> 私有用户名</li><li><strong>密码：</strong> 私有密码</li></ul></li><li><strong>Key-Value：</strong> 通过Key-Value替换Chart包中默认配置。</li></ul><ol><li>单击【完成】按钮。</li></ol><p><img src=../../images/xin-jian-helm.png alt></p><p><img src=../../images/xin-jian-helm-ying-yong-.png alt></p></div><div class=td-content style=page-break-before:always><h1 id=pg-664c42187cbd9876a7d5ae8a17ec02ce>5 - 开发指引</h1><div class=lead>开发指引</div></div><div class=td-content><h1 id=pg-b5d18f6a5a5de4c1a4b8632ce9d76df1>5.1 - API 使用指引</h1><div class=lead>API 使用指引</div><h2 id=1-调用方式>1. 调用方式</h2><h3 id=11-创建访问凭证>1.1. 创建访问凭证</h3><p>访问【平台管理】控制台，在左侧找到【组织资源】，选择【访问凭证】，新建一个访问凭证。</p><h3 id=12-访问-api>1.2. 访问 API</h3><p>TKEStack上各种资源的接口均以 Kubernetes 原生 API 的形式提供，所有接口使用统一的前缀: <code>http://console.tke.com:8080/platform</code>，请求中需要将上一步申请的访问凭证以<code>"Authorization: Bearer ${访问凭证}"</code>的形式放入 header。</p><p>以查询集群信息为例，使用的请求如下：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>curl -H &#34;Authorization: Bearer xxxxxxx&#34; \
&#34;http://console.tke.com:8080/platform/apis/platform.tkestack.io/v1/clusters&#34;
</code></pre></div><h3 id=13-查看特定集群的-namespace>1.3. 查看特定集群的 Namespace</h3><p>查看集群所包含的 Namespace 需要传递 &ldquo;X-TKE-ClusterName: cls-xxx&rdquo; 的 header，cls-xxx 为特定集群 ID</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>curl -H &#34;Authorization: Bearer xxxxxxx&#34; \
-H &#34;X-TKE-ClusterName: cls-xxx&#34; \
&#34;http://console.tke.com:8080/platform/api/v1/namespaces&#34;
</code></pre></div><h2 id=2-通过-api-创建应用>2. 通过 API 创建应用</h2><h3 id=21-非-tapp-应用deploymentstatefulsetdaemonset>2.1. 非 TApp 应用（deployment，statefulset，daemonset）</h3><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>curl &#39;http://console.tke.com:8080/platform/apis/apps/v1/namespaces/命名空间/工作负载类型/工作负载名称&#39; 

-X PATCH

-H &#39;Content-Type:application/strategic-merge-patch+json&#39; 

-H &#39;X-TKE-ClusterName:所属集群&#39;

-H &#39;Authorization: Bearer 访问凭证&#39;

-d &#39;{&#34;spec&#34;:{&#34;template&#34;:{&#34;spec&#34;:{&#34;containers&#34;:[{&#34;name&#34;:&#34;容器名称&#34;,&#34;image&#34;:&#34;容器镜像&#34;}]}}}}&#39;
</code></pre></div><p>工作负载类型： 选择需要更新的工作负载类型（deployment，statefulset， daemonset） 所属集群：填写所要更新容器所属集群。 命名空间：填写所要更新容器所属的命名空间。 工作负载名称：填写所要更新容器的工作负载名称。 容器名称：填写所要更新容器的名称。 访问凭证：填写访问该容器资源的访问凭证，可以在“tkestack-组织资源-访问凭证“中获取该信息（<strong>访问凭证有过期时间，如过期需要重新创建</strong>）。 容器镜像：填写所要更新的Docker镜像</p><h3 id=22-tapp>2.2. TApp</h3><p>TApp 是自研的应用类型，更新镜像需要两步，首先获取当前的容器 spec，调整镜像名后在调用更新接口</p><h4 id=221-获取tapp-spec>2.2.1. 获取tapp spec</h4><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>curl &#39;http://console.tke.com:8080/platform/apis/platform.tkestack.io/v1/clusters/所属集群/tapps?namespace=命名空间&amp;name=工作负载名称&#39;

-X GET

-H &#39;Authorization: Bearer 访问凭证&#39;
</code></pre></div><p>返回值示例：</p><p><code>{"apiVersion":"apps.tkestack.io/v1","kind":"TApp","metadata":{"creationTimestamp":"2020-06-10T13:35:54Z","generation":8,"labels":{"k8s-app":"kevintest","qcloud-app":"kevintest"},"name":"kevintest","namespace":"default","resourceVersion":"13925571","selfLink":"/apis/apps.tkestack.io/v1/namespaces/default/tapps/kevintest","uid":"0269fb69-fa87-42f8-9c3a-e1f96cef40f1"},"spec":{"forceDeletePod":true,"replicas":1,"selector":{"matchLabels":{"k8s-app":"kevintest","qcloud-app":"kevintest"}},"template":{"metadata":{"creationTimestamp":null,"labels":{"k8s-app":"kevintest","qcloud-app":"kevintest","tapp_template_hash_key":"9636164821252331163","tapp_uniq_hash_key":"9518255606018677371"}},"spec":{"containers":[{"image":"mirrors.tencent.com/elsanli/devops-demo:62","imagePullPolicy":"Always","livenessProbe":{"failureThreshold":10,"periodSeconds":10,"successThreshold":1,"tcpSocket":{"port":8888},"timeoutSeconds":2},"name":"test","readinessProbe":{"failureThreshold":10,"periodSeconds":30,"successThreshold":1,"tcpSocket":{"port":8888},"timeoutSeconds":2},"resources":{"limits":{"cpu":"100m","memory":"48Mi"},"requests":{"cpu":"100m","memory":"25Mi"}}}],"restartPolicy":"Always"}},"updateStrategy":{}},"status":{"appStatus":"Running","observedGeneration":7,"readyReplicas":0,"replicas":1,"scaleLabelSelector":"k8s-app=kevintest,qcloud-app=kevintest","statuses":{"0":"Pending"}}}</code></p><h3 id=23-更新-tapp-镜像>2.3. 更新 TApp 镜像</h3><p>从上一步返回值中获取想要更新的整个容器的 spec，替换其中的 image 字段，这样做是为了避免将其他字段覆盖为空</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>curl &#39;&#39;http://console.tke.com:8080/platform/apis/platform.tkestack.io/v1/clusters/所属集群/tapps?namespace=命名空间&amp;name=工作负载名称&#39;

-X PATCH

-H &#39;Content-Type:application/merge-patch+json&#39; 

-H &#39;X-TKE-ClusterName:所属集群&#39;

-H &#39;Authorization: Bearer 访问凭证&#39;

-d &#39;{&#34;spec&#34;:{&#34;template&#34;:{&#34;spec&#34;:{&#34;containers&#34;:[{&#34;name&#34;:&#34;容器名称&#34;,&#34;image&#34;:&#34;容器镜像&#34;,&#34;resources&#34;:{&#34;limits&#34;:{&#34;cpu&#34;:&#34;100m&#34;,&#34;memory&#34;:&#34;48Mi&#34;},&#34;requests&#34;:{&#34;cpu&#34;:&#34;100m&#34;,&#34;memory&#34;:&#34;25Mi&#34;}},&#34;livenessProbe&#34;:{&#34;tcpSocket&#34;:{&#34;port&#34;:8888},&#34;timeoutSeconds&#34;:2,&#34;periodSeconds&#34;:10,&#34;successThreshold&#34;:1,&#34;failureThreshold&#34;:10},&#34;readinessProbe&#34;:{&#34;tcpSocket&#34;:{&#34;port&#34;:8888},&#34;timeoutSeconds&#34;:2,&#34;periodSeconds&#34;:30,&#34;successThreshold&#34;:1,&#34;failureThreshold&#34;:10},&#34;imagePullPolicy&#34;:&#34;Always&#34;}]}},&#34;templates&#34;:null}}
</code></pre></div><p>所属集群：填写所要更新容器所属集群。 命名空间：填写所要更新容器所属的命名空间。 工作负载名称：填写所要更新容器的工作负载名称。 容器名称：填写所要更新容器的名称。 访问凭证：填写访问该容器资源的访问凭证，可以在“tkestack-组织资源-访问凭证“中获取该信息（访问凭证有过期时间，如过期需要重新创建）。 容器镜像：填写所要更新的Docker镜像</p><h2 id=3-通过-api-增删集群节点>3. 通过 API 增删集群节点</h2><p>只能对独立集群的节点进行增删操作，不可操作导入集群。</p><h3 id=31-增加节点>3.1. 增加节点</h3><p>URL: <a href=http://console.tke.com:8080/platform/apis/platform.tkestack.io/v1/machines>http://console.tke.com:8080/platform/apis/platform.tkestack.io/v1/machines</a></p><p>Method: POST</p><p>Headers:</p><ol><li>Content-Type: application/json</li><li>Authorization: Bearer xxx</li></ol><p>按照以下命令的格式，将中文部分替换成实际值，发送请求。请求成功后，会返回被创建的Machine对象。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>curl -X POST \
&#34;http://console.tke.com:8080/platform/apis/platform.tkestack.io/v1/machines&#34; \
-H &#34;Content-Type: application/json&#34; \
-H &#34;Authorization: Bearer 你的访问凭证&#34; \
-d &#39;
{
    &#34;kind&#34;: &#34;Machine&#34;,
    &#34;apiVersion&#34;: &#34;platform.tkestack.io/v1&#34;,
    &#34;metadata&#34;: {
        &#34;generateName&#34;: &#34;mc-&#34;
    },
    &#34;spec&#34;: {
        &#34;finalizers&#34;: [
            &#34;machine&#34;
        ],
        &#34;tenantID&#34;: &#34;租户ID（联系平台管理员获取）&#34;,
        &#34;clusterName&#34;: &#34;集群ID，可通过页面查看（不是集群名称）&#34;,
        &#34;type&#34;: &#34;Baremetal&#34;,
        &#34;ip&#34;: &#34;节点IP&#34;,
        &#34;port&#34;: 节点SSH端口（int）,
        &#34;username&#34;: &#34;root&#34;,
        &#34;password&#34;: &#34;节点root密码(需经base64编码)&#34;
    }
}&#39;
</code></pre></div><p>password base64编码：</p><p><code>echo -n $PASSWORD | base64</code> 假设password原文为123456，则生成的base64编码为MTIzNDU2</p><blockquote><p>PS: 使用 echo 命令时一定加上 -n 参数</p></blockquote><h3 id=32-查看节点>3.2. 查看节点</h3><p>URL: <a href=http://console.tke.com:8080/platform/apis/platform.tkestack.io/v1/machines/$%7Bmachine.metadata.name%7D>http://console.tke.com:8080/platform/apis/platform.tkestack.io/v1/machines/${machine.metadata.name}</a></p><p>Method: GET</p><p>Headers:</p><ol><li>Authorization: Bearer xxx</li></ol><p>假设平台中有 name 为 mc-brd44nzd 的 Machine 对象：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>{
  &#34;kind&#34;: &#34;Machine&#34;,
  &#34;apiVersion&#34;: &#34;platform.tkestack.io/v1&#34;,
  &#34;metadata&#34;: {
    &#34;name&#34;: &#34;mc-brd44nzd&#34;,
    &#34;generateName&#34;: &#34;mc-&#34;,
    &#34;selfLink&#34;: &#34;/apis/platform.tkestack.io/v1/machines/mc-brd44nzd&#34;,
    &#34;uid&#34;: &#34;9ef7c08f-c535-4e99-b11d-9f7d02be19f5&#34;,
    &#34;resourceVersion&#34;: &#34;343953553&#34;,
    &#34;creationTimestamp&#34;: &#34;2020-02-27T00:25:02Z&#34;
  },
  &#34;spec&#34;: {
    &#34;finalizers&#34;: [
      &#34;machine&#34;
    ],
    &#34;tenantID&#34;: &#34;default&#34;,
    &#34;clusterName&#34;: &#34;xxxx&#34;,
    &#34;type&#34;: &#34;Baremetal&#34;,
    &#34;ip&#34;: &#34;xxxxxx&#34;,
    &#34;port&#34;: 36000,
    &#34;username&#34;: &#34;root&#34;,
    &#34;password&#34;: &#34;xxxxxx&#34;
  }
}
</code></pre></div><p>则查看该 Machine 部署进度的请求为：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>curl &#34;http://console.tke.com:8080/platform/apis/platform.tkestack.io/v1/machines/mc-brd44nzd&#34; \
-H &#34;Authorization: Bearer 你的访问凭证&#34;
</code></pre></div><h3 id=33-删除节点>3.3. 删除节点</h3><p>URL: <a href=http://console.tke.com:8080/platform/apis/platform.tkestack.io/v1/machines/$%7Bmachine.metadata.name%7D>http://console.tke.com:8080/platform/apis/platform.tkestack.io/v1/machines/${machine.metadata.name}</a></p><p>Method: DELETE</p><p>Headers:</p><ol><li>Authorization: Bearer xxx</li></ol><p>假设平台中有 name 为 mc-brd44nzd 的 Machine 对象，则删除节点的请求为：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>curl -X DELETE &#34;http://console.tke.com:8080/platform/apis/platform.tkestack.io/v1/machines/mc-brd44nzd&#34; \
-H &#34;Authorization: Bearer 你的访问凭证&#34;
</code></pre></div><h2 id=4-通过-api-获取业务信息>4. 通过 API 获取业务信息</h2><h3 id=41-查看自身所在业务>4.1. 查看自身所在业务</h3><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>curl &#39;http://console.tke.com:8080/business/apis/business.tkestack.io/v1/portal&#39; \
-X GET \
-H &#34;Authorization: Bearer 访问凭证&#34;
</code></pre></div><h3 id=42-查看特定业务包含的-namespace-信息>4.2. 查看特定业务包含的 Namespace 信息</h3><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>curl &#39;http://console.tke.com:8080/business/apis/business.tkestack.io/v1/namespaces/prj-xxx/namespaces&#39; \
-X GET \
-H &#34;Authorization: Bearer 访问凭证&#34;
prj-xxx 为业务 id
</code></pre></div><h3 id=43-查看特定业务信息>4.3. 查看特定业务信息</h3><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>curl &#39;http://console.tke.com:8080/business/apis/business.tkestack.io/v1/projects/prj-xxx&#39; \
-X GET \
-H &#39;Authorization: Bearer 访问凭证&#39;
prj-xxx为业务id
</code></pre></div></div></main></div></div><footer class="bg-dark py-5 row d-print-none"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank rel=noopener href=https://github.com/tkestack/tke aria-label=GitHub><i class="fab fa-github"></i></a></li></ul></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2022 The TKEStack Authors All Rights Reserved</small></div></div></div></footer></div><script src=https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js integrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js integrity=sha384-+YQ4JLhjyBLPDQt//I+STsc9iw4uQqACwlvpslubQzn4u2UU2UFM80nGisd026JF crossorigin=anonymous></script><script src=/web/js/main.min.1911ee3ae98d7d6df3807cd00d8e31ae7d1c08ee0f0bb587529b0483da4e5464.js integrity="sha256-GRHuOumNfW3zgHzQDY4xrn0cCO4PC7WHUpsEg9pOVGQ=" crossorigin=anonymous></script></body></html>